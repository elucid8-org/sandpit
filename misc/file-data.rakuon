{
	｢*｣  => {
		｢index｣ => {
			｢xtrk-targs｣ => {},
			｢toc｣        => [],
			｢modified｣   => "Instant.from-posix(1742118643.203115429)",
			｢defns｣      => {},
			｢config｣     => {
				｢index｣ => False,
				｢toc｣   => False
			},
			｢lang｣       => "en",
			｢type｣       => "glue",
			｢title｣      => "Website contents",
			｢index｣      => {},
			｢subtitle｣   => "Under development with only one language so far"
		}
	},
	｢en｣ => {
		｢type/IO/Notification｣              => {
			｢index｣      => {
				｢Types｣ => {
					｢sub-index｣ => {
						｢FileChanged (FileChangeEvent)｣ => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "SUBTITLE",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢FileChangeEvent (enum)｣        => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "SUBTITLE",
										｢target｣        => "index-entry-"
								}
							],
							｢sub-index｣ => {}
						},
						｢FileRenamed (FileChangeEvent)｣ => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "SUBTITLE"
								}
							]
						}
					},
					｢refs｣      => []
				}
			},
			｢subtitle｣   => "<p id=\"9b42c85\">Asynchronous notification for file and directory changes <span class=\"indexed\" id=\"index-entry-\"></span> <span class=\"indexed\" id=\"index-entry-_0\"></span> <span class=\"indexed\" id=\"index-entry-_0\"></span> </p>",
			｢toc｣        => [
				{
						｢level｣      => 1,
						｢caption｣    => "Methods",
						｢numeration｣ => "",
						｢target｣     => "Methods"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "method_watch-path",
						｢caption｣    => "method watch-path",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "Class relation diagram",
						｢level｣      => 1,
						｢target｣     => "Class_relation_diagram"
				}
			],
			｢config｣     => {
				｢subkind｣  => "class",
				｢kind｣     => "Type",
				｢category｣ => "domain-specific"
			},
			｢modified｣   => "Instant.from-posix(1716570626.140091333)",
			｢xtrk-targs｣ => {},
			｢type｣       => "primary",
			｢title｣      => "class IO::Notification",
			｢defns｣      => {
				｢en#type/IO/Notification#001｣ => {
					｢name｣       => "watch-path",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Notification#001\")},\n      paragraphs  => (\n        \"method watch-path\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"method watch-path(IO::Notification: Str() \\\$path, :\\\$scheduler = \\\$*SCHEDULER)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Supply\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Supply\",\n        )\n      ),\n      \" that emits \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Notification::Change\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Notification::Change\",\n        )\n      ),\n      \" objects.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" is a file, only modifications of that file are reported. If\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" is a directory, both modifications to the directory itself (for\\nexample permission changes) and to files in the directory (including new\\nfiles in the directory) are reported.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$scheduler\",\n        )\n      ),\n      \" named argument allows you to specify which thread scheduler\\nis going to be responsible for the notification stream; it can be omitted if\\nthe default scheduler is used.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"my \\\$supply = IO::Notification.watch-path( \\\"/var/log/syslog\\\" );\\n\\n\\\$supply.tap( -> \\\$v \\\{ say \\\"Got \\\", \\\$v });\\n\\nsleep 60;\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This snippet of code sets a watch on the system log file, emitting the kind\\nof event that has occurred or capturing an error otherwise; the created\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Supply\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Supply\",\n        )\n      ),\n      \" is tapped, and the event printed. It does so for 60 minutes,\\nemitting something like this:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      config     => \$\{:lang(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"text\"),\n        )\n      ))},\n      paragraphs => (\n        \"Got /var/log/syslog: FileChanged\\nGot /var/log/syslog: FileChanged\\nGot /var/log/syslog: FileChanged\\nGot /var/log/syslog: FileChanged\\nGot /var/log/syslog: FileChanged\\nGot /var/log/syslog: FileChanged\\nGot /var/log/syslog: FileChanged\\nGot /var/log/syslog: FileChanged\\n\\n\",\n      )\n    ),\n    \"The only kind of information this method provides is the bare fact that\\nsomething has change or been renamed. You will need to actually open and read\\nthe file or directory to check the actual changes.\\n\\n\",\n  )\n)",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_watch-path"
				}
			}
		},
		｢language/math｣                     => {
			｢defns｣      => {},
			｢index｣      => {},
			｢type｣       => "primary",
			｢subtitle｣   => "Different mathematical paradigms and how they are implemented in this language",
			｢title｣      => "Doing math with Raku",
			｢toc｣        => [
				{
						｢caption｣    => "Arithmetic",
						｢target｣     => "Arithmetic",
						｢numeration｣ => "",
						｢level｣      => 1
				},
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢caption｣    => "Sets",
						｢target｣     => "Sets"
				},
				{
						｢caption｣    => "Sequences",
						｢numeration｣ => "",
						｢target｣     => "Sequences",
						｢level｣      => 1
				},
				{
						｢caption｣    => "Mathematical constants",
						｢numeration｣ => "",
						｢target｣     => "Mathematical_constants",
						｢level｣      => 1
				},
				{
						｢numeration｣ => "",
						｢target｣     => "Numerical_integration_of_ordinary_differential_equations",
						｢caption｣    => "Numerical integration of ordinary differential equations",
						｢level｣      => 1
				},
				{
						｢caption｣    => "Requirements",
						｢target｣     => "Requirements",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "Malthus model",
						｢numeration｣ => "",
						｢target｣     => "Malthus_model",
						｢level｣      => "2"
				},
				{
						｢target｣     => "Step_by_step_explanation",
						｢numeration｣ => "",
						｢level｣      => "3",
						｢caption｣    => "Step by step explanation"
				},
				{
						｢target｣     => "Logistic_model",
						｢numeration｣ => "",
						｢caption｣    => "Logistic model",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "Strong Allee Effect",
						｢numeration｣ => "",
						｢target｣     => "Strong_Allee_Effect",
						｢level｣      => "2"
				},
				{
						｢target｣     => "Weak_Allee_Effect",
						｢caption｣    => "Weak Allee Effect",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢target｣     => "Extra_info",
						｢level｣      => "2",
						｢caption｣    => "Extra info",
						｢numeration｣ => ""
				}
			],
			｢modified｣   => "Instant.from-posix(1735468959.879930777)",
			｢config｣     => {
				｢category｣ => "tutorial",
				｢subkind｣  => "Language",
				｢kind｣     => "Language"
			},
			｢xtrk-targs｣ => {}
		},
		｢routine/basename｣                  => {
			｢modified｣ => "Instant.from-posix(1742118640.619440251)",
			｢title｣    => "The <b>basename</b> routine",
			｢type｣     => "composite",
			｢config｣   => {
				｢kind｣  => "routine",
				｢index｣ => False
			},
			｢subtitle｣ => "From: en/type/IO/Spec/Win32, en/type/IO/Spec/Unix."
		},
		｢all-routines｣                      => {
			｢modified｣   => "Instant.from-posix(1741013229.939900164)",
			｢defns｣      => {},
			｢config｣     => {
				｢no-glossary｣ => True,
				｢no-toc｣      => True,
				｢index｣       => False,
				｢type｣        => "info",
				｢toc｣         => False
			},
			｢title｣      => "Routines in Raku",
			｢type｣       => "info",
			｢xtrk-targs｣ => {},
			｢toc｣        => [],
			｢subtitle｣   => "Searchable table of documented routines",
			｢index｣      => {}
		},
		｢type/IO/Socket/Async/ListenSocket｣ => {
			｢subtitle｣   => "A tap for listening TCP sockets",
			｢xtrk-targs｣ => {},
			｢toc｣        => [
				{
						｢numeration｣ => "",
						｢target｣     => "Methods",
						｢caption｣    => "Methods",
						｢level｣      => 1
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method socket-host",
						｢numeration｣ => "",
						｢target｣     => "method_socket-host"
				},
				{
						｢caption｣    => "method socket-port",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "method_socket-port"
				},
				{
						｢target｣     => "method_native-descriptor",
						｢level｣      => "2",
						｢caption｣    => "method native-descriptor",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "Class relation diagram",
						｢target｣     => "Class_relation_diagram",
						｢numeration｣ => "",
						｢level｣      => 1
				}
			],
			｢defns｣      => {
				｢en#type/IO/Socket/Async/ListenSocket#001｣ => {
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async/ListenSocket#001\")},\n      paragraphs  => (\n        \"method socket-host\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method socket-host(--> Promise)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Promise\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Promise\",\n        )\n      ),\n      \" that will be kept with a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \"\\ncontaining the address of the listening socket.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_socket-host",
					｢subkind｣    => "method",
					｢name｣       => "socket-host"
				},
				｢en#type/IO/Socket/Async/ListenSocket#002｣ => {
					｢targ-in-fn｣ => "method_socket-port",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async/ListenSocket#002\")},\n      paragraphs  => (\n        \"method socket-port\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method socket-port(--> Promise)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Promise\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Promise\",\n        )\n      ),\n      \" that will be kept with an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \"\\ncontaining the port of the listening socket.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "socket-port"
				},
				｢en#type/IO/Socket/Async/ListenSocket#003｣ => {
					｢targ-in-fn｣ => "method_native-descriptor",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢name｣       => "native-descriptor",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async/ListenSocket#003\")},\n      paragraphs  => (\n        \"method native-descriptor\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method native-descriptor(--> Int)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the corresponding file descriptor (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"SOCKET\",\n        )\n      ),\n      \" on Windows) for the\\nlistening socket.\\n\\n\"\n    ),\n  )\n)"
				}
			},
			｢index｣      => {},
			｢config｣     => {
				｢subkind｣  => "class",
				｢category｣ => "domain-specific",
				｢kind｣     => "Type"
			},
			｢modified｣   => "Instant.from-posix(1716570626.140091333)",
			｢title｣      => "class IO::Socket::Async::ListenSocket",
			｢type｣       => "primary"
		},
		｢routine/Str｣                       => {
			｢subtitle｣ => "From: en/type/IO/Special, en/type/IO/CatHandle.",
			｢modified｣ => "Instant.from-posix(1742118640.462549473)",
			｢type｣     => "composite",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢title｣    => "The <b>Str</b> routine"
		},
		｢type/IO/Spec｣                      => {
			｢modified｣   => "Instant.from-posix(1716570626.140091333)",
			｢xtrk-targs｣ => {},
			｢subtitle｣   => "Platform specific operations on file and directory paths",
			｢config｣     => {
				｢kind｣     => "Type",
				｢category｣ => "domain-specific",
				｢subkind｣  => "class"
			},
			｢defns｣      => {},
			｢index｣      => {},
			｢title｣      => "class IO::Spec",
			｢type｣       => "primary",
			｢toc｣        => [
				{
						｢target｣     => "About_sub-classes_IO::Spec::*",
						｢caption｣    => "About sub-classes IO::Spec::*",
						｢level｣      => 1,
						｢numeration｣ => ""
				},
				{
						｢target｣     => "Methods",
						｢level｣      => 1,
						｢numeration｣ => "",
						｢caption｣    => "Methods"
				},
				{
						｢target｣     => "Class_relation_diagram",
						｢level｣      => 1,
						｢caption｣    => "Class relation diagram",
						｢numeration｣ => ""
				}
			]
		},
		｢routine/print｣                     => {
			｢subtitle｣ => "From: en/type/IO/Socket, en/type/IO/Socket/Async, en/type/IO/Socket/Async.",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢type｣     => "composite",
			｢modified｣ => "Instant.from-posix(1742118640.561399791)",
			｢title｣    => "The <b>print</b> routine"
		},
		｢type/IO/Special｣                   => {
			｢defns｣      => {
				｢en#type/IO/Special#011｣ => {
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#011\")},\n      paragraphs  => (\n        \"method r\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method r(IO::Special:D: --> Bool)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The 'read access' file test operator, returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if and only if\\nthis instance represents the standard input handle(\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"<STDIN>\",\n        )\n      ),\n      \").\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_r",
					｢name｣       => "r",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Special#010｣ => {
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_l",
					｢name｣       => "l",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#010\")},\n      paragraphs  => (\n        \"method l\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method l(IO::Special:D: --> False)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The 'symbolic links' file test operator, always returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#type/IO/Special#015｣ => {
					｢targ-in-fn｣ => "method_accessed",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#015\")},\n      paragraphs  => (\n        \"method accessed\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method accessed(IO::Special:D: --> Instant)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The last accessed time for the filehandle.\\nIt always returns an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Instant\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Instant\",\n        )\n      ),\n      \" type\\nobject.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "accessed",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Special#001｣ => {
					｢targ-in-fn｣ => "method_new",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#001\")},\n      paragraphs  => (\n        \"method new\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      config     => \$\{:skip-test(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"compile time error\"),\n        )\n      ))},\n      paragraphs => (\n        \"method new(:\\\$!what!)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Takes a single required attribute \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"what\",\n        ),\n        meta   => (\n          \"/routine/what\",\n        )\n      ),\n      \". It is unlikely that you will ever\\nneed to construct one of these objects yourself.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "new",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Special#014｣ => {
					｢targ-in-fn｣ => "method_modified",
					｢subkind｣    => "method",
					｢name｣       => "modified",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#014\")},\n      paragraphs  => (\n        \"method modified\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method modified(IO::Special:D: --> Instant)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The last modified time for the filehandle.\\nIt always returns an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Instant\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Instant\",\n        )\n      ),\n      \" type\\nobject.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#type/IO/Special#004｣ => {
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#004\")},\n      paragraphs  => (\n        \"method Str\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method Str(IO::Special:D:)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"'<STDIN>'\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"'<STDOUT>'\",\n        )\n      ),\n      \", or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"'<STDERR>'\",\n        )\n      ),\n      \" as appropriate.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢name｣       => "Str",
					｢targ-in-fn｣ => "method_Str"
				},
				｢en#type/IO/Special#007｣ => {
					｢name｣       => "d",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#007\")},\n      paragraphs  => (\n        \"method d\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method d(IO::Special:D: --> False)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The 'directory' file test operator, always returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_d"
				},
				｢en#type/IO/Special#005｣ => {
					｢kind｣       => "routine",
					｢name｣       => "IO",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_IO",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#005\")},\n      paragraphs  => (\n        \"method IO\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method IO(IO::Special:D: --> IO::Special)\\n\\n\",\n      )\n    ),\n    \"Returns the invocant.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say \\\$*IN.path.IO.what;  # OUTPUT: «<STDIN>␤»\\nsay \\\$*IN.path.what;     # OUTPUT: «<STDIN>␤»\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#type/IO/Special#003｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#003\")},\n      paragraphs  => (\n        \"method WHICH\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method WHICH(IO::Special:D: --> Str)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This returns a string that identifies the object. The string is composed by the\\ntype of the instance (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Special\",\n        )\n      ),\n      \") and the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"what\",\n        )\n      ),\n      \" attribute:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"\\\$*IN.path.what;  # OUTPUT: «<STDIN>␤»\\n\\\$*IN.path.WHICH; # OUTPUT: «IO::Special<STDIN>␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢name｣       => "WHICH",
					｢targ-in-fn｣ => "method_WHICH",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Special#016｣ => {
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#016\")},\n      paragraphs  => (\n        \"method changed\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method changed(IO::Special:D: --> Instant)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The last changed time for the filehandle.\\nIt always returns an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Instant\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Instant\",\n        )\n      ),\n      \" type\\nobject.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "changed",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_changed"
				},
				｢en#type/IO/Special#017｣ => {
					｢subkind｣    => "method",
					｢name｣       => "mode",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_mode",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#017\")},\n      paragraphs  => (\n        \"method mode\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method mode(IO::Special:D: --> Nil)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The mode for the filehandle, it always returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#type/IO/Special#002｣ => {
					｢targ-in-fn｣ => "method_what",
					｢name｣       => "what",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#002\")},\n      paragraphs  => (\n        \"method what\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say \\\$*IN.path.what;  # OUTPUT: «<STDIN>␤»\\nsay \\\$*OUT.path.what; # OUTPUT: «<STDOUT>␤»\\nsay \\\$*ERR.path.what; # OUTPUT: «<STDERR>␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns one of the strings \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"'<STDIN>'\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"'<STDOUT>'\",\n        )\n      ),\n      \", or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"'<STDERR>'\",\n        )\n      ),\n      \",\\nspecifying the type of the special IO device.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#type/IO/Special#009｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#009\")},\n      paragraphs  => (\n        \"method s\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method s(IO::Special:D: --> 0)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The 'size' file test operator, always returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"0\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_s",
					｢name｣       => "s"
				},
				｢en#type/IO/Special#008｣ => {
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_f",
					｢name｣       => "f",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#008\")},\n      paragraphs  => (\n        \"method f\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method f(IO::Special:D: --> False)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The 'file' file test operator, always returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Special#013｣ => {
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_x",
					｢name｣       => "x",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#013\")},\n      paragraphs  => (\n        \"method x\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method x(IO::Special:D: --> False)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The 'execute access' file test operator, always returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Special#012｣ => {
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_w",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#012\")},\n      paragraphs  => (\n        \"method w\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method w(IO::Special:D: --> Bool)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The 'write access' file test operator, returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \"\\nonly if this instance represents either the standard output (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"<STOUT>\",\n        )\n      ),\n      \")\\nor the standard error (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"<STDERR>\",\n        )\n      ),\n      \") handle.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "w"
				},
				｢en#type/IO/Special#006｣ => {
					｢kind｣       => "routine",
					｢name｣       => "e",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_e",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Special#006\")},\n      paragraphs  => (\n        \"method e\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method e(IO::Special:D: --> True)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The 'exists' file test operator, always returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)"
				}
			},
			｢toc｣        => [
				{
						｢target｣     => "Methods",
						｢caption｣    => "Methods",
						｢level｣      => 1,
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "method new",
						｢level｣      => "2",
						｢target｣     => "method_new"
				},
				{
						｢target｣     => "method_what",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method what"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "method_WHICH",
						｢caption｣    => "method WHICH",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method Str",
						｢numeration｣ => "",
						｢target｣     => "method_Str"
				},
				{
						｢target｣     => "method_IO",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method IO"
				},
				{
						｢caption｣    => "method e",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "method_e"
				},
				{
						｢target｣     => "method_d",
						｢numeration｣ => "",
						｢caption｣    => "method d",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "method f",
						｢target｣     => "method_f",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "method s",
						｢target｣     => "method_s",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "method l",
						｢level｣      => "2",
						｢target｣     => "method_l",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "method r",
						｢level｣      => "2",
						｢target｣     => "method_r",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "method w",
						｢numeration｣ => "",
						｢target｣     => "method_w",
						｢level｣      => "2"
				},
				{
						｢target｣     => "method_x",
						｢numeration｣ => "",
						｢caption｣    => "method x",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "method modified",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_modified"
				},
				{
						｢caption｣    => "method accessed",
						｢target｣     => "method_accessed",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "method changed",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_changed"
				},
				{
						｢target｣     => "method_mode",
						｢numeration｣ => "",
						｢caption｣    => "method mode",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢caption｣    => "Class relation diagram",
						｢target｣     => "Class_relation_diagram"
				}
			],
			｢index｣      => {},
			｢title｣      => "class IO::Special",
			｢subtitle｣   => "Path to special I/O device",
			｢type｣       => "primary",
			｢config｣     => {
				｢kind｣     => "Type",
				｢subkind｣  => "class",
				｢category｣ => "domain-specific"
			},
			｢xtrk-targs｣ => {},
			｢modified｣   => "Instant.from-posix(1716570626.140091333)"
		},
		｢operator/%5E｣                      => {
			｢title｣    => "The <b>^</b> operator",
			｢subtitle｣ => "From: en/language/operators, en/language/operators.",
			｢modified｣ => "Instant.from-posix(1742118639.198909241)",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "operator"
			},
			｢type｣     => "composite"
		},
		｢type/IO/Socket/INET｣               => {
			｢modified｣   => "Instant.from-posix(1730070864.910096394)",
			｢title｣      => "class IO::Socket::INET",
			｢config｣     => {
				｢kind｣     => "Type",
				｢subkind｣  => "class",
				｢category｣ => "domain-specific"
			},
			｢type｣       => "primary",
			｢xtrk-targs｣ => {},
			｢toc｣        => [
				{
						｢numeration｣ => "",
						｢caption｣    => "Methods",
						｢level｣      => 1,
						｢target｣     => "Methods"
				},
				{
						｢caption｣    => "method new",
						｢target｣     => "method_new",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "Methods",
						｢numeration｣ => "",
						｢level｣      => 1,
						｢target｣     => "Methods_0"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "method_get",
						｢level｣      => "2",
						｢caption｣    => "method get"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "method lines",
						｢level｣      => "2",
						｢target｣     => "method_lines"
				},
				{
						｢target｣     => "method_accept",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method accept"
				},
				{
						｢target｣     => "Class_relation_diagram",
						｢caption｣    => "Class relation diagram",
						｢numeration｣ => "",
						｢level｣      => 1
				}
			],
			｢defns｣      => {
				｢en#type/IO/Socket/INET#001｣ => {
					｢targ-in-fn｣ => "method_new",
					｢name｣       => "new",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/INET#001\")},\n      paragraphs  => (\n        \"method new\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"multi method new(\\n        :\\\$host,\\n        :\\\$port,\\n        :\\\$family = PF_INET,\\n        :\\\$encoding = 'utf-8',\\n        :\\\$nl-in = \\\"\\\\r\\\\n\\\",\\n    --> IO::Socket::INET:D)\\nmulti method new(\\n        :\\\$localhost,\\n        :\\\$localport,\\n        :\\\$family = PF_INET,\\n        :\\\$listen,\\n        :\\\$encoding = 'utf-8',\\n        :\\\$nl-in = \\\"\\\\r\\\\n\\\",\\n    --> IO::Socket::INET:D)\\n\\n\",\n      )\n    ),\n    \"Creates a new socket.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"If \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$listen\",\n        )\n      ),\n      \" is True, creates a new socket that listen on \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$localhost\",\n        )\n      ),\n      \"\\n(which can be an IP address or a domain name) on port \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$localport\",\n        )\n      ),\n      \"; in other words\\nthe \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$listen\",\n        )\n      ),\n      \" flag determines the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"server mode\",\n        )\n      ),\n      \" of the socket.\\nOtherwise (i.e., \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$listen\",\n        )\n      ),\n      \" is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \"), the new socket opens immediately\\na connection to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$host\",\n        )\n      ),\n      \" on port \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$port\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$family\",\n        )\n      ),\n      \" defaults to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"PF_INET\",\n        )\n      ),\n      \" constant for IPv4, and can be set\\nto \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"PF_INET6\",\n        )\n      ),\n      \" constant for IPv6.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"For text operations (such as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"method lines\",\n        ),\n        meta   => (\n          \"#method lines\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"method get\",\n        ),\n        meta   => (\n          \"#method get\",\n        )\n      ),\n      \"),\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$encoding\",\n        )\n      ),\n      \" specifies the encoding, and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$nl-in\",\n        )\n      ),\n      \" determines\\nthe character(s) that separate lines.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Socket/INET#004｣ => {
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/INET#004\")},\n      paragraphs  => (\n        \"method accept\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method accept()\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"In listen/server mode, waits for a new incoming connection.\\nOnce a new connection is established, an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Socket::INET\",\n        )\n      ),\n      \"\\ninstance (or a subclass instance) for consuming\\nthe connection is returned.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_accept",
					｢name｣       => "accept"
				},
				｢en#type/IO/Socket/INET#003｣ => {
					｢kind｣       => "routine",
					｢name｣       => "lines",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/INET#003\")},\n      paragraphs  => (\n        \"method lines\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method lines()\\n\\n\",\n      )\n    ),\n    \"Returns a lazy list of lines read from the socket.\\n\\n\",\n  )\n)",
					｢targ-in-fn｣ => "method_lines"
				},
				｢en#type/IO/Socket/INET#002｣ => {
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/INET#002\")},\n      paragraphs  => (\n        \"method get\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method get()\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Reads a line from the socket and returns it as of type \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \".\\nReturn \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \" on end-of-file (EOF).\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_get",
					｢name｣       => "get"
				}
			},
			｢subtitle｣   => "TCP Socket",
			｢index｣      => {}
		},
		｢routine/peer｣                      => {
			｢modified｣ => "Instant.from-posix(1742118641.383676704)",
			｢title｣    => "The <b>peer</b> routine",
			｢subtitle｣ => "From: en/type/IO/Socket/Async, en/type/IO/Socket/Async.",
			｢type｣     => "composite",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			}
		},
		｢type/IO/Spec/Cygwin｣               => {
			｢toc｣        => [
				{
						｢caption｣    => "Methods",
						｢target｣     => "Methods",
						｢level｣      => 1,
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢target｣     => "method_abs2rel",
						｢level｣      => "2",
						｢caption｣    => "method abs2rel"
				},
				{
						｢caption｣    => "method canonpath",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_canonpath"
				},
				{
						｢caption｣    => "method catdir",
						｢numeration｣ => "",
						｢target｣     => "method_catdir",
						｢level｣      => "2"
				},
				{
						｢target｣     => "method_catpath",
						｢numeration｣ => "",
						｢caption｣    => "method catpath",
						｢level｣      => "2"
				},
				{
						｢target｣     => "method_is-absolute",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method is-absolute"
				},
				{
						｢caption｣    => "method join",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_join"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "method rel2abs",
						｢target｣     => "method_rel2abs"
				},
				{
						｢target｣     => "method_split",
						｢caption｣    => "method split",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "method splitpath",
						｢target｣     => "method_splitpath",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "method tmpdir",
						｢target｣     => "method_tmpdir",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢level｣      => 1,
						｢numeration｣ => "",
						｢caption｣    => "Class relation diagram",
						｢target｣     => "Class_relation_diagram"
				}
			],
			｢title｣      => "class IO::Spec::Cygwin",
			｢xtrk-targs｣ => {},
			｢type｣       => "primary",
			｢defns｣      => {
				｢en#type/IO/Spec/Cygwin#001｣ => {
					｢targ-in-fn｣ => "method_abs2rel",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Cygwin#001\")},\n      paragraphs  => (\n        \"method abs2rel\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method abs2rel(IO::Path:D \\\$path, IO::Path:D \\\$base = \\\$*CWD --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a string that represents \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \", but relative to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$base\",\n        )\n      ),\n      \" path.\\nBoth \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$base\",\n        )\n      ),\n      \" may be relative paths. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$base\",\n        )\n      ),\n      \" defaults to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*CWD\",\n        )\n      ),\n      \".\\nUses \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Spec::Win32\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Spec::Win32\",\n        )\n      ),\n      \"'s semantics.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "abs2rel",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Spec/Cygwin#007｣ => {
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢name｣       => "rel2abs",
					｢targ-in-fn｣ => "method_rel2abs",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Cygwin#007\")},\n      paragraphs  => (\n        \"method rel2abs\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method rel2abs(|c --> List:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Spec::Win32.rel2abs\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Spec::Win32#method_rel2abs\",\n        )\n      ),\n      \",\\nexcept replaces backslashes with slashes in the final result.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#type/IO/Spec/Cygwin#009｣ => {
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Cygwin#009\")},\n      paragraphs  => (\n        \"method splitpath\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method splitpath(|c --> List:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Spec::Win32.splitpath\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Spec::Win32#method_splitpath\",\n        )\n      ),\n      \",\\nexcept replaces backslashes with slashes in all the values of the final result.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "splitpath",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_splitpath"
				},
				｢en#type/IO/Spec/Cygwin#008｣ => {
					｢kind｣       => "routine",
					｢name｣       => "split",
					｢targ-in-fn｣ => "method_split",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Cygwin#008\")},\n      paragraphs  => (\n        \"method split\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method split(IO::Spec::Cygwin: Cool:D \\\$path)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Spec::Win32.split\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Spec::Win32#method_split\",\n        )\n      ),\n      \",\\nexcept it replaces backslashes with slashes in all the values of the\\nfinal result.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#type/IO/Spec/Cygwin#005｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Cygwin#005\")},\n      paragraphs  => (\n        \"method is-absolute\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method is-absolute(Str:D \\\$path --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" starts with a slash (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\"/\\\"\",\n        )\n      ),\n      \") or backslash\\n(\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\"\\\\\\\"\",\n        )\n      ),\n      \"), even if they have combining character on them, optionally preceded by\\na volume:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say IO::Spec::Cygwin.is-absolute: \\\"/foo\\\";        # OUTPUT: «True␤»\\nsay IO::Spec::Cygwin.is-absolute: \\\"/\\\\x[308]foo\\\"; # OUTPUT: «True␤»\\nsay IO::Spec::Cygwin.is-absolute: ｢C:\\\\foo｣;      # OUTPUT: «True␤»\\nsay IO::Spec::Cygwin.is-absolute: \\\"bar\\\";         # OUTPUT: «False␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_is-absolute",
					｢name｣       => "is-absolute",
					｢subkind｣    => "method",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Spec/Cygwin#003｣ => {
					｢targ-in-fn｣ => "method_catdir",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Cygwin#003\")},\n      paragraphs  => (\n        \"method catdir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method catdir (*\\\@parts --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Concatenates multiple path fragments and returns the canonical representation\\nof the resultant path as a string. The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@parts\",\n        )\n      ),\n      \" are \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" objects\\nand are allowed to contain path separators.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Cygwin.catdir(<foo/bar ber raku>).say;\\n# OUTPUT: «foo/bar/ber/raku␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢name｣       => "catdir",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Spec/Cygwin#010｣ => {
					｢name｣       => "tmpdir",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Cygwin#010\")},\n      paragraphs  => (\n        \"method tmpdir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method tmpdir(--> IO::Path:D)\\n\\n\",\n      )\n    ),\n    \"Attempts to locate a system's temporary directory by checking several typical directories and environment variables. Uses current directory if no suitable directories are found.\\n\\n\",\n  )\n)",
					｢targ-in-fn｣ => "method_tmpdir",
					｢kind｣       => "routine",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Spec/Cygwin#002｣ => {
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_canonpath",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Cygwin#002\")},\n      paragraphs  => (\n        \"method canonpath\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method canonpath(Str() \\\$path, :\\\$parent --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a string that is a canonical representation of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \". If \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$parent\",\n        )\n      ),\n      \"\\nis set to true, will also clean up references to parent directories. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NOTE:\",\n        )\n      ),\n      \"\\nthe routine does not access the filesystem.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Cygwin.canonpath(｢C:\\\\foo\\\\\\\\..\\\\bar\\\\..\\\\ber｣).say;\\n# OUTPUT: «C:/foo/../bar/../ber␤»\\n\\nIO::Spec::Cygwin.canonpath(\\\"foo///./../bar/../ber\\\").say;\\n# OUTPUT: «foo/../bar/../ber␤»\\n\\nIO::Spec::Cygwin.canonpath(\\\"foo///./../bar/../ber\\\", :parent).say;\\n# OUTPUT: «ber␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢name｣       => "canonpath"
				},
				｢en#type/IO/Spec/Cygwin#004｣ => {
					｢name｣       => "catpath",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_catpath",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Cygwin#004\")},\n      paragraphs  => (\n        \"method catpath\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method catpath (Str:D \\\$volume, Str:D \\\$dir, Str:D \\\$file --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Spec::Win32.catpath\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Spec::Win32#method_catpath\",\n        )\n      ),\n      \",\\nexcept will also change all backslashes to slashes at the end:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Cygwin.catpath('C:', '/some/dir', 'foo.txt').say;\\n# OUTPUT: «C:/some/dir/foo.txt␤»\\n\\nIO::Spec::Cygwin.catpath('C:', '/some/dir', '').say;\\n# OUTPUT: «C:/some/dir␤»\\n\\nIO::Spec::Cygwin.catpath('', '/some/dir', 'foo.txt').say;\\n# OUTPUT: «/some/dir/foo.txt␤»\\n\\nIO::Spec::Cygwin.catpath('E:', '', 'foo.txt').say;\\n# OUTPUT: «E:foo.txt␤»\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#type/IO/Spec/Cygwin#006｣ => {
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Cygwin#006\")},\n      paragraphs  => (\n        \"method join\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method join(|c)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Spec::Win32.join\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Spec::Win32#method_join\",\n        )\n      ),\n      \", except\\nreplaces backslashes with slashes in the final result.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_join",
					｢subkind｣    => "method",
					｢name｣       => "join"
				}
			},
			｢modified｣   => "Instant.from-posix(1716570626.140091333)",
			｢config｣     => {
				｢kind｣     => "Type",
				｢subkind｣  => "class",
				｢category｣ => "domain-specific"
			},
			｢index｣      => {},
			｢subtitle｣   => "Platform specific operations on file and directory paths for Cygwin"
		},
		｢routine/get｣                       => {
			｢type｣     => "composite",
			｢subtitle｣ => "From: en/type/IO/Socket, en/type/IO/Socket/INET, en/type/IO/CatHandle.",
			｢modified｣ => "Instant.from-posix(1742118641.04941545)",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢title｣    => "The <b>get</b> routine"
		},
		｢routine/canonpath｣                 => {
			｢modified｣ => "Instant.from-posix(1742118641.495298765)",
			｢subtitle｣ => "From: en/type/IO/Spec/Cygwin, en/type/IO/Spec/QNX, en/type/IO/Spec/Win32, en/type/IO/Spec/Unix.",
			｢type｣     => "composite",
			｢title｣    => "The <b>canonpath</b> routine",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			}
		},
		｢routine/rel2abs｣                   => {
			｢type｣     => "composite",
			｢modified｣ => "Instant.from-posix(1742118641.839854344)",
			｢subtitle｣ => "From: en/type/IO/Spec/Cygwin, en/type/IO/Spec/Win32, en/type/IO/Spec/Unix.",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢title｣    => "The <b>rel2abs</b> routine"
		},
		｢operator/temp｣                     => {
			｢modified｣ => "Instant.from-posix(1742118639.738618617)",
			｢subtitle｣ => "From: en/language/operators, en/language/variables.",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "operator"
			},
			｢type｣     => "composite",
			｢title｣    => "The <b>temp</b> operator"
		},
		｢operator/~｣                        => {
			｢config｣   => {
				｢kind｣  => "operator",
				｢index｣ => False
			},
			｢subtitle｣ => "From: en/language/operators, en/language/operators.",
			｢type｣     => "composite",
			｢title｣    => "The <b>~</b> operator",
			｢modified｣ => "Instant.from-posix(1742118639.527886005)"
		},
		｢type/IO/Pipe｣                      => {
			｢title｣      => "class IO::Pipe",
			｢modified｣   => "Instant.from-posix(1716570626.140091333)",
			｢subtitle｣   => "Buffered inter-process string or binary stream",
			｢defns｣      => {
				｢en#type/IO/Pipe#001｣ => {
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_close",
					｢subkind｣    => "method",
					｢name｣       => "close",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Pipe#001\")},\n      paragraphs  => (\n        \"method close\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method close(IO::Pipe: --> Proc:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Closes the pipe and returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Proc\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Proc\",\n        )\n      ),\n      \" object from which the pipe originates.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#type/IO/Pipe#004｣ => {
					｢name｣       => "proc",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Pipe#004\")},\n      paragraphs  => (\n        \"method proc\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method proc(IO::Pipe: --> Proc:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Proc\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Proc\",\n        )\n      ),\n      \" object from which the pipe originates.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_proc"
				},
				｢en#type/IO/Pipe#003｣ => {
					｢kind｣       => "routine",
					｢name｣       => "path",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Pipe#003\")},\n      paragraphs  => (\n        \"method path\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method path(IO::Pipe: --> IO::Path:U)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Path\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Path\",\n        )\n      ),\n      \" type object.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_path"
				},
				｢en#type/IO/Pipe#002｣ => {
					｢name｣       => "IO",
					｢targ-in-fn｣ => "method_IO",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Pipe#002\")},\n      paragraphs  => (\n        \"method IO\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method IO(IO::Pipe: --> IO::Path:U)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Path\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Path\",\n        )\n      ),\n      \" type object.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢kind｣       => "routine"
				}
			},
			｢config｣     => {
				｢kind｣     => "Type",
				｢subkind｣  => "class",
				｢category｣ => "domain-specific"
			},
			｢index｣      => {},
			｢toc｣        => [
				{
						｢caption｣    => "Methods",
						｢numeration｣ => "",
						｢target｣     => "Methods",
						｢level｣      => 1
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method close",
						｢numeration｣ => "",
						｢target｣     => "method_close"
				},
				{
						｢target｣     => "method_IO",
						｢caption｣    => "method IO",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method path",
						｢numeration｣ => "",
						｢target｣     => "method_path"
				},
				{
						｢target｣     => "method_proc",
						｢caption｣    => "method proc",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢level｣      => 1,
						｢numeration｣ => "",
						｢caption｣    => "Class relation diagram",
						｢target｣     => "Class_relation_diagram"
				}
			],
			｢xtrk-targs｣ => {},
			｢type｣       => "primary"
		},
		｢routine/splitpath｣                 => {
			｢modified｣ => "Instant.from-posix(1742118641.701187558)",
			｢subtitle｣ => "From: en/type/IO/Spec/Cygwin, en/type/IO/Spec/Win32, en/type/IO/Spec/Unix.",
			｢title｣    => "The <b>splitpath</b> routine",
			｢type｣     => "composite",
			｢config｣   => {
				｢kind｣  => "routine",
				｢index｣ => False
			}
		},
		｢routine/splitdir｣                  => {
			｢subtitle｣ => "From: en/type/IO/Spec/Win32, en/type/IO/Spec/Unix.",
			｢config｣   => {
				｢kind｣  => "routine",
				｢index｣ => False
			},
			｢title｣    => "The <b>splitdir</b> routine",
			｢modified｣ => "Instant.from-posix(1742118641.594771032)",
			｢type｣     => "composite"
		},
		｢routine/path｣                      => {
			｢modified｣ => "Instant.from-posix(1742118642.103024948)",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢subtitle｣ => "From: en/type/IO/Pipe, en/type/IO/Spec/Win32, en/type/IO/Notification/Change, en/type/IO/Spec/Unix, en/type/IO/CatHandle.",
			｢type｣     => "composite",
			｢title｣    => "The <b>path</b> routine"
		},
		｢routine/catdir｣                    => {
			｢subtitle｣ => "From: en/type/IO/Spec/Cygwin, en/type/IO/Spec/Win32, en/type/IO/Spec/Unix.",
			｢type｣     => "composite",
			｢config｣   => {
				｢kind｣  => "routine",
				｢index｣ => False
			},
			｢modified｣ => "Instant.from-posix(1742118640.889044613)",
			｢title｣    => "The <b>catdir</b> routine"
		},
		｢index｣                             => {
			｢subtitle｣   => "",
			｢title｣      => "English Index",
			｢index｣      => {},
			｢config｣     => {
				｢no-toc｣      => True,
				｢no-meta｣     => True,
				｢no-glossary｣ => True,
				｢direct-wrap｣ => True
			},
			｢defns｣      => {},
			｢xtrk-targs｣ => {},
			｢toc｣        => [],
			｢modified｣   => "Instant.from-posix(1736715076.606690253)",
			｢type｣       => "glue"
		},
		｢routine/socket｣                    => {
			｢config｣   => {
				｢kind｣  => "routine",
				｢index｣ => False
			},
			｢title｣    => "The <b>socket</b> routine",
			｢modified｣ => "Instant.from-posix(1742118640.506913088)",
			｢type｣     => "composite",
			｢subtitle｣ => "From: en/type/IO/Socket/Async/ListenSocket, en/type/IO/Socket/Async/ListenSocket, en/type/IO/Socket/Async, en/type/IO/Socket/Async."
		},
		｢routine/devnull｣                   => {
			｢title｣    => "The <b>devnull</b> routine",
			｢type｣     => "composite",
			｢modified｣ => "Instant.from-posix(1742118642.245441609)",
			｢subtitle｣ => "From: en/type/IO/Spec/Win32, en/type/IO/Spec/Unix.",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			}
		},
		｢language/REPL｣                     => {
			｢subtitle｣   => "Read-eval-print loop",
			｢title｣      => "REPL",
			｢modified｣   => "Instant.from-posix(1716570626.128091464)",
			｢index｣      => {},
			｢xtrk-targs｣ => {},
			｢config｣     => {
				｢kind｣     => "Language",
				｢category｣ => "tutorial",
				｢subkind｣  => "Language"
			},
			｢toc｣        => [
				{
						｢numeration｣ => "",
						｢caption｣    => "Overview",
						｢level｣      => 1,
						｢target｣     => "Overview"
				},
				{
						｢level｣      => 1,
						｢numeration｣ => "",
						｢caption｣    => "Trap",
						｢target｣     => "Trap"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "non-interactive_mode",
						｢caption｣    => "non-interactive mode",
						｢level｣      => 1
				},
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢target｣     => "sub_repl()",
						｢caption｣    => "sub repl()"
				},
				{
						｢caption｣    => "ENVIRONMENT Variables",
						｢target｣     => "ENVIRONMENT_Variables",
						｢numeration｣ => "",
						｢level｣      => 1
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "Get command line history",
						｢target｣     => "Get_command_line_history"
				}
			],
			｢type｣       => "primary",
			｢defns｣      => {
				｢en#language/REPL#001｣ => {
					｢name｣       => "repl()",
					｢targ-in-fn｣ => "sub_repl()",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/REPL#001\")},\n      paragraphs  => (\n        \"sub repl()\\n\\n\",\n      )\n    ),\n    \"This routine allows you to embed a REPL inside a larger script and have access to all\\nthe variables in context.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"sub repl()\",\n        ),\n        meta   => (\n          \"/type/independent-routines#sub_repl\",\n        )\n      ),\n      \" in Independent Routines for more\\ninformation.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "sub",
					｢kind｣       => "routine"
				}
			}
		},
		｢operator/let｣                      => {
			｢title｣    => "The <b>let</b> operator",
			｢config｣   => {
				｢kind｣  => "operator",
				｢index｣ => False
			},
			｢type｣     => "composite",
			｢modified｣ => "Instant.from-posix(1742118639.283793873)",
			｢subtitle｣ => "From: en/language/operators, en/language/variables."
		},
		｢operator/%2F%2F｣                   => {
			｢type｣     => "composite",
			｢title｣    => "The <b>//</b> operator",
			｢modified｣ => "Instant.from-posix(1742118639.566047179)",
			｢subtitle｣ => "From: en/language/operators, en/language/operators.",
			｢config｣   => {
				｢kind｣  => "operator",
				｢index｣ => False
			}
		},
		｢all-operators｣                     => {
			｢xtrk-targs｣ => {},
			｢modified｣   => "Instant.from-posix(1741016460.359613791)",
			｢title｣      => "Operators in Raku",
			｢index｣      => {},
			｢toc｣        => [],
			｢type｣       => "glue",
			｢subtitle｣   => "Searchable table of documented operators",
			｢config｣     => {
				｢toc｣ => False
			},
			｢defns｣      => {}
		},
		｢operator/%7C｣                      => {
			｢config｣   => {
				｢kind｣  => "operator",
				｢index｣ => False
			},
			｢modified｣ => "Instant.from-posix(1742118640.105964895)",
			｢title｣    => "The <b>|</b> operator",
			｢subtitle｣ => "From: en/language/operators, en/language/operators.",
			｢type｣     => "composite"
		},
		｢routine/dir｣                       => {
			｢modified｣ => "Instant.from-posix(1742118641.35834486)",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢title｣    => "The <b>dir</b> routine",
			｢type｣     => "composite",
			｢subtitle｣ => "From: en/type/IO/Spec/Win32, en/type/IO/Spec/Unix."
		},
		｢routine/native｣                    => {
			｢type｣     => "composite",
			｢modified｣ => "Instant.from-posix(1742118642.421151422)",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢subtitle｣ => "From: en/type/IO/Socket/Async/ListenSocket, en/type/IO/Socket, en/type/IO/Socket/Async, en/type/IO/CatHandle.",
			｢title｣    => "The <b>native</b> routine"
		},
		｢miscellaneous｣                     => {
			｢type｣       => "glue",
			｢title｣      => "Raku language - other",
			｢subtitle｣   => "Miscellaneous categories",
			｢xtrk-targs｣ => {},
			｢defns｣      => {},
			｢modified｣   => "Instant.from-posix(1741016460.363613656)",
			｢index｣      => {},
			｢toc｣        => [
				{
						｢level｣      => 1,
						｢numeration｣ => "",
						｢caption｣    => (
							"Advanced",
							"topics"
						),
						｢target｣     => "Advanced_topics"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "Programs",
						｢level｣      => 1,
						｢target｣     => "Programs"
				}
			],
			｢config｣     => {
				｢no-toc｣               => True,
				｢page-content-one-col｣ => True,
				｢no-glossary｣          => True
			}
		},
		｢routine/split｣                     => {
			｢modified｣ => "Instant.from-posix(1742118641.324060934)",
			｢title｣    => "The <b>split</b> routine",
			｢type｣     => "composite",
			｢config｣   => {
				｢kind｣  => "routine",
				｢index｣ => False
			},
			｢subtitle｣ => "From: en/type/IO/Spec/Cygwin, en/type/IO/Spec/Win32, en/type/IO/Spec/Unix, en/type/IO/CatHandle."
		},
		｢routine/IO｣                        => {
			｢modified｣ => "Instant.from-posix(1742118640.798383583)",
			｢title｣    => "The <b>IO</b> routine",
			｢type｣     => "composite",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢subtitle｣ => "From: en/type/IO/Pipe, en/type/IO/Special, en/type/IO/Notification/Change, en/type/IO/CatHandle."
		},
		｢operator/%2B｣                      => {
			｢modified｣ => "Instant.from-posix(1742118640.147633978)",
			｢config｣   => {
				｢kind｣  => "operator",
				｢index｣ => False
			},
			｢type｣     => "composite",
			｢subtitle｣ => "From: en/language/operators, en/language/operators.",
			｢title｣    => "The <b>+</b> operator"
		},
		｢reference｣                         => {
			｢type｣       => "glue",
			｢title｣      => "Raku reference material",
			｢modified｣   => "Instant.from-posix(1741016460.319615139)",
			｢config｣     => {
				｢page-content-columns｣ => True,
				｢no-glossary｣          => True
			},
			｢toc｣        => [
				{
						｢level｣      => 1,
						｢caption｣    => (
							"Fundamental",
							"topics"
						),
						｢numeration｣ => "",
						｢target｣     => "Fundamental_topics"
				},
				{
						｢level｣      => 1,
						｢numeration｣ => "",
						｢caption｣    => (
							"General",
							"reference"
						),
						｢target｣     => "General_reference"
				}
			],
			｢xtrk-targs｣ => {},
			｢index｣      => {},
			｢subtitle｣   => "Broader explanations of fundamental topics and descriptions of Types and slangs",
			｢defns｣      => {}
		},
		｢operator/%5B%20%5D｣                => {
			｢modified｣ => "Instant.from-posix(1742118639.828603055)",
			｢title｣    => "The <b>[ ]</b> operator",
			｢config｣   => {
				｢kind｣  => "operator",
				｢index｣ => False
			},
			｢type｣     => "composite",
			｢subtitle｣ => "From: en/language/operators, en/language/operators."
		},
		｢routine/Supply｣                    => {
			｢subtitle｣ => "From: en/type/IO/Socket/Async, en/type/IO/CatHandle.",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢type｣     => "composite",
			｢modified｣ => "Instant.from-posix(1742118641.121976185)",
			｢title｣    => "The <b>Supply</b> routine"
		},
		｢operator/｣                         => {
			｢type｣     => "composite",
			｢subtitle｣ => "From: en/language/operators, en/language/operators, en/language/operators, en/language/operators.",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "operator"
			},
			｢modified｣ => "Instant.from-posix(1742118639.385869268)",
			｢title｣    => "The <b></b> operator"
		},
		｢language/variables｣                => {
			｢modified｣   => "Instant.from-posix(1740907940.598644609)",
			｢defns｣      => {
				｢en#language/variables#019｣ => {
					｢kind｣       => "syntax",
					｢subkind｣    => "variable",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#019\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$¢\",\n            )\n          ),\n          \" variable\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"See the description in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Match\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Match\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Variables,\\\$?FILE\",\n        )\n      ),\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Variables,\\\$?LINE\",\n        )\n      ),\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Variables,::?CLASS\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "\$¢",
					｢targ-in-fn｣ => "The_\$¢_variable"
				},
				｢en#language/variables#015｣ => {
					｢subkind｣    => "prefix",
					｢kind｣       => "operator",
					｢name｣       => "constant",
					｢targ-in-fn｣ => "The_constant_prefix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#015\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"constant\",\n            )\n          ),\n          \" prefix\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"constant\",\n        )\n      ),\n      \" prefix declares that the value it tags is not going to change\\nduring its lifetime.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"constant \\\$pi2 = pi * 2;\\n\\\$pi2 = 6; # OUTPUT: «(exit code 1) Cannot assign to an immutable value␤\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The value is assigned at compile time. Since Raku modules are \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"precompiled\\nautomatically\",\n        ),\n        meta   => (\n          \"/language/compilation\",\n        )\n      ),\n      \", constants defined in modules are not\\nre-evaluated when the program is run. Please check\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"the section on constants in the Terms page\",\n        ),\n        meta   => (\n          \"/language/terms#Constants\",\n        )\n      ),\n      \" for\\nadditional information.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/variables#018｣ => {
					｢kind｣       => "syntax",
					｢targ-in-fn｣ => "The_\$!_variable",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#018\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$!\",\n            )\n          ),\n          \" variable\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$!\",\n        )\n      ),\n      \" is the error variable.  A fresh one is created in every \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"routine\",\n        )\n      ),\n      \".\\nIf a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"try\",\n        )\n      ),\n      \" block or statement prefix catches an exception, that exception\\nis stored in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$!\",\n        )\n      ),\n      \". If no exception was caught, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$!\",\n        )\n      ),\n      \" is set to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note that \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"CATCH\",\n        )\n      ),\n      \" blocks \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"do not\",\n        )\n      ),\n      \" set \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$!\",\n        )\n      ),\n      \". Rather, they set \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" inside\\nthe block to the caught exception.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Also note that the same thread-safety issues apply to the use of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$!\",\n        )\n      ),\n      \" as\\nthey do to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$/\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Language,cursor variable\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "variable",
					｢name｣       => "\$!"
				},
				｢en#language/variables#005｣ => {
					｢kind｣       => "syntax",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#005\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"=\",\n            )\n          ),\n          \" twigil\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,=\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\$=\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\@=\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\%=\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\&=\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"=\",\n        )\n      ),\n      \" twigil is used to access Pod variables. Every Pod block in the\\ncurrent file can be accessed via a Pod object, such as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$=data\",\n        )\n      ),\n      \",\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$=SYNOPSIS\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"=UserBlock\",\n        )\n      ),\n      \". That is: a variable with the same name of\\nthe desired block and a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"=\",\n        )\n      ),\n      \" twigil.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"=begin Foo\\n...\\n=end Foo\\n# after that, \\\$=Foo gives you all Foo-Pod-blocks\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"You may access the Pod tree which contains all Pod structures as a\\nhierarchical data structure through \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$=pod\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note that all those \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$=someBlockName\",\n        )\n      ),\n      \" support the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Positional\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Positional\",\n        )\n      ),\n      \" and the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Associative\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Associative\",\n        )\n      ),\n      \" roles.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "twigil",
					｢targ-in-fn｣ => "The_=_twigil",
					｢name｣       => "="
				},
				｢en#language/variables#007｣ => {
					｢kind｣       => "syntax",
					｢name｣       => "my",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#007\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"my\",\n            )\n          ),\n          \" declarator\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Declaring a variable with \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"my\",\n        )\n      ),\n      \" gives it lexical scope. This means it only\\nexists within the current block. For example:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:skip-test(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"illustrates error\"),\n        )\n      ))},\n      paragraphs => (\n        \"\\\{\\n    my \\\$foo = \\\"bar\\\";\\n    say \\\$foo; # OUTPUT: «\\\"bar\\\"␤»\\n}\\nsay \\\$foo; # Exception! \\\"Variable '\\\$foo' is not declared\\\"\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This dies because \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$foo\",\n        )\n      ),\n      \" is only defined as long as we are in the same\\nscope.\\n\\n\"\n    ),\n    \"In order to create more than one variable with a lexical scope in the same\\nsentence surround the variables with parentheses:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"   \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my ( \\\$foo, \\\$bar );\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"see also \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Declaring a list of variables with lexical or package scope\",\n        ),\n        meta   => (\n          \"/language/variables#index-entry-declaring_a_list_of_variables\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"Additionally, lexical scoping means that variables can be temporarily\\nredefined in a new scope:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$location = \\\"outside\\\";\\n\\nsub outer-location \\\{\\n    # Not redefined:\\n    say \\\$location;\\n}\\n\\nouter-location; # OUTPUT: «outside␤»\\n\\nsub in-building \\\{\\n    my \\\$location = \\\"inside\\\";\\n    say \\\$location;\\n}\\n\\nin-building;    # OUTPUT: «inside␤»\\n\\nouter-location; # OUTPUT: «outside␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If a variable has been redefined, any code that referenced the outer\\nvariable will continue to reference the outer variable. So here,\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\&outer-location\",\n        )\n      ),\n      \" still prints the outer \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$location\",\n        )\n      ),\n      \":\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:skip-test(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"continued example\"),\n        )\n      ))},\n      paragraphs => (\n        \"sub new-location \\\{\\n    my \\\$location = \\\"nowhere\\\";\\n    outer-location;\\n}\\n\\nnew-location; # OUTPUT: «outside␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"To make \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"new-location()\",\n        )\n      ),\n      \" print \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"nowhere\",\n        )\n      ),\n      \", make \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$location\",\n        )\n      ),\n      \" a dynamic variable\\nusing \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"the * twigil\",\n        ),\n        meta   => (\n          \"#The_*_twigil\",\n        )\n      ),\n      \". This twigil makes the compiler look up the\\nsymbol in the calling scope instead of the outer scope after trying the local\\nscope.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"my\",\n        )\n      ),\n      \" is the default scope for subroutines, so \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"my sub x() \\\{}\",\n        )\n      ),\n      \" and\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"sub x() \\\{}\",\n        )\n      ),\n      \" do exactly the same thing.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "The_my_declarator",
					｢subkind｣    => "declarator"
				},
				｢en#language/variables#010｣ => {
					｢kind｣       => "syntax",
					｢targ-in-fn｣ => "The_anon_declarator",
					｢subkind｣    => "declarator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#010\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"anon\",\n            )\n          ),\n          \" declarator\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"anon\",\n        )\n      ),\n      \" declarator prevents a symbol from getting installed in the lexical\\nscope, the method table and everywhere else.\\n\\n\"\n    ),\n    \"For example, you can use it to declare subroutines which know their own name,\\nbut still aren't installed in a scope:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\%operations =\\n    half   => anon sub half(\\\$x) \\\{ \\\$x / 2 },\\n    square => anon sub square(\\\$x) \\\{ \\\$x * \\\$x },\\n    ;\\nsay \\\%operations<square>.name;       # square\\nsay \\\%operations<square>(8);         # 64\\n\\n\",\n      )\n    ),\n    \"Since it is a declarator, it can be applied anywhere anything is declared, for\\ninstance for classes or even sigilless variables.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say anon class þ \\\{};     # OUTPUT: «(þ)␤»\\nsay anon sub þ  \\\{ 42 };  # OUTPUT: «\\\&þ␤»\\n\\n\",\n      )\n    ),\n    \"Since these symbols are not installed in the scope, they can't be used by name.\\nThey are useful, however, if they need to be assigned to an external variable\\nand they need to know their own name, but this can be retrieved using\\nintrospection.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"my \\\$anon-class = anon class \\\{\\n    has \\\$.bar;\\n    method equal( ::?CLASS \\\$foo ) \\\{\\n      return \\\$foo.bar == \\\$.bar;\\n    }\\n};\\nsay \\\$anon-class.new( :3bar).equal( \\\$anon-class.new( :3bar ) );\\n# OUTPUT: «True␤»\\n\\n\\n\\n\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "anon"
				},
				｢en#language/variables#006｣ => {
					｢kind｣       => "syntax",
					｢subkind｣    => "twigil",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#006\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"~\",\n            )\n          ),\n          \" twigil\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\$~\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"~\",\n        )\n      ),\n      \" twigil is for referring to sublanguages (called slangs). The\\nfollowing are useful:\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Variables,\\\$~MAIN\",\n        )\n      ),\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Variables,\\\$~Quote\",\n        )\n      ),\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Variables,\\\$~Quasi\",\n        )\n      ),\n      \"\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Variables,\\\$~Regex\",\n        )\n      ),\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Variables,\\\$~Trans\",\n        )\n      ),\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Variables,\\\$~P5Regex\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"table\",\n      paragraphs => (\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,13),\n          cells          => (\n            \"\\\$~MAIN     \",\n            \"the current main language (e.g., Raku statements)\",\n          )\n        ),\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,13),\n          cells          => (\n            \"\\\$~Quote    \",\n            \"the current root of quoting language\",\n          )\n        ),\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,13),\n          cells          => (\n            \"\\\$~Quasi    \",\n            \"the current root of quasiquoting language\",\n          )\n        ),\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,13),\n          cells          => (\n            \"\\\$~Regex    \",\n            \"the current root of regex language\",\n          )\n        ),\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,13),\n          cells          => (\n            \"\\\$~Trans    \",\n            \"the current root of transliteration language\",\n          )\n        ),\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,13),\n          cells          => (\n            \"\\\$~P5Regex  \",\n            \"the current root of the Perl regex language\",\n          )\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"You \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"augment\",\n        )\n      ),\n      \" these languages in your current lexical scope.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"use MONKEY-TYPING;\\naugment slang Regex \\\{  # derive from \\\$~Regex and then modify \\\$~Regex\\n    token backslash:std<\\\\Y> \\\{ YY };\\n}\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Syntax,supersede\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "The_~_twigil",
					｢name｣       => "~"
				},
				｢en#language/variables#014｣ => {
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#014\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"let\",\n            )\n          ),\n          \" prefix\\n\\n\"\n        ),\n      )\n    ),\n    \"Restores the previous value if the block exits unsuccessfully. A\\nsuccessful exit means the block returned a defined value or a list.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$answer = 42;\\n\\n\\\{\\n    let \\\$answer = 84;\\n    die if not Bool.pick;\\n    CATCH \\\{\\n        default \\\{ say \\\"it's been reset :(\\\" }\\n    }\\n    say \\\"we made it 84 sticks!\\\";\\n}\\n\\nsay \\\$answer;\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"In the above case, if the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Bool.pick\",\n        )\n      ),\n      \" returns true, the answer will\\nstay as 84 because the block returns a defined value (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"say\",\n        )\n      ),\n      \" returns\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \"). Otherwise the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"die\",\n        )\n      ),\n      \" statement will cause the block to exit\\nunsuccessfully, resetting the answer to 42.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Syntax,constant (Prefix)\",\n        )\n      ),\n      \"\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Language,constants (syntax)\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "prefix",
					｢name｣       => "let",
					｢targ-in-fn｣ => "The_let_prefix"
				},
				｢en#language/variables#003｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#003\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"^\",\n            )\n          ),\n          \" twigil\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,^\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\$^\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\@^\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\%^\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\&^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^\",\n        )\n      ),\n      \" twigil declares a formal positional parameter to blocks or subroutines;\\nthat is, variables of the form \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$^variable\",\n        )\n      ),\n      \" are a type of placeholder variable.\\nThey may be used in bare blocks to declare formal parameters to that block. So\\nthe block in the code\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@powers-of-three = 1,3,9…100;\\nsay reduce \\\{ \\\$^b - \\\$^a }, 0, |\\\@powers-of-three;\\n# OUTPUT: «61␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"has two formal parameters, namely \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \". Note that even though \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$^b\",\n        )\n      ),\n      \"\\nappears before \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$^a\",\n        )\n      ),\n      \" in the code, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$^a\",\n        )\n      ),\n      \" is still the first formal parameter\\nto that block. This is because the placeholder variables are sorted in Unicode\\norder.\\n\\n\"\n    ),\n    \"Although it is possible to use nearly any valid identifier as a placeholder\\nvariable, it is recommended to use short names or ones that can be trivially\\nunderstood in the correct order, to avoid surprise on behalf of the reader.\\n\\n\",\n    \"Normal blocks and subroutines may also make use of placeholder variables but\\nonly if they do not have an explicit parameter list.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:skip-test(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"illustrates error\"),\n        )\n      ))},\n      paragraphs => (\n        \"sub say-it    \\\{ say \\\$^a; } # valid\\nsub say-it()  \\\{ say \\\$^a; } # invalid\\n              \\\{ say \\\$^a; } # valid\\n-> \\\$x, \\\$y, \\\$x \\\{ say \\\$^a; } # invalid\\n\",\n      )\n    ),\n    \"Placeholder variables cannot have type constraints or a variable name with a\\nsingle uppercase letter (this is disallowed to enable catching some\\nPerl-isms).\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^\",\n        )\n      ),\n      \" twigil can be combined with any sigil to create a placeholder variable\\nwith that sigil.  The sigil will have its normal semantic effects, as described\\nin the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Sigils table\",\n        ),\n        meta   => (\n          \"#Sigils\",\n        )\n      ),\n      \". Thus \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@^array\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\%^hash\",\n        )\n      ),\n      \", and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\&^fun\",\n        )\n      ),\n      \" are all\\nvalid placeholder variables.\\n\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "syntax",
					｢name｣       => "^",
					｢targ-in-fn｣ => "The_^_twigil",
					｢subkind｣    => "twigil"
				},
				｢en#language/variables#004｣ => {
					｢kind｣       => "syntax",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#004\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \":\",\n            )\n          ),\n          \" twigil\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,:\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\$:\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\@:\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\%:\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\&:\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\",\n        )\n      ),\n      \" twigil declares a formal named parameter to a block or subroutine.\\nVariables declared using this form are a type of placeholder variable too.\\nTherefore the same things that apply to variables declared using the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^\",\n        )\n      ),\n      \"\\ntwigil also apply here (with the exception that they are not positional and\\ntherefore not ordered using Unicode order). For instance:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say \\\{ \\\$:add ?? \\\$^a + \\\$^b !! \\\$^a - \\\$^b }( 4, 5 ) :!add\\n# OUTPUT: «-1␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^\",\n        ),\n        meta   => (\n          \"/syntax/\\\$CIRCUMFLEX_ACCENT\",\n        )\n      ),\n      \" for more details about placeholder variables.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"A note on \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"^\",\n            )\n          ),\n          \" and \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \":\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Unlike other twigils, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"declare\",\n        )\n      ),\n      \" variables, which can then be\\nreferred to without that twigil.  Thus, the previous example could be written as:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say \\\{ \\\$:add ?? \\\$^a + \\\$^b !! \\\$a - \\\$b }( 4, 5 ) :!add      # OUTPUT: «-1␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"That is, once you have used \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$^a\",\n        )\n      ),\n      \" to declare \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \", you can refer to that variable\\nin the same scope with \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"either\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$^a\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \".  The same is true for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\",\n        )\n      ),\n      \": after\\ndeclaring \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$:add\",\n        )\n      ),\n      \", you are free to refer to that declared variable with \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$add\",\n        )\n      ),\n      \" if\\nyou prefer.\\n\\n\"\n    ),\n    \"In some instances, this is just a convenience – but it can be much more significant\\nwhen dealing with nested blocks.  For example:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"\\\{ say \\\$^a; with \\\"inner\\\" \\\{ say \\\$^a } }(\\\"outer\\\");       # OUTPUT: «outer␤inner␤»\\n\\\{ say \\\$^a; with \\\"inner\\\" \\\{ say \\\$a } }(\\\"outer\\\");        # OUTPUT: «outer␤outer␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The first line declares \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"two\",\n        )\n      ),\n      \" formal positional parameters, while the second declares\\nonly one (but refers to it twice).  This can be especially significant with constructs\\nsuch as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"with\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"for\",\n        )\n      ),\n      \", and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"if\",\n        )\n      ),\n      \" that are often used without much consideration of\\nthe fact that they create blocks.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Just like the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^\",\n        )\n      ),\n      \"twigil, the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\",\n        )\n      ),\n      \" twigil can be combined with any sigil; using\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\",\n        )\n      ),\n      \" with a sigil will create a formal named parameter with that sigil (applying\\nthe \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"semantics of that sigil\",\n        ),\n        meta   => (\n          \"#Sigils\",\n        )\n      ),\n      \").  Thus \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@:array\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\%:hash\",\n        )\n      ),\n      \", and\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\&:fun\",\n        )\n      ),\n      \" are all valid, and each creates a formal named parameter with the\\nspecified sigil.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "twigil",
					｢name｣       => ":",
					｢targ-in-fn｣ => "The_:_twigil"
				},
				｢en#language/variables#008｣ => {
					｢name｣       => "our",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#008\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"our\",\n            )\n          ),\n          \" declarator\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"our\",\n        )\n      ),\n      \" variables are created in the scope of the surrounding package. They also create\\nan alias in the lexical scope, therefore they can be used like \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"my\",\n        )\n      ),\n      \" variables as well.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"module M \\\{\\n    our \\\$Var;\\n    # \\\$Var available here\\n}\\n\\n# Available as \\\$M::Var here.\\n\\n\",\n      )\n    ),\n    \"In order to create more than one variable with package scope,\\nat the same time, surround the variables with parentheses:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"   \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"our ( \\\$foo, \\\$bar );\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"see also \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"the section on declaring a list of variables with lexical or package scope\",\n        ),\n        meta   => (\n          \"/language/variables#index-entry-declaring_a_list_of_variables\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Language,declaring a list of variables\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢kind｣       => "syntax",
					｢targ-in-fn｣ => "The_our_declarator",
					｢subkind｣    => "declarator"
				},
				｢en#language/variables#012｣ => {
					｢name｣       => "augment",
					｢kind｣       => "syntax",
					｢targ-in-fn｣ => "The_augment_declarator",
					｢subkind｣    => "declarator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#012\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"augment\",\n            )\n          ),\n          \" declarator\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"With \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"augment\",\n        )\n      ),\n      \", you can add methods, but not attributes, to existing classes and\\ngrammars, provided you activated the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"MONKEY-TYPING\",\n        )\n      ),\n      \" pragma first.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Since classes are usually \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"our\",\n        )\n      ),\n      \" scoped, and thus global, this means modifying\\nglobal state, which is strongly discouraged. For almost all situations, there\\nare better solutions.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"# don't do this\\nuse MONKEY-TYPING;\\naugment class Int \\\{\\n    method is-answer \\\{ self == 42 }\\n}\\nsay 42.is-answer;       # OUTPUT: «True␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"(In this case, the better solution would be to use a\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"function\",\n        ),\n        meta   => (\n          \"/language/functions\",\n        )\n      ),\n      \").\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"For a better, and safer example, this is a practical\\nway to create a class module to extend \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Path\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Path\",\n        )\n      ),\n      \" by\\nadding a currently missing method to yield the part of the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"basename\",\n        )\n      ),\n      \"\\nleft after the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"extension\",\n        )\n      ),\n      \" is removed. (Note there\\nis no clear developer consensus about what to call that\\npart or even how it should be constructed.)\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:solo(RakuAST::Term::Name.new(\n        RakuAST::Name.from-identifier(\"True\")\n      ))},\n      paragraphs => (\n        \"unit class IO::Barename is IO::Path;\\n\\nmethod new(|c) \\\{\\n    return self.IO::Path::new(|c);\\n}\\n\\nuse MONKEY-TYPING;\\naugment class IO::Path \\\{\\n    method barename \\\{\\n        self.extension(\\\"\\\").basename;\\n    }\\n}\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/variables#009｣ => {
					｢targ-in-fn｣ => "The_has_declarator",
					｢kind｣       => "syntax",
					｢subkind｣    => "declarator",
					｢name｣       => "has",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#009\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"has\",\n            )\n          ),\n          \" declarator\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"has\",\n        )\n      ),\n      \" scopes attributes to instances of a class or role, and methods to\\nclasses or roles. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"has\",\n        )\n      ),\n      \" is implied for methods, so \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"has method x() \\\{}\",\n        )\n      ),\n      \"\\nand \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"method x() \\\{}\",\n        )\n      ),\n      \" do the same thing.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"object orientation\",\n        ),\n        meta   => (\n          \"/language/objects\",\n        )\n      ),\n      \" for more documentation and some\\nexamples.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/variables#011｣ => {
					｢targ-in-fn｣ => "The_state_declarator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#011\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"state\",\n            )\n          ),\n          \" declarator\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"state\",\n        )\n      ),\n      \" declares lexically scoped variables, just like \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"my\",\n        )\n      ),\n      \". However,\\ninitialization happens exactly once, the first time the initialization\\nis encountered in the normal flow of execution. Thus, state variables\\nwill retain their value across multiple executions of the enclosing\\nblock or routine.\\n\\n\"\n    ),\n    \"Therefore, the subroutine\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub a \\\{\\n    state \\\@x;\\n    state \\\$l = 'A';\\n    \\\@x.push(\\\$l++);\\n};\\n\\nsay a for 1..6;\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"will continue to increment \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$l\",\n        )\n      ),\n      \" and append it to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@x\",\n        )\n      ),\n      \" each time it is\\ncalled. So it will output:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      config     => \$\{:lang(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"text\"),\n        )\n      ))},\n      paragraphs => (\n        \"[A]\\n[A B]\\n[A B C]\\n[A B C D]\\n[A B C D E]\\n[A B C D E F]\\n\\n\",\n      )\n    ),\n    \"Since they have a lexical scope, they are tied to the block in which they are\\ndeclared.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"sub foo () \\\{\\n  for 0..1 \\\{\\n    state \\\$foo = 1;\\n    say \\\$foo++;\\n  }\\n};\\nfoo;  # OUTPUT: «1␤2␤»\\nfoo;  # OUTPUT: «1␤2␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"In this case, a new state variable is created every time the block that\\nruns the for loop is entered, which is why the state variable is reset\\nin every call to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"foo\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"This works per \\\"clone\\\" of the containing code object, as in this\\nexample:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"(\\\{ state \\\$i = 1; \\\$i++.say; } xx 3).map: \\\{\\\$_(), \\\$_()}; # OUTPUT: «1␤2␤1␤2␤1␤2␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note that this is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"not\",\n        )\n      ),\n      \" a thread-safe construct when the same clone of\\nthe same block is run by multiple threads.  Also remember that methods\\nonly have one clone per class, not per object.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"As with \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"my\",\n        )\n      ),\n      \", a declaration of multiple \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"state\",\n        )\n      ),\n      \" variables must be placed\\nin parentheses which can be omitted for a single variable.\\n\\n\"\n    ),\n    \"Many operators come with implicit binding which can lead to actions at a\\ndistance.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"Use \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".clone\",\n        )\n      ),\n      \" or coercion to create a new container that can be bound to.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@a;\\nmy \\\@a-cloned;\\nsub f() \\\{\\n    state \\\$i;\\n    \\\$i++;\\n    \\\@a       .push: \\\"k\\\$i\\\" => \\\$i;\\n    \\\@a-cloned.push: \\\"k\\\$i\\\" => \\\$i.clone;\\n};\\n\\nf for 1..3;\\nsay \\\@a;        # OUTPUT: «[k1 => 3 k2 => 3 k3 => 3]␤»\\nsay \\\@a-cloned; # OUTPUT: «[k1 => 1 k2 => 2 k3 => 3]␤»\\n\\n\",\n      )\n    ),\n    \"State variables are shared between all threads. The result can be unexpected.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub code()\\\{ state \\\$i = 0; say ++\\\$i; \\\$i };\\nawait\\n    start \\\{ loop \\\{ last if code() >= 5 } },\\n    start \\\{ loop \\\{ last if code() >= 5 } };\\n\\n# OUTPUT: «1␤2␤3␤4␤4␤3␤5␤»\\n# OUTPUT: «2␤1␤3␤4␤5␤»\\n# many other more or less odd variations can be produced\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Language,anon state variables\",\n        )\n      ),\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Language,nameless variables\",\n        )\n      ),\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Variables,\\\$ (variable)\",\n        )\n      ),\n      \"\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$\",\n            )\n          ),\n          \" variable\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"In addition to explicitly declared named state variables, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$\",\n        )\n      ),\n      \" can be used\\nas an anonymous state variable without an explicit \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"state\",\n        )\n      ),\n      \" declaration.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say \\\"1-a 2-b 3-c\\\".subst(:g, /\\\\d/, \\\{<one two three>[\\\$++]});\\n# OUTPUT: «one-a two-b three-c␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Furthermore, state variables can be used outside of subroutines. You\\ncould, for example, use \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$\",\n        )\n      ),\n      \" in a one-liner to number the lines in a file.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:lang(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"shell\"),\n        )\n      ))},\n      paragraphs => (\n        \"raku -ne 'say ++\\\$ ~ \\\" \\\$_\\\"' example.txt\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Each reference to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$\",\n        )\n      ),\n      \" within a lexical scope is in effect a separate\\nvariable.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:lang(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"shell\"),\n        )\n      ))},\n      paragraphs => (\n        \"raku -e '\\\{ say ++\\\$; say \\\$++  } for ^5'\\n# OUTPUT: «1␤0␤2␤1␤3␤2␤4␤3␤5␤4␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"That is why, if you need to reference the same \\\$ variable (or, for that matter,\\nany of the other anon state variables \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\%\",\n        )\n      ),\n      \") more than once, a possible\\nsolution is to bind another variable to it, although in this example it would be\\nmore straightforward to just declare state \\\$x and not use the magical/anonymous\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$\",\n        )\n      ),\n      \" variable:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"sub foo () \\\{\\n    my \\\$x := \\\$;\\n    \\\$x++;\\n    say \\\$x;\\n    \\\$x = \\\$x + 1;\\n}\\n\\nfoo() for ^3; # OUTPUT: «1␤3␤5␤»\\n\",\n      )\n    ),\n    \"In general, it is better style to declare a named state variable in case you\\nhave to refer to it several times.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"Note that the implicit state declarator is only applied to the variable\\nitself, not the expression that may contain an initializer. If the\\ninitializer has to be called exactly once, the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"state\",\n        )\n      ),\n      \" declarator has to be\\nprovided.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"for ^3 \\\{       \\\$ = .say } # OUTPUT: «0␤1␤2␤»\\nfor ^3 \\\{ state \\\$ = .say } # OUTPUT: «0␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\@\",\n            )\n          ),\n          \" variable\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Similar to the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$\",\n        )\n      ),\n      \" variable, there is also a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Positional\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Positional\",\n        )\n      ),\n      \"\\nanonymous state variable \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub foo(\\\$x) \\\{\\n    say (\\\@).push(\\\$x);\\n}\\n\\nfoo(\\\$_) for ^3;\\n\\n# OUTPUT: «[0]\\n#          [0 1]\\n#          [0 1 2]␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@\",\n        )\n      ),\n      \" here is parenthesized in order to disambiguate the expression\\nfrom a class member variable named \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@.push\",\n        )\n      ),\n      \".  Indexed access doesn't\\nrequire this disambiguation but you will need to copy the value in order\\nto do anything useful with it.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub foo(\\\$x) \\\{\\n    my \\\$v = \\\@;\\n    \\\$v[\\\$x] = \\\$x;\\n    say \\\$v;\\n}\\n\\nfoo(\\\$_) for ^3;\\n\\n# OUTPUT: «[0]\\n#          [0 1]\\n#          [0 1 2]␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"As with \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$\",\n        )\n      ),\n      \", each mention of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@\",\n        )\n      ),\n      \" in a scope introduces a new anonymous\\narray.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\%\",\n            )\n          ),\n          \" variable\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"In addition, there's an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Associative\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Associative\",\n        )\n      ),\n      \" anonymous state\\nvariable \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\%\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub foo(\\\$x) \\\{\\n    say (\\\%).push(\\\$x => \\\$x);\\n}\\n\\nfoo(\\\$_) for ^3;\\n\\n# OUTPUT: «\\\{0 => 0}\\n#          \\\{0 => 0, 1 => 1}\\n#          \\\{0 => 0, 1 => 1, 2 => 2}␤»\\n\\n\",\n      )\n    ),\n    \"The same caveat about disambiguation applies. As you may expect, indexed\\naccess is also possible (with copying to make it useful).\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub foo(\\\$x) \\\{\\n    my \\\$v = \\\%;\\n    \\\$v\\\{\\\$x} = \\\$x;\\n    say \\\$v;\\n}\\n\\nfoo(\\\$_) for ^3;\\n\\n# OUTPUT: «\\\{0 => 0}\\n#          \\\{0 => 0, 1 => 1}\\n#          \\\{0 => 0, 1 => 1, 2 => 2}␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"As with the other anonymous state variables, each mention of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\%\",\n        )\n      ),\n      \" within a\\ngiven scope will effectively introduce a separate variable.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "state",
					｢kind｣       => "syntax",
					｢subkind｣    => "declarator"
				},
				｢en#language/variables#017｣ => {
					｢targ-in-fn｣ => "The_\$/_variable",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#017\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$/\",\n            )\n          ),\n          \" variable\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$/\",\n        )\n      ),\n      \" is the match variable.  A fresh one is created in every \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"routine\",\n        )\n      ),\n      \".\\nIt is set to the result of the last \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Regex\",\n        ),\n        meta   => (\n          \"/language/regexes\",\n        )\n      ),\n      \"\\nmatch and so usually contains objects of type \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Match\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Match\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"'abc 12' ~~ /\\\\w+/;  # sets \\\$/ to a Match object\\nsay \\\$/.Str;         # OUTPUT: «abc␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Grammar.parse\",\n        )\n      ),\n      \" method also sets the caller's \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$/\",\n        )\n      ),\n      \" to the resulting\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Match\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Match\",\n        )\n      ),\n      \" object.  For the following code:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:skip-test(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"needs XML::Grammar\"),\n        )\n      ))},\n      paragraphs => (\n        \"use XML::Grammar; # zef install XML\\nXML::Grammar.parse(\\\"<p>some text</p>\\\");\\nsay \\\$/;\\n\\n# OUTPUT: «｢<p>some text</p>｣\\n#           root => ｢<p>some text</p>｣\\n#            name => ｢p｣\\n#            child => ｢some text｣\\n#             text => ｢some text｣\\n#             textnode => ｢some text｣\\n#           element => ｢<p>some text</p>｣\\n#            name => ｢p｣\\n#            child => ｢some text｣\\n#             text => ｢some text｣\\n#             textnode => ｢some text｣␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Prior to the 6.d version, you could use \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$()\",\n        )\n      ),\n      \" shortcut to get the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"ast\",\n        ),\n        meta   => (\n          \"/routine/ast\",\n        )\n      ),\n      \" value from \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$/\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Match\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Match\",\n        )\n      ),\n      \" if that value is\\ntruthy, or the stringification of the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Match\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Match\",\n        )\n      ),\n      \" object otherwise.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"'test' ~~ /.../;\\n# 6.c language only:\\nsay \\\$(); # OUTPUT: «tes␤»;\\n\\\$/.make: 'McTesty';\\nsay \\\$(); # OUTPUT: «McTesty␤»;\\n\\n\",\n      )\n    ),\n    \"This (non-)feature has been deprecated as of version 6.d.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"Positional attributes\",\n            ),\n            meta   => (\n              \"Variables,\\\$0;Variables,\\\$1\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$/\",\n        )\n      ),\n      \" can have positional attributes if the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Regex\",\n        ),\n        meta   => (\n          \"/language/regexes\",\n        )\n      ),\n      \" had\\ncapture-groups in it, which are just formed with parentheses.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"'abbbbbcdddddeffg' ~~ / a (b+) c (d+ef+) g /;\\nsay \\\$/[0]; # OUTPUT: «｢bbbbb｣␤»\\nsay \\\$/[1]; # OUTPUT: «｢dddddeff｣␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"These can also be accessed by the shortcuts \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$0\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$1\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$2\",\n        )\n      ),\n      \", etc.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say \\\$0; # OUTPUT: «｢bbbbb｣␤»\\nsay \\\$1; # OUTPUT: «｢dddddeff｣␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"To get all of the positional attributes, you can use \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$/.list\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@\\\$/\",\n        )\n      ),\n      \".\\nBefore 6.d, you can also use the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@()\",\n        )\n      ),\n      \" shortcut (no spaces inside the\\nparentheses).\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say \\\@\\\$/.join; # OUTPUT: «bbbbbdddddeff␤»\\n\\n# 6.c language only:\\nsay \\\@().join; # OUTPUT: «bbbbbdddddeff␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"magic\",\n        )\n      ),\n      \" behavior of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@()\",\n        )\n      ),\n      \" has been deprecated as of 6.d\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"Named attributes\",\n            ),\n            meta   => (\n              \"Variables,\\\$<named>\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$/\",\n        )\n      ),\n      \" can have named attributes if the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Regex\",\n        ),\n        meta   => (\n          \"/language/regexes\",\n        )\n      ),\n      \" had named\\ncapture-groups in it, or if the Regex called out to another Regex.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"'I... see?' ~~ / \\\\w+ \\\$<punctuation>=[ <-[\\\\w\\\\s]>+ ] \\\\s* \\\$<final-word> = [ \\\\w+ . ] /;\\nsay \\\$/<punctuation>; # OUTPUT: «｢....｣␤»\\nsay \\\$/<final-word>;  # OUTPUT: «｢see?｣␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"These can also be accessed by the shortcut \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"\\\$<named>\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say \\\$<punctuation>; # OUTPUT: «｢....｣␤»\\nsay \\\$<final-word>;  # OUTPUT: «｢see?｣␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"To get all of the named attributes, you can use \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$/.hash\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\%\\\$/\",\n        )\n      ),\n      \".  Before\\n6.d language, you could also use the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\%()\",\n        )\n      ),\n      \" shortcut (no spaces inside the\\nparentheses).\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say \\\%\\\$/.join;       # OUTPUT: «\\\"punctuation     ....final-word  see?\\\"␤»\\n\\n# 6.c language only\\nsay \\\%().join;       # OUTPUT: «\\\"punctuation     ....final-word  see?\\\"␤»\\n\\n\",\n      )\n    ),\n    \"This behavior has been deprecated as of the 6.d version.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      paragraphs  => (\n        \"Thread-safety issues\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Because \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$/\",\n        )\n      ),\n      \" is only defined per \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"routine\",\n        )\n      ),\n      \", you are in fact\\nre-using the same \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$/\",\n        )\n      ),\n      \" when you do matching in a loop.  In a single\\nthreaded program, this is not an issue.  However, if you're going to\\nuse \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"hyper\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"race\",\n        )\n      ),\n      \" to have multiple threads do matching in\\nparallel, the sharing of the \\\"outer\\\" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$/\",\n        )\n      ),\n      \" becomes an issue, because\\nthen it is being shared \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"between\",\n        )\n      ),\n      \" threads!  Fortunately, the solution\\nis very simple: define your own \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$/\",\n        )\n      ),\n      \" inside the scope where you are\\ndoing the matching.  For example, taking a source of text, running\\na regex on it, and map that to a hash using parallel execution:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:preamble(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"my \\\@source\"),\n        )\n      ))},\n      paragraphs => (\n        \"my \\\%mapped = \\\@source.race.map: \\\{\\n    my \\\$/;  # need one in this block to prevent racing issues\\n    m/foo (.*?) bar (.*)/;  # matches on \\\$_, stores in \\\$/\\n    \\\$0 => \\\$1   # short for \\\$/[0] / \\\$/[1]\\n}\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Language,error variable\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢kind｣       => "syntax",
					｢subkind｣    => "variable",
					｢name｣       => "\$/"
				},
				｢en#language/variables#016｣ => {
					｢subkind｣    => "variable",
					｢kind｣       => "syntax",
					｢targ-in-fn｣ => "The_\$__variable",
					｢name｣       => "\$_",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#016\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$_\",\n            )\n          ),\n          \" variable\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" is the topic variable.  A fresh one is created in every \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"block\",\n        )\n      ),\n      \".\\nIt's also the default parameter for blocks that do not have an explicit\\nsignature, so constructs like \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"for \\\@array \\\{ ... }\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"given \\\$var\\n\\\{ ... }\",\n        )\n      ),\n      \" bind the value or values of the variable to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" by invoking\\nthe block.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"for <a b c> \\\{ say \\\$_ }  # binds \\\$_ to 'a', 'b' and 'c' in turn\\nsay \\\$_ for <a b c>;     # same, even though it's not a block\\ngiven 'a'   \\\{ say \\\$_ }  # binds \\\$_ to 'a'\\nsay \\\$_ given 'a';       # same, even though it's not a block\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Because \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" is bound to the value of the iteration, you can also\\nassign to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" if it is bound to something assignable.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@numbers = ^5;   # 0 through 4\\n\\\$_++ for \\\@numbers;  # increment all elements of \\\@numbers\\nsay \\\@numbers;\\n\\n# OUTPUT: «1 2 3 4 5␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"CATCH\",\n        )\n      ),\n      \" blocks bind \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" to the exception that was caught. The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"~~\",\n        )\n      ),\n      \"\\nsmartmatch operator binds \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" on the right-hand side expression to the\\nvalue of the left-hand side.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Calling a method on \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" can be shortened by leaving off the variable name:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \".say;                   # same as \\\$_.say\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"m/regex/\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"/regex/\",\n        )\n      ),\n      \" regex matches and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"s/regex/subst/\",\n        )\n      ),\n      \" substitutions\\nwork on \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \":\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say \\\"Looking for strings with non-alphabetic characters...\\\";\\nfor <ab:c d\\\$e fgh ij*> \\\{\\n    .say if m/<-alpha>/;\\n}\\n\\n# OUTPUT: «Looking for strings with non-alphabetic characters...\\n#          ab:c\\n#          d\\\$e\\n#          ij*␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Language,match variable\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)"
				},
				｢en#language/variables#002｣ => {
					｢name｣       => "!",
					｢kind｣       => "syntax",
					｢targ-in-fn｣ => "The_!_twigil",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#002\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"!\",\n            )\n          ),\n          \" twigil\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,!\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\$!\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\@!\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\%!\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\&!\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Attributes\",\n        ),\n        meta   => (\n          \"/language/objects#Attributes\",\n        )\n      ),\n      \" are variables that exist per instance\\nof a class. They may be directly accessed from within the class via \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"!\",\n        )\n      ),\n      \":\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my class Point \\\{\\n    has \\\$.x;\\n    has \\\$.y;\\n\\n    method Str() \\\{\\n        \\\"(\\\$!x, \\\$!y)\\\"\\n    }\\n}\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note how the attributes are declared as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$.x\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$.y\",\n        )\n      ),\n      \" but are still\\naccessed via \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$!x\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$!y\",\n        )\n      ),\n      \". This is because in Raku all attributes are\\nprivate and can be directly accessed within the class by using\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$!attribute-name\",\n        )\n      ),\n      \". Raku may automatically generate accessor methods for\\nyou though. For more details on objects, classes and their attributes see\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"object orientation\",\n        ),\n        meta   => (\n          \"/language/objects\",\n        )\n      ),\n      \".\\n\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "twigil"
				},
				｢en#language/variables#001｣ => {
					｢targ-in-fn｣ => "The_*_twigil",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#001\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"*\",\n            )\n          ),\n          \" twigil\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,*\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\$*\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\@*\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\%*\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Syntax,\\\&*\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This twigil is used for dynamic variables which are looked up through the\\ncaller's, not through the outer, scope. Look at the example below.\",\n      RakuAST::Doc::Markup.new(\n        letter => \"N\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"The example\\nbelow cannot run correctly in the \",\n          RakuAST::Doc::Markup.new(\n            letter => \"L\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"REPL\",\n            ),\n            meta   => (\n              \"/language/REPL\",\n            )\n          ),\n          \", yielding an error about not finding the\\ndynamic variables. Please test it by copy-pasting it into a file, then run the\\nfile.\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"my \\\$lexical   = 1;\\nmy \\\$*dynamic1 = 10;\\nmy \\\$*dynamic2 = 100;\\n\\nsub say-all() \\\{\\n    say \\\"\\\$lexical, \\\$*dynamic1, \\\$*dynamic2\\\";\\n}\\n\\nsay-all();    # OUTPUT: 1, 10, 100\\n\\n\\\{\\n    my \\\$lexical   = 2;\\n    my \\\$*dynamic1 = 11;\\n    \\\$*dynamic2    = 101;\\n\\n    say-all(); # OUTPUT: 1, 11, 101\\n}\\n\\nsay-all();  # OUTPUT: 1, 10, 101\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The first time \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\&say-all\",\n        )\n      ),\n      \" is called, it prints \\\"\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"1, 10, 100\",\n        )\n      ),\n      \"\\\" just as one\\nwould expect. The second time though, it prints \\\"\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"1, 11, 101\",\n        )\n      ),\n      \"\\\". This is\\nbecause \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$lexical\",\n        )\n      ),\n      \" isn't looked up in the caller's scope but in the scope\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\&say-all\",\n        )\n      ),\n      \" was defined in. The two dynamic variables are looked up in the\\ncaller's scope and therefore have the values \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"11\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"101\",\n        )\n      ),\n      \". The third\\ntime \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\&say-all\",\n        )\n      ),\n      \" is called \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*dynamic1\",\n        )\n      ),\n      \" isn't \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"11\",\n        )\n      ),\n      \" anymore, but\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*dynamic2\",\n        )\n      ),\n      \" is still \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"101\",\n        )\n      ),\n      \". This stems from the fact that we declared a\\nnew dynamic variable \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*dynamic1\",\n        )\n      ),\n      \" in the block and did not assign to the\\nold variable as we did with \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*dynamic2\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The dynamic variables differ from other variable types in that referring\\nto an undeclared dynamic variable is not a compile time error but a\\nruntime \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Failure\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Failure\",\n        )\n      ),\n      \", so a dynamic variable can be used\\nundeclared as long as it's checked for definedness or used in a\\nBoolean context before using it for anything else:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"sub foo() \\\{\\n    \\\$*FOO // 'foo';\\n}\\n\\nsay foo; # OUTPUT: «foo␤»\\n\\nmy \\\$*FOO = 'bar';\\n\\nsay foo; # OUTPUT: «bar␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Dynamic variables can have lexical scope when declared with \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"my\",\n        )\n      ),\n      \" or package\\nscope when declared with \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"our\",\n        )\n      ),\n      \". Dynamic resolution and resolution through\\nsymbol tables introduced with \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"our\",\n        )\n      ),\n      \" are two orthogonal issues.\\n\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "*",
					｢kind｣       => "syntax",
					｢subkind｣    => "twigil"
				},
				｢en#language/variables#013｣ => {
					｢name｣       => "temp",
					｢subkind｣    => "prefix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/variables#013\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"The \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"temp\",\n            )\n          ),\n          \" prefix\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Like \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"my\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"temp\",\n        )\n      ),\n      \" restores the old value of a variable at the end of its\\nscope. However, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"temp\",\n        )\n      ),\n      \" does not create a new variable.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$in = 0; # temp will \\\"entangle\\\" the global variable with the call stack\\n            # that keeps the calls at the bottom in order.\\nsub f(*\\\@c) \\\{\\n    (temp \\\$in)++;\\n     \\\"<f>\\\\n\\\"\\n     ~ \\\@c».indent(\\\$in).join(\\\"\\\\n\\\")\\n     ~ (+\\\@c ?? \\\"\\\\n\\\" !! \\\"\\\")\\n     ~ '</f>'\\n};\\nsub g(*\\\@c) \\\{\\n    (temp \\\$in)++;\\n    \\\"<g>\\\\n\\\"\\n    ~ \\\@c».indent(\\\$in).join(\\\"\\\\n\\\")\\n    ~ (+\\\@c ?? \\\"\\\\n\\\" !! \\\"\\\")\\n    ~ \\\"</g>\\\"\\n};\\nprint g(g(f(g()), g(), f()));\\n\\n# OUTPUT: «<g>\\n#           <g>\\n#            <f>\\n#             <g>\\n#             </g>\\n#            </f>\\n#            <g>\\n#            </g>\\n#            <f>\\n#            </f>\\n#           </g>\\n#          </g>␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "The_temp_prefix"
				}
			},
			｢config｣     => {
				｢subkind｣  => "Language",
				｢kind｣     => "Language",
				｢category｣ => "fundamental"
			},
			｢title｣      => "Variables",
			｢subtitle｣   => "Variables in Raku",
			｢type｣       => "primary",
			｢index｣      => {
				｢Variables｣ => {
					｢refs｣      => [],
					｢sub-index｣ => {
						｢$?LINE｣               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">\$¢</span> variable",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							]
						},
						｢$*COLLATION｣          => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*DEFAULT-READ-ELEMS</span>",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*EXECUTABLE-NAME｣    => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "<span class=\"code\">\$*EXECUTABLE</span>"
								}
							]
						},
						｢::?CLASS｣             => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "The <span class=\"code\">\$¢</span> variable"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*PROGRAM-NAME｣       => {
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">\$*PID</span>",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢$*TZ｣                 => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*INIT-INSTANT</span>"
								}
							]
						},
						｢$~Trans｣              => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">~</span> twigil",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢$*VM｣                 => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*DISTRO</span>",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*HOME｣               => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*HOMEPATH</span>",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*DEFAULT-READ-ELEMS｣ => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "Runtime variables",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢$*PERL｣               => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*RAKU</span>",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*DISTRO｣             => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*KERNEL</span>",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*HOMEPATH｣           => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*HOMEDRIVE</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*SAMPLER｣            => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "<span class=\"code\">\$*SCHEDULER</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢$?TABSTOP｣            => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "Introspection compile-time variables",
										｢is-in-heading｣ => False
								}
							]
						},
						｢$~Quasi｣              => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "The <span class=\"code\">~</span> twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢$?MODULE｣             => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "Introspection compile-time variables",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢$*SPEC｣               => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*HOME</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢&*EXIT｣               => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "<span class=\"code\">\$*PROGRAM</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*USAGE｣              => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*EXECUTABLE-NAME</span>",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*GROUP｣              => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "<span class=\"code\">\$*USER</span>",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢$~P5Regex｣            => {
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">~</span> twigil",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*HOMEDRIVE｣          => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*GROUP</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢%?RESOURCES｣          => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "<span class=\"code\">\%?RESOURCES</span>",
										｢target｣        => "\%?RESOURCES"
								}
							]
						},
						｢&?ROUTINE｣            => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "\&amp;?ROUTINE",
										｢place｣         => "\&amp;?ROUTINE"
								}
							]
						},
						｢$*RAKU｣               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">\$*VM</span>",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							]
						},
						｢$ (variable)｣         => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "The <span class=\"code\">state</span> declarator",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢$*SCHEDULER｣          => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*THREAD</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*EXIT｣               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">\&amp;*EXIT</span>",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							]
						},
						｢%*ENV｣                => {
							｢refs｣      => [
								{
										｢place｣         => "Runtime environment",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$0｣                   => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "Positional attributes",
										｢target｣        => "Positional_attributes"
								}
							]
						},
						｢$*USER｣               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">\$*USAGE</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢&*ARGS-TO-CAPTURE｣    => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\@*ARGS</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*INIT-INSTANT｣       => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*REPO</span>",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$?PACKAGE｣            => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "Introspection compile-time variables",
										｢is-in-heading｣ => False
								}
							]
						},
						｢$*IN｣                 => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\&amp;*GENERATE-USAGE</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*PROGRAM｣            => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">\$*PROGRAM-NAME</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢$~Regex｣              => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "The <span class=\"code\">~</span> twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢$?CLASS｣              => {
							｢refs｣      => [
								{
										｢place｣         => "Introspection compile-time variables",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*EXCEPTION｣          => {
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">\$*EXIT</span>",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢$~Quote｣              => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">~</span> twigil",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢$1｣                   => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "Positional attributes",
										｢target｣        => "Positional_attributes"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*REPO｣               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\%*ENV</span>",
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢$?DISTRIBUTION｣       => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "\$?DISTRIBUTION",
										｢is-in-heading｣ => True,
										｢target｣        => "\$?DISTRIBUTION"
								}
							]
						},
						｢&*GENERATE-USAGE｣     => {
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">\&amp;*ARGS-TO-CAPTURE</span>",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢$*RAT-OVERFLOW｣       => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">\$*COLLATION</span>",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							]
						},
						｢$?ROLE｣               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "Introspection compile-time variables",
										｢is-in-heading｣ => False
								}
							]
						},
						｢$*CWD｣                => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "<span class=\"code\">\$*TZ</span>"
								}
							]
						},
						｢$*ARGFILES｣           => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "Dynamic variables",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							]
						},
						｢&?BLOCK｣              => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "\&amp;?BLOCK",
										｢is-in-heading｣ => True,
										｢place｣         => "\&amp;?BLOCK"
								}
							]
						},
						｢$~MAIN｣               => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "The <span class=\"code\">~</span> twigil",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$?NL｣                 => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "Introspection compile-time variables",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢$*ERR｣                => {
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">\&amp;*GENERATE-USAGE</span>",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢@*ARGS｣               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "Dynamic variables",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢$*TOLERANCE｣          => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*RAT-OVERFLOW</span>",
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢$*EXECUTABLE｣         => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">\$*EXCEPTION</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢$*THREAD｣             => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*TMPDIR</span>",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*KERNEL｣             => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*CWD</span>",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*OUT｣                => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\&amp;*GENERATE-USAGE</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*PID｣                => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*PERL</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢$?FILE｣               => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "The <span class=\"code\">\$¢</span> variable"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*TMPDIR｣             => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "<span class=\"code\">\$*SPEC</span>"
								}
							]
						},
						｢$<named>｣             => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "Named attributes",
										｢target｣        => "Named_attributes"
								}
							]
						}
					}
				},
				｢Language｣  => {
					｢sub-index｣ => {
						｢anon state variables｣          => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">state</span> declarator",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢Dynamically scoped variables｣  => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "Twigils",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢match variable｣                => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "The <span class=\"code\">\$_</span> variable",
										｢is-in-heading｣ => False
								}
							]
						},
						｢constants (syntax)｣            => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "The <span class=\"code\">let</span> prefix",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢nameless variables｣            => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">state</span> declarator",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢destructuring assignment｣      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "Declaring a list of variables with lexical (<span class=\"code\">my</span>) or package (<span class=\"code\">our</span>) scope",
										｢target｣        => "index-entry-destructuring_assignment"
								}
							]
						},
						｢topic variable｣                => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "Pre-defined lexical variables",
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢error variable｣                => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "Thread-safety issues"
								}
							],
							｢sub-index｣ => {}
						},
						｢declaring a list of variables｣ => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">our</span> declarator",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢cursor variable｣               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">\$!</span> variable",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							]
						}
					},
					｢refs｣      => []
				},
				｢Syntax｣    => {
					｢sub-index｣ => {
						｢%^｣                      => {
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">^</span> twigil",
										｢is-in-heading｣ => True,
										｢target｣        => "The_^_twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢?｣                       => {
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">?</span> twigil",
										｢target｣        => "The_?__twigil",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢@｣                       => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "Sigils",
										｢target｣        => "Sigils",
										｢is-in-heading｣ => True
								}
							]
						},
						｢:｣                       => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">:</span> twigil",
										｢target｣        => "The_:_twigil",
										｢is-in-heading｣ => True
								}
							]
						},
						｢@.｣                      => {
							｢refs｣      => [
								{
										｢target｣        => "The_.__twigil",
										｢place｣         => "The <span class=\"code\">.</span> twigil",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢!｣                       => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "The_!_twigil",
										｢place｣         => "The <span class=\"code\">!</span> twigil",
										｢is-in-heading｣ => True
								}
							]
						},
						｢=｣                       => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "The_=_twigil",
										｢is-in-heading｣ => True,
										｢place｣         => "The <span class=\"code\">=</span> twigil"
								}
							]
						},
						｢@*｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">*</span> twigil",
										｢target｣        => "The_*_twigil",
										｢is-in-heading｣ => True
								}
							]
						},
						｢&!｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">!</span> twigil",
										｢target｣        => "The_!_twigil",
										｢is-in-heading｣ => True
								}
							]
						},
						｢$｣                       => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "Sigils",
										｢target｣        => "Sigils"
								}
							],
							｢sub-index｣ => {}
						},
						｢&^｣                      => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "The <span class=\"code\">^</span> twigil",
										｢target｣        => "The_^_twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢$~｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "The_~_twigil",
										｢place｣         => "The <span class=\"code\">~</span> twigil",
										｢is-in-heading｣ => True
								}
							]
						},
						｢$?｣                      => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "The <span class=\"code\">?</span> twigil",
										｢target｣        => "The_?__twigil"
								},
								{
										｢target｣        => "The_?__twigil",
										｢place｣         => "The <span class=\"code\">?</span> twigil",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢&=｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">=</span> twigil",
										｢target｣        => "The_=_twigil",
										｢is-in-heading｣ => True
								}
							]
						},
						｢$:｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "The <span class=\"code\">:</span> twigil",
										｢target｣        => "The_:_twigil"
								}
							]
						},
						｢@?｣                      => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "The_?__twigil",
										｢place｣         => "The <span class=\"code\">?</span> twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢&｣                       => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "Sigils",
										｢place｣         => "Sigils",
										｢is-in-heading｣ => True
								}
							]
						},
						｢.｣                       => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "The_.__twigil",
										｢place｣         => "The <span class=\"code\">.</span> twigil"
								}
							]
						},
						｢\ (sigilless variables)｣ => {
							｢refs｣      => [
								{
										｢place｣         => "Sigilless variables",
										｢is-in-heading｣ => True,
										｢target｣        => "Sigilless_variables"
								}
							],
							｢sub-index｣ => {}
						},
						｢&:｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "The_:_twigil",
										｢place｣         => "The <span class=\"code\">:</span> twigil"
								}
							]
						},
						｢@^｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "The <span class=\"code\">^</span> twigil",
										｢target｣        => "The_^_twigil"
								}
							]
						},
						｢% (sigil)｣               => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "Sigils",
										｢place｣         => "Sigils"
								}
							],
							｢sub-index｣ => {}
						},
						｢$*｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "Twigils",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								},
								{
										｢is-in-heading｣ => True,
										｢target｣        => "The_*_twigil",
										｢place｣         => "The <span class=\"code\">*</span> twigil"
								}
							]
						},
						｢^｣                       => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "The_^_twigil",
										｢is-in-heading｣ => True,
										｢place｣         => "The <span class=\"code\">^</span> twigil"
								}
							]
						},
						｢@!｣                      => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "The <span class=\"code\">!</span> twigil",
										｢target｣        => "The_!_twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢$=｣                      => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "The_=_twigil",
										｢place｣         => "The <span class=\"code\">=</span> twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢$.｣                      => {
							｢refs｣      => [
								{
										｢target｣        => "The_.__twigil",
										｢is-in-heading｣ => True,
										｢place｣         => "The <span class=\"code\">.</span> twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢%:｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">:</span> twigil",
										｢is-in-heading｣ => True,
										｢target｣        => "The_:_twigil"
								}
							]
						},
						｢%*｣                      => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "The <span class=\"code\">*</span> twigil",
										｢target｣        => "The_*_twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢supersede｣               => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "The <span class=\"code\">~</span> twigil",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢Twigil｣                  => {
							｢refs｣      => [
								{
										｢place｣         => "Twigils",
										｢target｣        => "Twigils",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢%.｣                      => {
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">.</span> twigil",
										｢is-in-heading｣ => True,
										｢target｣        => "The_.__twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢&*｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "The_*_twigil",
										｢is-in-heading｣ => True,
										｢place｣         => "The <span class=\"code\">*</span> twigil"
								}
							]
						},
						｢&.｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "The_.__twigil",
										｢place｣         => "The <span class=\"code\">.</span> twigil"
								}
							]
						},
						｢&?｣                      => {
							｢refs｣      => [
								{
										｢target｣        => "The_?__twigil",
										｢place｣         => "The <span class=\"code\">?</span> twigil",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢is (type of variable)｣   => {
							｢refs｣      => [
								{
										｢place｣         => "Sigils",
										｢target｣        => "index-entry-",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢%!｣                      => {
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">!</span> twigil",
										｢is-in-heading｣ => True,
										｢target｣        => "The_!_twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢*｣                       => {
							｢refs｣      => [
								{
										｢target｣        => "The_*_twigil",
										｢is-in-heading｣ => True,
										｢place｣         => "The <span class=\"code\">*</span> twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢@:｣                      => {
							｢refs｣      => [
								{
										｢target｣        => "The_:_twigil",
										｢place｣         => "The <span class=\"code\">:</span> twigil",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢%?｣                      => {
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">?</span> twigil",
										｢target｣        => "The_?__twigil",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢$^｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "The_^_twigil",
										｢place｣         => "The <span class=\"code\">^</span> twigil"
								}
							]
						},
						｢$!｣                      => {
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">!</span> twigil",
										｢is-in-heading｣ => True,
										｢target｣        => "The_!_twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢constant (Prefix)｣       => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "The <span class=\"code\">let</span> prefix",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							]
						},
						｢@=｣                      => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "The_=_twigil",
										｢place｣         => "The <span class=\"code\">=</span> twigil"
								}
							],
							｢sub-index｣ => {}
						},
						｢%=｣                      => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "The_=_twigil",
										｢place｣         => "The <span class=\"code\">=</span> twigil"
								}
							],
							｢sub-index｣ => {}
						}
					},
					｢refs｣      => []
				}
			},
			｢xtrk-targs｣ => {},
			｢toc｣        => [
				{
						｢level｣      => 1,
						｢target｣     => "Sigils",
						｢caption｣    => "Sigils",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "Item and list assignment",
						｢target｣     => "Item_and_list_assignment",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "Sigilless variables",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "Sigilless_variables"
				},
				{
						｢caption｣    => "Twigils",
						｢level｣      => 1,
						｢numeration｣ => "",
						｢target｣     => "Twigils"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "The <span class=\"code\">*</span> twigil",
						｢target｣     => "The_*_twigil",
						｢level｣      => "2"
				},
				{
						｢target｣     => "The_?__twigil",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "The <span class=\"code\">?</span> twigil"
				},
				{
						｢target｣     => "The_!_twigil",
						｢caption｣    => "The <span class=\"code\">!</span> twigil",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢target｣     => "The_.__twigil",
						｢numeration｣ => "",
						｢caption｣    => "The <span class=\"code\">.</span> twigil"
				},
				{
						｢caption｣    => "The <span class=\"code\">^</span> twigil",
						｢numeration｣ => "",
						｢target｣     => "The_^_twigil",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "The <span class=\"code\">:</span> twigil",
						｢target｣     => "The_:_twigil"
				},
				{
						｢target｣     => "A_note_on_^_and_:",
						｢numeration｣ => "",
						｢level｣      => "3",
						｢caption｣    => "A note on <span class=\"code\">^</span> and <span class=\"code\">:</span>"
				},
				{
						｢target｣     => "The_=_twigil",
						｢numeration｣ => "",
						｢caption｣    => "The <span class=\"code\">=</span> twigil",
						｢level｣      => "2"
				},
				{
						｢target｣     => "The_~_twigil",
						｢caption｣    => "The <span class=\"code\">~</span> twigil",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "Variable declarators and scope",
						｢level｣      => 1,
						｢numeration｣ => "",
						｢target｣     => "Variable_declarators_and_scope"
				},
				{
						｢level｣      => "2",
						｢target｣     => "The_my_declarator",
						｢caption｣    => "The <span class=\"code\">my</span> declarator",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "The <span class=\"code\">our</span> declarator",
						｢numeration｣ => "",
						｢target｣     => "The_our_declarator",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "Declaring a list of variables with lexical (<span class=\"code\">my</span>) or package (<span class=\"code\">our</span>) scope",
						｢target｣     => "Declaring_a_list_of_variables_with_lexical_(my)_or_package_(our)_scope",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "The_has_declarator",
						｢caption｣    => "The <span class=\"code\">has</span> declarator"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "The <span class=\"code\">anon</span> declarator",
						｢numeration｣ => "",
						｢target｣     => "The_anon_declarator"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "The <span class=\"code\">state</span> declarator",
						｢numeration｣ => "",
						｢target｣     => "The_state_declarator"
				},
				{
						｢level｣      => "3",
						｢caption｣    => "The <span class=\"code\">\$</span> variable",
						｢target｣     => "The_\$_variable",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "The <span class=\"code\">\@</span> variable",
						｢level｣      => "3",
						｢target｣     => "The_\@_variable",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "The <span class=\"code\">\%</span> variable",
						｢numeration｣ => "",
						｢level｣      => "3",
						｢target｣     => "The_\%_variable"
				},
				{
						｢level｣      => "2",
						｢target｣     => "The_augment_declarator",
						｢caption｣    => "The <span class=\"code\">augment</span> declarator",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "The <span class=\"code\">temp</span> prefix",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "The_temp_prefix"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "The_let_prefix",
						｢level｣      => "2",
						｢caption｣    => "The <span class=\"code\">let</span> prefix"
				},
				{
						｢target｣     => "The_constant_prefix",
						｢level｣      => "2",
						｢caption｣    => "The <span class=\"code\">constant</span> prefix",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢target｣     => "Type_constraints_and_initialization",
						｢caption｣    => "Type constraints and initialization"
				},
				{
						｢caption｣    => "Default defined variables pragma",
						｢target｣     => "Default_defined_variables_pragma",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "Special variables",
						｢target｣     => "Special_variables",
						｢level｣      => 1
				},
				{
						｢numeration｣ => "",
						｢target｣     => "Pre-defined_lexical_variables",
						｢caption｣    => "Pre-defined lexical variables",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "The_\$__variable",
						｢caption｣    => "The <span class=\"code\">\$_</span> variable",
						｢level｣      => "3"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "3",
						｢caption｣    => "The <span class=\"code\">\$/</span> variable",
						｢target｣     => "The_\$/_variable"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "4",
						｢target｣     => "Positional_attributes",
						｢caption｣    => "Positional attributes"
				},
				{
						｢level｣      => "4",
						｢numeration｣ => "",
						｢target｣     => "Named_attributes",
						｢caption｣    => "Named attributes"
				},
				{
						｢caption｣    => "Thread-safety issues",
						｢level｣      => "4",
						｢target｣     => "Thread-safety_issues",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "The <span class=\"code\">\$!</span> variable",
						｢target｣     => "The_\$!_variable",
						｢level｣      => "3"
				},
				{
						｢level｣      => "3",
						｢caption｣    => "The <span class=\"code\">\$¢</span> variable",
						｢numeration｣ => "",
						｢target｣     => "The_\$¢_variable"
				},
				{
						｢target｣     => "Compile-time_variables",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "Compile-time variables"
				},
				{
						｢level｣      => "3",
						｢caption｣    => "<span class=\"code\">\%?RESOURCES</span>",
						｢target｣     => "\%?RESOURCES",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "Introspection_compile-time_variables",
						｢numeration｣ => "",
						｢caption｣    => "Introspection compile-time variables",
						｢level｣      => "3"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "Rakudo-specific compile-time variables",
						｢target｣     => "Rakudo-specific_compile-time_variables",
						｢level｣      => "3"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "3",
						｢caption｣    => "\&amp;?ROUTINE",
						｢target｣     => "\&amp;?ROUTINE"
				},
				{
						｢caption｣    => "\&amp;?BLOCK",
						｢numeration｣ => "",
						｢level｣      => "3",
						｢target｣     => "\&amp;?BLOCK"
				},
				{
						｢caption｣    => "\$?DISTRIBUTION",
						｢target｣     => "\$?DISTRIBUTION",
						｢level｣      => "3",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "Dynamic_variables",
						｢caption｣    => "Dynamic variables",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢level｣      => "3",
						｢caption｣    => "Argument related variables",
						｢target｣     => "Argument_related_variables"
				},
				{
						｢target｣     => "\$*ARGFILES",
						｢caption｣    => "<span class=\"code\">\$*ARGFILES</span>",
						｢numeration｣ => "",
						｢level｣      => "4"
				},
				{
						｢level｣      => "4",
						｢numeration｣ => "",
						｢caption｣    => "<span class=\"code\">\@*ARGS</span>",
						｢target｣     => "\@*ARGS"
				},
				{
						｢caption｣    => "<span class=\"code\">\&amp;*ARGS-TO-CAPTURE</span>",
						｢numeration｣ => "",
						｢level｣      => "4",
						｢target｣     => "\&amp;*ARGS-TO-CAPTURE"
				},
				{
						｢caption｣    => "<span class=\"code\">\&amp;*GENERATE-USAGE</span>",
						｢numeration｣ => "",
						｢target｣     => "\&amp;*GENERATE-USAGE",
						｢level｣      => "4"
				},
				{
						｢target｣     => "Special_filehandles:_STDIN,_STDOUT_and_STDERR",
						｢caption｣    => "Special filehandles: <span class=\"code\">STDIN</span>, <span class=\"code\">STDOUT</span> and <span class=\"code\">STDERR</span>",
						｢level｣      => "3",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "Runtime_environment",
						｢numeration｣ => "",
						｢caption｣    => "Runtime environment",
						｢level｣      => "3"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "4",
						｢caption｣    => "<span class=\"code\">\%*ENV</span>",
						｢target｣     => "\%*ENV"
				},
				{
						｢level｣      => "4",
						｢numeration｣ => "",
						｢caption｣    => "<span class=\"code\">\$*REPO</span>",
						｢target｣     => "\$*REPO"
				},
				{
						｢target｣     => "\$*INIT-INSTANT",
						｢caption｣    => "<span class=\"code\">\$*INIT-INSTANT</span>",
						｢level｣      => "4",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "4",
						｢numeration｣ => "",
						｢target｣     => "\$*TZ",
						｢caption｣    => "<span class=\"code\">\$*TZ</span>"
				},
				{
						｢caption｣    => "<span class=\"code\">\$*CWD</span>",
						｢level｣      => "4",
						｢target｣     => "\$*CWD",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "<span class=\"code\">\$*KERNEL</span>",
						｢numeration｣ => "",
						｢target｣     => "\$*KERNEL",
						｢level｣      => "4"
				},
				{
						｢target｣     => "\$*DISTRO",
						｢caption｣    => "<span class=\"code\">\$*DISTRO</span>",
						｢numeration｣ => "",
						｢level｣      => "4"
				},
				{
						｢level｣      => "4",
						｢numeration｣ => "",
						｢target｣     => "\$*VM",
						｢caption｣    => "<span class=\"code\">\$*VM</span>"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "<span class=\"code\">\$*RAKU</span>",
						｢level｣      => "4",
						｢target｣     => "\$*RAKU"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "4",
						｢target｣     => "\$*PERL",
						｢caption｣    => "<span class=\"code\">\$*PERL</span>"
				},
				{
						｢level｣      => "4",
						｢target｣     => "\$*PID",
						｢numeration｣ => "",
						｢caption｣    => "<span class=\"code\">\$*PID</span>"
				},
				{
						｢target｣     => "\$*PROGRAM-NAME",
						｢level｣      => "4",
						｢caption｣    => "<span class=\"code\">\$*PROGRAM-NAME</span>",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "4",
						｢target｣     => "\$*PROGRAM",
						｢numeration｣ => "",
						｢caption｣    => "<span class=\"code\">\$*PROGRAM</span>"
				},
				{
						｢level｣      => "4",
						｢caption｣    => "<span class=\"code\">\&amp;*EXIT</span>",
						｢numeration｣ => "",
						｢target｣     => "\&amp;*EXIT"
				},
				{
						｢level｣      => "4",
						｢numeration｣ => "",
						｢target｣     => "\$*EXIT",
						｢caption｣    => "<span class=\"code\">\$*EXIT</span>"
				},
				{
						｢level｣      => "4",
						｢numeration｣ => "",
						｢target｣     => "\$*EXCEPTION",
						｢caption｣    => "<span class=\"code\">\$*EXCEPTION</span>"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "\$*EXECUTABLE",
						｢level｣      => "4",
						｢caption｣    => "<span class=\"code\">\$*EXECUTABLE</span>"
				},
				{
						｢target｣     => "\$*EXECUTABLE-NAME",
						｢level｣      => "4",
						｢caption｣    => "<span class=\"code\">\$*EXECUTABLE-NAME</span>",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "\$*USAGE",
						｢caption｣    => "<span class=\"code\">\$*USAGE</span>",
						｢numeration｣ => "",
						｢level｣      => "4"
				},
				{
						｢target｣     => "\$*USER",
						｢numeration｣ => "",
						｢level｣      => "4",
						｢caption｣    => "<span class=\"code\">\$*USER</span>"
				},
				{
						｢target｣     => "\$*GROUP",
						｢caption｣    => "<span class=\"code\">\$*GROUP</span>",
						｢numeration｣ => "",
						｢level｣      => "4"
				},
				{
						｢level｣      => "4",
						｢target｣     => "\$*HOMEDRIVE",
						｢caption｣    => "<span class=\"code\">\$*HOMEDRIVE</span>",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "4",
						｢numeration｣ => "",
						｢target｣     => "\$*HOMEPATH",
						｢caption｣    => "<span class=\"code\">\$*HOMEPATH</span>"
				},
				{
						｢level｣      => "4",
						｢target｣     => "\$*HOME",
						｢caption｣    => "<span class=\"code\">\$*HOME</span>",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "\$*SPEC",
						｢caption｣    => "<span class=\"code\">\$*SPEC</span>",
						｢level｣      => "4",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "<span class=\"code\">\$*TMPDIR</span>",
						｢numeration｣ => "",
						｢level｣      => "4",
						｢target｣     => "\$*TMPDIR"
				},
				{
						｢target｣     => "\$*THREAD",
						｢level｣      => "4",
						｢caption｣    => "<span class=\"code\">\$*THREAD</span>",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "<span class=\"code\">\$*SCHEDULER</span>",
						｢target｣     => "\$*SCHEDULER",
						｢level｣      => "4"
				},
				{
						｢target｣     => "\$*SAMPLER",
						｢level｣      => "4",
						｢caption｣    => "<span class=\"code\">\$*SAMPLER</span>",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "3",
						｢target｣     => "Runtime_variables",
						｢caption｣    => "Runtime variables",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "\$*DEFAULT-READ-ELEMS",
						｢numeration｣ => "",
						｢level｣      => "4",
						｢caption｣    => "<span class=\"code\">\$*DEFAULT-READ-ELEMS</span>"
				},
				{
						｢target｣     => "\$*COLLATION",
						｢caption｣    => "<span class=\"code\">\$*COLLATION</span>",
						｢numeration｣ => "",
						｢level｣      => "4"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "4",
						｢caption｣    => "<span class=\"code\">\$*RAT-OVERFLOW</span>",
						｢target｣     => "\$*RAT-OVERFLOW"
				},
				{
						｢level｣      => "4",
						｢numeration｣ => "",
						｢target｣     => "\$*TOLERANCE",
						｢caption｣    => "<span class=\"code\">\$*TOLERANCE</span>"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "Naming_conventions",
						｢caption｣    => "Naming conventions",
						｢level｣      => 1
				}
			]
		},
		｢routine/read｣                      => {
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢type｣     => "composite",
			｢subtitle｣ => "From: en/type/IO/Socket, en/type/IO/CatHandle.",
			｢modified｣ => "Instant.from-posix(1742118641.914917318)",
			｢title｣    => "The <b>read</b> routine"
		},
		｢routine/is｣                        => {
			｢type｣     => "composite",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢subtitle｣ => "From: en/type/IO/Spec/Cygwin, en/type/IO/Spec/Win32, en/type/IO/Spec/Unix.",
			｢title｣    => "The <b>is</b> routine",
			｢modified｣ => "Instant.from-posix(1742118642.208040245)"
		},
		｢operator/~%5E｣                     => {
			｢config｣   => {
				｢kind｣  => "operator",
				｢index｣ => False
			},
			｢type｣     => "composite",
			｢modified｣ => "Instant.from-posix(1742118640.25948062)",
			｢title｣    => "The <b>~^</b> operator",
			｢subtitle｣ => "From: en/language/operators, en/language/operators."
		},
		｢programs｣                          => {
			｢toc｣        => [],
			｢defns｣      => {},
			｢subtitle｣   => "",
			｢index｣      => {},
			｢config｣     => {
				｢page-content-columns｣ => True,
				｢no-glossary｣          => True
			},
			｢modified｣   => "Instant.from-posix(1741016460.355613925)",
			｢title｣      => "Raku Programs Documentation",
			｢xtrk-targs｣ => {},
			｢type｣       => "glue"
		},
		｢type/IO/CatHandle｣                 => {
			｢index｣      => {},
			｢modified｣   => "Instant.from-posix(1730070864.910096394)",
			｢config｣     => {
				｢category｣ => "domain-specific",
				｢subkind｣  => "class",
				｢kind｣     => "Type"
			},
			｢xtrk-targs｣ => {},
			｢toc｣        => [
				{
						｢numeration｣ => "",
						｢caption｣    => "Methods",
						｢target｣     => "Methods",
						｢level｣      => 1
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "method new",
						｢target｣     => "method_new",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢target｣     => "method_chomp",
						｢numeration｣ => "",
						｢caption｣    => "method chomp"
				},
				{
						｢caption｣    => "method nl-in",
						｢target｣     => "method_nl-in",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "method close",
						｢target｣     => "method_close",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "method_comb",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method comb"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method DESTROY",
						｢target｣     => "method_DESTROY"
				},
				{
						｢target｣     => "method_encoding",
						｢numeration｣ => "",
						｢caption｣    => "method encoding",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method eof",
						｢target｣     => "method_eof",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "method get",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_get"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "method_getc",
						｢caption｣    => "method getc"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "method_handles",
						｢caption｣    => "method handles"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_IO",
						｢caption｣    => "method IO"
				},
				{
						｢target｣     => "method_lines",
						｢caption｣    => "method lines",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "method_lock",
						｢level｣      => "2",
						｢caption｣    => "method lock",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢target｣     => "method_native-descriptor",
						｢level｣      => "2",
						｢caption｣    => "method native-descriptor"
				},
				{
						｢target｣     => "method_next-handle",
						｢numeration｣ => "",
						｢caption｣    => "method next-handle",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method on-switch",
						｢target｣     => "method_on-switch"
				},
				{
						｢caption｣    => "method open",
						｢numeration｣ => "",
						｢target｣     => "method_open",
						｢level｣      => "2"
				},
				{
						｢target｣     => "method_opened",
						｢caption｣    => "method opened",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢target｣     => "method_path",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method path"
				},
				{
						｢level｣      => "2",
						｢target｣     => "method_read",
						｢numeration｣ => "",
						｢caption｣    => "method read"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "method readchars",
						｢level｣      => "2",
						｢target｣     => "method_readchars"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "method_seek",
						｢level｣      => "2",
						｢caption｣    => "method seek"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method tell",
						｢numeration｣ => "",
						｢target｣     => "method_tell"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method slurp",
						｢numeration｣ => "",
						｢target｣     => "method_slurp"
				},
				{
						｢level｣      => "2",
						｢target｣     => "method_split",
						｢caption｣    => "method split",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "method Str",
						｢level｣      => "2",
						｢target｣     => "method_Str"
				},
				{
						｢target｣     => "method_Supply",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method Supply"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method t",
						｢numeration｣ => "",
						｢target｣     => "method_t"
				},
				{
						｢target｣     => "method_unlock",
						｢caption｣    => "method unlock",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_words",
						｢caption｣    => "method words"
				},
				{
						｢target｣     => "Class_relation_diagram",
						｢caption｣    => "Class relation diagram",
						｢level｣      => 1,
						｢numeration｣ => ""
				}
			],
			｢title｣      => "class IO::CatHandle",
			｢defns｣      => {
				｢en#type/IO/CatHandle#015｣ => {
					｢targ-in-fn｣ => "method_native-descriptor",
					｢kind｣       => "routine",
					｢name｣       => "native-descriptor",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#015\")},\n      paragraphs  => (\n        \"method native-descriptor\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method native-descriptor(IO::CatHandle:D: --> Int:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"native-descriptor\",\n        ),\n        meta   => (\n          \"/type/IO::Handle#method_native-descriptor\",\n        )\n      ),\n      \"\\nof the currently active source handle or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \" if the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"source handle queue has\\nbeen exhausted\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Since the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"CatHandle\",\n        )\n      ),\n      \" closes a source handle, once it's done with it, it's\\npossible for successive source handles to have the same native descriptor, if\\nthey were passed to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".new\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_new\",\n        )\n      ),\n      \" as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Cool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Cool\",\n        )\n      ),\n      \"\\nor \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Path\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Path\",\n        )\n      ),\n      \" objects.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'foo';\\n(my \\\$f2 = 'bar'.IO).spurt: 'bar';\\nwith IO::CatHandle.new: \\\$f1, \\\$f2, \\\$*IN \\\{\\n    repeat \\\{ .native-descriptor.say } while .next-handle;\\n    # OUTPUT: «13␤13␤9␤»\\n}\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#type/IO/CatHandle#002｣ => {
					｢name｣       => "chomp",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#002\")},\n      paragraphs  => (\n        \"method chomp\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method chomp(IO::CatHandle:D:) is rw\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Sets the invocant's \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$.chomp\",\n        )\n      ),\n      \" attribute to the assigned value. All source\\nhandles, including the active one will use the provided \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$.chomp\",\n        )\n      ),\n      \" value.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: \\\"A\\\\nB\\\\nC\\\\n\\\";\\n(my \\\$f2 = 'bar'.IO).spurt: \\\"D\\\\nE\\\\n\\\";\\nwith IO::CatHandle.new: \\\$f1, \\\$f2 \\\{\\n    # .chomp is True by default:\\n    (.get xx 2).raku.say; # OUTPUT: «(\\\"A\\\", \\\"B\\\").Seq␤»\\n\\n    .chomp = False;\\n    (.get xx 3).raku.say; # OUTPUT: «(\\\"C\\\\n\\\", \\\"D\\\\n\\\", \\\"E\\\\n\\\").Seq␤»\\n    .close\\n}\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_chomp"
				},
				｢en#type/IO/CatHandle#016｣ => {
					｢name｣       => "next-handle",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#016\")},\n      paragraphs  => (\n        \"method next-handle\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method next-handle(IO::CatHandle:D: --> IO::Handle:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Switches the active source handle to the next handle in the source handle\\nqueue, which is the sources given in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@handles\",\n        )\n      ),\n      \" attribute to\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".new\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_new\",\n        )\n      ),\n      \". The return value is the currently\\nactive source handle or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \" if the source handle queue has been exhausted.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Cool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Cool\",\n        )\n      ),\n      \" source \\\"handles\\\" to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Path\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Path\",\n        )\n      ),\n      \"; opens \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Path\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Path\",\n        )\n      ),\n      \" and unopened\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle\",\n        )\n      ),\n      \" source handles for reading using the invocant's\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$.nl-in\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_nl-in\",\n        )\n      ),\n      \",\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$.chomp\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_chomp\",\n        )\n      ),\n      \", and\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$.encoding\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_encoding\",\n        )\n      ),\n      \" attributes;\\nthose same attributes of already-opened \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle\",\n        )\n      ),\n      \" objects will be changed to\\nthe values of the invocant's attributes.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This method is called automatically whenever CatHandle's methods require\\na switch to the next source handle, triggers\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".on-switch\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_on-switch\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Callable\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Callable\",\n        )\n      ),\n      \" to be called,\\nand is called once during \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".new\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_new\",\n        )\n      ),\n      \" call. The\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".on-switch\",\n        )\n      ),\n      \" will continue to be triggered each time this method is called,\\neven after the source handle queue has been exhausted. Note\\nthat generally reaching the EOF of the currently active source handle does not\\ntrigger the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".next-handle\",\n        )\n      ),\n      \" call, but rather further read operations that\\nneed more data do.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: \\\"a\\\\nb\\\";\\n(my \\\$f2 = 'bar'.IO).spurt: \\\"c\\\\nd\\\";\\nwith IO::CatHandle.new: :on-switch\\\{ say '▸ Switching' }, \\\$f1, \\\$f2 \\\{\\n    say 'one';\\n    .next-handle.^name.say;\\n    say 'two';\\n    .next-handle.^name.say;\\n    say 'three';\\n    .next-handle.^name.say;\\n    # OUTPUT:\\n    # ▸ Switching\\n    # one\\n    # ▸ Switching\\n    # IO::Handle\\n    # two\\n    # ▸ Switching\\n    # Nil\\n    # three\\n    # ▸ Switching\\n    # Nil\\n}\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_next-handle"
				},
				｢en#type/IO/CatHandle#027｣ => {
					｢name｣       => "Str",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#027\")},\n      paragraphs  => (\n        \"method Str\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method Str(IO::CatHandle:D: --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Calls \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle#method_Str\",\n        )\n      ),\n      \" on the currently active source\\nhandle and returns the result. If the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"source handle\\nqueue has been exhausted\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \", returns\\nan implementation-defined string (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"'<closed IO::CatHandle>'\",\n        )\n      ),\n      \" in Rakudo).\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_Str",
					｢kind｣       => "routine",
					｢subkind｣    => "method"
				},
				｢en#type/IO/CatHandle#022｣ => {
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#022\")},\n      paragraphs  => (\n        \"method readchars\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method readchars(IO::CatHandle:D: Int(Cool:D) \\\$chars = 65536 --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" of up to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$chars\",\n        )\n      ),\n      \" characters read from the handle.\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$chars\",\n        )\n      ),\n      \" defaults to an implementation-specific value (in Rakudo, the value of\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*DEFAULT-READ-ELEMS\",\n        )\n      ),\n      \", which by default is set to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"65536\",\n        )\n      ),\n      \").\\nIt is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NOT\",\n        )\n      ),\n      \" permitted to call this method on handles opened in binary\\nmode and doing so will result in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"X::IO::BinaryMode\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/X::IO::BinaryMode\",\n        )\n      ),\n      \" exception being thrown.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'Raku loves to';\\n(my \\\$f2 = 'bar'.IO).spurt: ' meow';\\n\\nwith IO::CatHandle.new: \\\$f1, \\\$f2 \\\{\\n    say .readchars: 11;   # OUTPUT: «Raku loves ␤»\\n    say .readchars: 1000; # OUTPUT: «to meow␤»\\n}\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_readchars",
					｢name｣       => "readchars"
				},
				｢en#type/IO/CatHandle#017｣ => {
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_on-switch",
					｢name｣       => "on-switch",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#017\")},\n      paragraphs  => (\n        \"method on-switch\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"has \\\&.on-switch is rw\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"One of the attributes that can be set during\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".new\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_new\",\n        )\n      ),\n      \" call and changed later by assigning\\nto. By default is not specified. Takes a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Callable\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Callable\",\n        )\n      ),\n      \" with\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".count\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Code#method_count\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"0\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"1\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"2\",\n        )\n      ),\n      \", or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Inf\",\n        )\n      ),\n      \". Gets called\\nevery time \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".next-handle\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \" is, which\\nhappens once during \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".new\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_new\",\n        )\n      ),\n      \" call and then each\\ntime a source handle is switched to the next one in the queue, or when the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".next-handle\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \" method is called\\nmanually.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".count\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Code#method_count\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\&.on-switch\",\n        )\n      ),\n      \" is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"0\",\n        )\n      ),\n      \", it\\nreceives no arguments; if it's \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"1\",\n        )\n      ),\n      \", it receives the currently active handle,\\nand if it's \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"2\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Inf\",\n        )\n      ),\n      \", it receives the currently active handle, and the\\nlast active handle as positional arguments (in that order). On the very\\nfirst \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\&.on-switch\",\n        )\n      ),\n      \" execution, the \\\"last active handle\\\" argument is\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \". Upon source handle queue exhaustion the \\\"currently active handle\\\"\\nargument is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \", and all the executions made afterwards have both arguments\\nas \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: \\\"A\\\\nB\\\\nC\\\";\\n(my \\\$f2 = 'bar'.IO).spurt: \\\"D\\\\nE\\\";\\n\\nmy \\\$line;\\nmy \\\$cat = IO::CatHandle.new: :on-switch\\\{ \\\$line = 1 }, \\\$f1, \\\$f2;\\nsay \\\"\\\{\\\$cat.path}:\\\{\\\$line++} \\\$_\\\" for \\\$cat.lines;\\n# OUTPUT:\\n# foo:1 A\\n# foo:2 B\\n# foo:3 C\\n# bar:1 D\\n# bar:2 E\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"my \\\@old-stuff;\\nsub on-switch (\\\$new, \\\$old) \\\{\\n    \\\$new and \\\$new.seek: 1, SeekFromBeginning;\\n    \\\$old and \\\@old-stuff.push: \\\$old.open.slurp: :close;\\n}\\n\\n(my \\\$f1 = 'foo'.IO).spurt: \\\"A\\\\nB\\\\nC\\\";\\n(my \\\$f2 = 'bar'.IO).spurt: \\\"D\\\\nE\\\";\\nmy \\\$cat = IO::CatHandle.new: :\\\&on-switch, \\\$f1, \\\$f2;\\n\\\$cat.lines.raku.say; # OUTPUT: «(\\\"\\\", \\\"B\\\", \\\"C\\\", \\\"\\\", \\\"E\\\").Seq␤»\\n\\\@old-stuff.raku.say; # OUTPUT: «[\\\"A\\\\nB\\\\nC\\\", \\\"D\\\\nE\\\"]␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine"
				},
				｢en#type/IO/CatHandle#026｣ => {
					｢targ-in-fn｣ => "method_split",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#026\")},\n      paragraphs  => (\n        \"method split\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method split(IO::CatHandle:D: |args --> Seq:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Read the handle and processes its contents the same way\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str.split\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str#routine_split\",\n        )\n      ),\n      \" does, taking the same arguments.\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Implementations may slurp the contents of all the source handles\",\n        )\n      ),\n      \" in their\\nentirety when this method is called.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'foo';\\n(my \\\$f2 = 'bar'.IO).spurt: 'bar';\\nIO::CatHandle.new(\\\$f1, \\\$f2).split(/o+/).raku.say;\\n# OUTPUT: «(\\\"f\\\", \\\"bar\\\").Seq␤»\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢name｣       => "split"
				},
				｢en#type/IO/CatHandle#024｣ => {
					｢targ-in-fn｣ => "method_tell",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#024\")},\n      paragraphs  => (\n        \"method tell\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method tell(IO::CatHandle:D: --> Int:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Calls \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".tell\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle#method_tell\",\n        )\n      ),\n      \" on the currently active source\\nhandle and returns the result. Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \" if the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"source handle\\nqueue has been exhausted\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'foo';\\n(my \\\$f2 = 'bar'.IO).spurt: 'bar';\\n\\nwith IO::CatHandle.new: \\\$f1, \\\$f2 \\\{\\n    .get.say;                   # OUTPUT: «foo␤»\\n    .tell.say;                  # OUTPUT: «3␤»\\n    .seek: -2, SeekFromCurrent;\\n    .tell.say;                  # OUTPUT: «1␤»\\n    say .readchars: 3;          # OUTPUT: «oob␤»\\n    .tell.say;                  # OUTPUT: «2␤»\\n    }\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢name｣       => "tell"
				},
				｢en#type/IO/CatHandle#008｣ => {
					｢name｣       => "eof",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#008\")},\n      paragraphs  => (\n        \"method eof\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method eof(IO::CatHandle:D: --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if the read operations have exhausted the source handle\\nqueue, including the contents of the last handle. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Note:\",\n        )\n      ),\n      \" calling this\\nmethod may cause one or more\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".on-switch\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_on-switch\",\n        )\n      ),\n      \" calls, while\\nthe source handle queue is examined, and the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"source handle queue may get\\nexhausted\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'foo';\\n(my \\\$f2 = 'bar'.IO).spurt: 'bar';\\nwith IO::CatHandle.new: :on-switch\\\{ print 'SWITCH! ' }, \\\$f1, \\\$f2 \\\{\\n                   # OUTPUT: «SWITCH! »\\n    .eof.say;      # OUTPUT: «False␤»\\n    .readchars(3);\\n    .eof.say;      # OUTPUT: «SWITCH! False␤»\\n\\n    .slurp;        # OUTPUT: «SWITCH! »\\n    .eof.say;      # OUTPUT: «True␤»\\n}\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The same caveats for non-seekable handles and empty files that apply to\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Handle.eof\",\n        ),\n        meta   => (\n          \"/type/IO::Handle#method_eof\",\n        )\n      ),\n      \" apply here.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_eof"
				},
				｢en#type/IO/CatHandle#011｣ => {
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#011\")},\n      paragraphs  => (\n        \"method handles\\n\\n\",\n      )\n    ),\n    \"Defines as:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method handles(IO::CatHandle:D: --> Seq:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \" containing the currently-active handle, as well as all the\\nremaining source handles produced by calling \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"next-handle\",\n        ),\n        meta   => (\n          \"/routine/next-handle\",\n        )\n      ),\n      \". If the invocant\\nhas already been fully-consumed, returns an empty \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This method is especially handy when working with \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::ArgFiles\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::ArgFiles\",\n        )\n      ),\n      \", where you\\nwant to treat each filehandle separately:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"# print at most the first 2 lines of each file in \\\$*ARGFILES:\\n.say for flat \\\$*ARGFILES.handles.map: *.lines: 2\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"It \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"is\",\n        )\n      ),\n      \" acceptable to call this method multiple times; \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".handles.head\",\n        )\n      ),\n      \" is a\\nvalid idiom for obtaining the currently-active handle. If, between\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"reification\",\n        ),\n        meta   => (\n          \"/language/glossary#Reify\",\n        )\n      ),\n      \" of the elements of the\\nreturned \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \" the handles get switched by some other means, the next\\nelement produced by the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \" would be the next handle of the\\ninvocant, not the handle that would've been produced if no switching occurred:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"(my \\\$file1 := 'file1'.IO).spurt: \\\"1a\\\\n1b\\\\n1c\\\";\\n(my \\\$file2 := 'file2'.IO).spurt: \\\"2a\\\\n2b\\\\n2c\\\";\\n(my \\\$file3 := 'file3'.IO).spurt: \\\"3a\\\\n3b\\\\n3c\\\";\\nmy \\\$cat := IO::CatHandle.new: \\\$file1, \\\$file2, \\\$file3;\\nfor \\\$cat.handles \\\{\\n    say .lines: 2;\\n    \\\$cat.next-handle;\\n}\\n# OUTPUT: «(1a 1b)␤(3a 3b)␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Likewise, reifying the returned \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \" consumes the invocant's source\\nhandles and once it is fully reified the invocant becomes fully-consumed.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_handles",
					｢name｣       => "handles"
				},
				｢en#type/IO/CatHandle#009｣ => {
					｢kind｣       => "routine",
					｢name｣       => "get",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#009\")},\n      paragraphs  => (\n        \"method get\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method get(IO::CatHandle:D: --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a single line of input from the handle, with the new line string\\ndefined by the value(s) of\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$.nl-in\",\n            )\n          ),\n          \" attribute\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_nl-in\",\n        )\n      ),\n      \", which will be removed\\nfrom the line if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$.chomp\",\n            )\n          ),\n          \" attribute\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_chomp\",\n        )\n      ),\n      \"\\nis set to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \". Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \" when there is no more input.\\nIt is an error to call this method when the handle is\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"in binary mode\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_encoding\",\n        )\n      ),\n      \", resulting in\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"X::IO::BinaryMode\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/X::IO::BinaryMode\",\n        )\n      ),\n      \" exception being thrown.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: \\\"a\\\\nb\\\\nc\\\";\\n(my \\\$f2 = 'bar'.IO).spurt: \\\"d\\\\ne\\\";\\nmy \\\$cat = IO::CatHandle.new: \\\$f1, \\\$f2;\\n.say while \\\$_ = \\\$cat.get; # OUTPUT: «a␤b␤c␤d␤e␤»\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_get"
				},
				｢en#type/IO/CatHandle#031｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#031\")},\n      paragraphs  => (\n        \"method words\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method words(IO::CatHandle:D: \\\$limit = Inf, :\\\$close --> Seq:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle.words\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle#routine_words\",\n        )\n      ),\n      \" (including\\nthe caveat about more data read than needed to make some number of words).\\nNote that a boundary between source handles is considered to be word boundary.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'foo bar';\\n(my \\\$f2 = 'bar'.IO).spurt: 'meow';\\nIO::CatHandle.new(\\\$f1, \\\$f2).words.raku.say;\\n# OUTPUT: «(\\\"foo\\\", \\\"bar\\\", \\\"meow\\\").Seq␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note: if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$close\",\n        )\n      ),\n      \" is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \", fully-consumed handles are \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"still\",\n        )\n      ),\n      \" going\\nto be closed.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢name｣       => "words",
					｢targ-in-fn｣ => "method_words",
					｢kind｣       => "routine"
				},
				｢en#type/IO/CatHandle#003｣ => {
					｢targ-in-fn｣ => "method_nl-in",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#003\")},\n      paragraphs  => (\n        \"method nl-in\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method nl-in(IO::CatHandle:D:) is rw\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Sets the invocant's \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$.nl-in\",\n        )\n      ),\n      \" attribute to the assigned value, which can be a\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" or a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"List\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/List\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \", where each\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" object represents the end-of-line string. All source handles,\\nincluding the active one will use the provided \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$.nl-in\",\n        )\n      ),\n      \" value. Note that\\nsource handle boundary is always counted as a new line break.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: \\\"A\\\\nB\\\\nC\\\";\\n(my \\\$f2 = 'bar'.IO).spurt: \\\"DxEx\\\";\\nwith IO::CatHandle.new: \\\$f1, \\\$f2 \\\{\\n    # .nl-in is [\\\"\\\\n\\\", \\\"\\\\r\\\\n\\\"] by default:\\n    (.get xx 2).raku.say; # OUTPUT: «(\\\"A\\\", \\\"B\\\").Seq␤»\\n\\n    .nl-in = 'x';\\n    (.get xx 3).raku.say; # OUTPUT: «(\\\"C\\\", \\\"D\\\", \\\"E\\\").Seq␤»\\n    .close\\n}\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "nl-in"
				},
				｢en#type/IO/CatHandle#028｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#028\")},\n      paragraphs  => (\n        \"method Supply\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method Supply(IO::CatHandle:D: :\\\$size = 65536 --> Supply:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Supply\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Supply\",\n        )\n      ),\n      \" fed with either\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".read\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_read\",\n        )\n      ),\n      \", if the handle is in\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"binary mode\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_encoding\",\n        )\n      ),\n      \", or with\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".readchars\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_readchars\",\n        )\n      ),\n      \", if it isn't, with\\nreads of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$size\",\n        )\n      ),\n      \" bytes or characters. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$size\",\n        )\n      ),\n      \" defaults to an implementation-specific value (in Rakudo, the value of\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*DEFAULT-READ-ELEMS\",\n        )\n      ),\n      \", which by default is set to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"65536\",\n        )\n      ),\n      \").\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'foo';\\n(my \\\$f2 = 'bar'.IO).spurt: 'bar';\\nreact whenever IO::CatHandle.new(\\\$f1, \\\$f2).Supply: :2size \\\{.say}\\n# OUTPUT: «fo␤ob␤ar␤»\\n\\nreact whenever IO::CatHandle.new(:bin, \\\$f1, \\\$f2).Supply: :2size \\\{.say}\\n# OUTPUT: «Buf[uint8]:0x<66 6f>␤Buf[uint8]:0x<6f 62>␤Buf[uint8]:0x<61 72>␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_Supply",
					｢subkind｣    => "method",
					｢name｣       => "Supply"
				},
				｢en#type/IO/CatHandle#019｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#019\")},\n      paragraphs  => (\n        \"method opened\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method opened(IO::CatHandle:D: --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if the invocant has any source handles, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \" otherwise.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"say IO::CatHandle.new      .opened; # OUTPUT: «False␤»\\nsay IO::CatHandle.new(\\\$*IN).opened; # OUTPUT: «True␤»\\n\\n(my \\\$f1 = 'foo'.IO).spurt: \\\"A\\\\nB\\\\nC\\\";\\nwith IO::CatHandle.new: \\\$f1 \\\{\\n    .opened.say; # OUTPUT: «True␤»\\n    .slurp;\\n    .opened.say; # OUTPUT: «False␤»\\n}\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_opened",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢name｣       => "opened"
				},
				｢en#type/IO/CatHandle#025｣ => {
					｢targ-in-fn｣ => "method_slurp",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#025\")},\n      paragraphs  => (\n        \"method slurp\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method slurp(IO::CatHandle:D:)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Reads all of the available input from all the source handles and returns it\\nas a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Buf\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Buf\",\n        )\n      ),\n      \" if the handle is in\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"binary mode\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_encoding\",\n        )\n      ),\n      \" or as a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" otherwise.\\nReturns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \" if the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"source handle\\nqueue has been exhausted\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'foo';\\n(my \\\$f2 = 'bar'.IO).spurt: 'bar';\\n\\nIO::CatHandle.new(      \\\$f1, \\\$f2).slurp.say; # OUTPUT: «foobar␤»\\nIO::CatHandle.new(:bin, \\\$f1, \\\$f2).slurp.say; # OUTPUT: «Buf[uint8]:0x<66 6f 6f 62 61 72>␤»\\nIO::CatHandle.new                .slurp.say; # OUTPUT: «Nil␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢name｣       => "slurp"
				},
				｢en#type/IO/CatHandle#010｣ => {
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_getc",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#010\")},\n      paragraphs  => (\n        \"method getc\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method getc(IO::CatHandle:D: --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a single character of input from the handle. All\\nthe caveats described in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle.getc\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle#routine_getc\",\n        )\n      ),\n      \"\\napply. Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \" when there is no more input.\\nIt is an error to call this method when the handle is\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"in binary mode\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_encoding\",\n        )\n      ),\n      \", resulting in\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"X::IO::BinaryMode\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/X::IO::BinaryMode\",\n        )\n      ),\n      \" exception being thrown.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'I ♥ Raku';\\n(my \\\$f2 = 'bar'.IO).spurt: 'meow';\\nmy \\\$cat = IO::CatHandle.new: \\\$f1, \\\$f2;\\n.say while \\\$_ = \\\$cat.getc; # OUTPUT: «I␤ ␤♥␤ ␤R␤a␤k␤u␤m␤e␤o␤w␤»\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "getc"
				},
				｢en#type/IO/CatHandle#005｣ => {
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#005\")},\n      paragraphs  => (\n        \"method comb\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method comb(IO::CatHandle:D: |args --> Seq:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Read the handle and processes its contents the same way\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str.comb\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str#routine_comb\",\n        )\n      ),\n      \" does, taking the same arguments.\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Implementations may slurp the contents of all the source handles\",\n        )\n      ),\n      \" in their\\nentirety when this method is called.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'foo';\\n(my \\\$f2 = 'bar'.IO).spurt: 'bar';\\nIO::CatHandle.new(\\\$f1, \\\$f2).comb(2).raku.say;\\n# OUTPUT: «(\\\"fo\\\", \\\"ob\\\", \\\"ar\\\").Seq␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_comb",
					｢name｣       => "comb"
				},
				｢en#type/IO/CatHandle#018｣ => {
					｢name｣       => "open",
					｢targ-in-fn｣ => "method_open",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#018\")},\n      paragraphs  => (\n        \"method open\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method open(IO::CatHandle:D: --> IO::CatHandle:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the invocant. The intent of this method is to merely make CatHandle\\nworkable with things that open \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle\",\n        )\n      ),\n      \". You never have to call this method\\nintentionally.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#type/IO/CatHandle#001｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#001\")},\n      paragraphs  => (\n        \"method new\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      config     => \$\{:method(RakuAST::Term::Name.new(\n        RakuAST::Name.from-identifier(\"True\")\n      ))},\n      paragraphs => (\n        \"method new(*\\\@handles, :\\\&on-switch, :\\\$chomp = True,\\n           :\\\$nl-in = [\\\"\\\\n\\\", \\\"\\\\r\\\\n\\\"], Str :\\\$encoding, Bool :\\\$bin)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Creates a new \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::CatHandle\",\n        )\n      ),\n      \" object.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@handles\",\n        )\n      ),\n      \" positional argument indicates a source of handles for the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::CatHandle\",\n        )\n      ),\n      \" to read from and can deal with a mixed collection of\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Cool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Cool\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Path\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Path\",\n        )\n      ),\n      \", and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle\",\n        )\n      ),\n      \" (including \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Pipe\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Pipe\",\n        )\n      ),\n      \")\\nobjects. As input from \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::CatHandle\",\n        )\n      ),\n      \" is processed (so operations won't happen\\nduring \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".new\",\n        )\n      ),\n      \" call, but only when \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@handles\",\n        )\n      ),\n      \"' data is needed), it will walk\\nthrough the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@handles\",\n        )\n      ),\n      \" list, processing each argument as follows:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type        => \"item\",\n      abbreviated => True,\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"the\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"L\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"<\",\n                closer => \">\",\n                atoms  => (\n                  \"Cool\",\n                )\n              ),\n            ),\n            meta   => (\n              \"/type/Cool\",\n            )\n          ),\n          \" objects will be coerced to \",\n          RakuAST::Doc::Markup.new(\n            letter => \"L\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"<\",\n                closer => \">\",\n                atoms  => (\n                  \"IO::Path\",\n                )\n              ),\n            ),\n            meta   => (\n              \"/type/IO::Path\",\n            )\n          ),\n          \";\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      type        => \"item\",\n      abbreviated => True,\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          RakuAST::Doc::Markup.new(\n            letter => \"L\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"<\",\n                closer => \">\",\n                atoms  => (\n                  \"IO::Path\",\n                )\n              ),\n            ),\n            meta   => (\n              \"/type/IO::Path\",\n            )\n          ),\n          \" objects\\nwill be opened for reading using the \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::CatHandle\",\n            )\n          ),\n          \"'s (invocant's) attributes\\nfor \",\n          RakuAST::Doc::Markup.new(\n            letter => \"L\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"<\",\n                closer => \">\",\n                atoms  => (\n                  \"open\",\n                )\n              ),\n            ),\n            meta   => (\n              \"/routine/open\",\n            )\n          ),\n          \" calls;\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      type        => \"item\",\n      abbreviated => True,\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"un-opened \",\n          RakuAST::Doc::Markup.new(\n            letter => \"L\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"<\",\n                closer => \">\",\n                atoms  => (\n                  \"IO::Handle\",\n                )\n              ),\n            ),\n            meta   => (\n              \"/type/IO::Handle\",\n            )\n          ),\n          \" objects will be\\nopened in the same fashion as \",\n          RakuAST::Doc::Markup.new(\n            letter => \"L\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"<\",\n                closer => \">\",\n                atoms  => (\n                  \"IO::Path\",\n                )\n              ),\n            ),\n            meta   => (\n              \"/type/IO::Path\",\n            )\n          ),\n          \" objects;\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      type        => \"item\",\n      abbreviated => True,\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"and already opened\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"L\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"<\",\n                closer => \">\",\n                atoms  => (\n                  \"IO::Handle\",\n                )\n              ),\n            ),\n            meta   => (\n              \"/type/IO::Handle\",\n            )\n          ),\n          \" objects will have all of their attributes set to the attributes of\\nthe invocant \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::CatHandle\",\n            )\n          ),\n          \".\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"In short, all the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@handles\",\n        )\n      ),\n      \" end up as\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle\",\n        )\n      ),\n      \" objects opened in the same mode and with the same attributes as\\nthe invocant \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::CatHandle\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".on-switch\",\n            )\n          ),\n          \" method\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_on-switch\",\n        )\n      ),\n      \" for details\\non the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\&on-switch\",\n        )\n      ),\n      \" named argument, which by default is not set.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \":\\\$encoding\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_encoding\",\n        )\n      ),\n      \" named argument\\nspecifies the handle's encoding and accepts the same values as\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle.encoding\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle#method_encoding\",\n        )\n      ),\n      \". Set \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$bin\",\n        )\n      ),\n      \" named\\nargument to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if you wish the handle to be in binary mode. Attempting to\\nspecify both a defined \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$encoding\",\n        )\n      ),\n      \" and a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$bin\",\n        )\n      ),\n      \" is a fatal error\\nresulting in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"X::IO::BinaryAndEncoding\",\n        )\n      ),\n      \" exception thrown. If neither\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$encoding\",\n        )\n      ),\n      \" is set nor \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$bin\",\n        )\n      ),\n      \" set to a true value, the handle will default\\nto \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"utf8\",\n        )\n      ),\n      \" encoding.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$chomp\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$nl-in\",\n        )\n      ),\n      \" arguments have the same meaning as in\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle\",\n        )\n      ),\n      \" and take and default to the same values.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "new",
					｢targ-in-fn｣ => "method_new",
					｢kind｣       => "routine",
					｢subkind｣    => "method"
				},
				｢en#type/IO/CatHandle#023｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#023\")},\n      paragraphs  => (\n        \"method seek\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method seek(IO::CatHandle:D: |c)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Calls \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".seek\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle#method_seek\",\n        )\n      ),\n      \" on the currently active source\\nhandle, forwarding it all the arguments, and returns the result.\\nReturns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \" if the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"source handle\\nqueue has been exhausted\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \".\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NOTE:\",\n        )\n      ),\n      \" this method does \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NOT\",\n        )\n      ),\n      \" perform any source handle switching, so\\nseeking past the end of the current source handle will \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NOT\",\n        )\n      ),\n      \" seek to the next\\nsource handle in the queue and seeking past the beginning of the current\\nsource handle is a fatal error. Also see\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".next-handle\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \", to learn the\\ndetails on when source handles are switched.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'foo';\\n(my \\\$f2 = 'bar'.IO).spurt: 'bar';\\n\\nwith IO::CatHandle.new: \\\$f1, \\\$f2 \\\{\\n    .get.say;                     # OUTPUT: «foo␤»\\n    .seek: -2, SeekFromCurrent;\\n    .readchars(2).say;            # OUTPUT: «oo␤»\\n    .seek: 1000, SeekFromCurrent; # this doesn't switch to second handle!\\n    .readchars(3).say;            # OUTPUT: «bar␤»\\n    try .seek: -4;                # this won't seek to previous handle!\\n    say ~\\\$!;                      # OUTPUT: «Failed to seek in filehandle: 22␤»\\n}\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_seek",
					｢kind｣       => "routine",
					｢name｣       => "seek"
				},
				｢en#type/IO/CatHandle#021｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#021\")},\n      paragraphs  => (\n        \"method read\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method read(IO::CatHandle:D: Int(Cool:D) \\\$bytes = 65536 --> Buf:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Reads up to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$bytes\",\n        )\n      ),\n      \" bytes from the handle and returns them in a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Buf\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Buf\",\n        )\n      ),\n      \".\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$bytes\",\n        )\n      ),\n      \" defaults to an implementation-specific value (in Rakudo, the value of\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*DEFAULT-READ-ELEMS\",\n        )\n      ),\n      \", which by default is set to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"65536\",\n        )\n      ),\n      \").\\nIt is permitted to call this method on handles that are not in binary mode.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'meow';\\n(my \\\$f2 = 'bar'.IO).spurt: Blob.new: 4, 5, 6;\\nwith IO::CatHandle.new: :bin, \\\$f1, \\\$f2 \\\{\\n    say .read: 2;    # OUTPUT: «Buf[uint8]:0x<6d 65>␤»\\n    say .read: 2000; # OUTPUT: «Buf[uint8]:0x<6f 77 04 05 06>␤»\\n}\\n\\n# Non-binary mode is OK too:\\nwith IO::CatHandle.new: \\\$f1, \\\$f2 \\\{\\n    say .get;        # OUTPUT: «meow␤»\\n    say .read: 2000; # OUTPUT: «Buf[uint8]:0x<04 05 06>␤»\\n}\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_read",
					｢name｣       => "read",
					｢subkind｣    => "method",
					｢kind｣       => "routine"
				},
				｢en#type/IO/CatHandle#014｣ => {
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#014\")},\n      paragraphs  => (\n        \"method lock\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method lock(IO::CatHandle:D: Bool:D :\\\$non-blocking = False, Bool:D :\\\$shared = False --> True)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle.lock\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle#method_lock\",\n        )\n      ),\n      \". Returns\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \"\\nif the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"source handle queue has been exhausted\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Locks only the currently active source handle. The\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".on-switch\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_on-switch\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Callable\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Callable\",\n        )\n      ),\n      \" can be\\nused to conveniently lock/unlock the handles as they're being processed\\nby the CatHandle.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "lock",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_lock"
				},
				｢en#type/IO/CatHandle#012｣ => {
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢name｣       => "IO",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#012\")},\n      paragraphs  => (\n        \"method IO\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method IO(IO::CatHandle:D:)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Alias for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".path\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_path\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_IO"
				},
				｢en#type/IO/CatHandle#029｣ => {
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_t",
					｢name｣       => "t",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#029\")},\n      paragraphs  => (\n        \"method t\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method t(IO::CatHandle:D: --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Calls \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".t\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle#method_t\",\n        )\n      ),\n      \", which tells if the handle is a TTY,\\non the currently active source handle and returns the result.\\nIf the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"source handle queue has been exhausted\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \",\\nreturns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'foo';\\nwith IO::CatHandle.new: \\\$f1, \\\$*IN \\\{\\n    repeat \\\{ .t.say } while .next-handle; # OUTPUT: «False␤True␤»\\n}\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#type/IO/CatHandle#004｣ => {
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#004\")},\n      paragraphs  => (\n        \"method close\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method close(IO::CatHandle:D: --> True)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Closes the currently active source handle, as well as any already-open source\\nhandles, and empties the source handle queue. Unlike a regular\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle\",\n        )\n      ),\n      \", an explicit call to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".close\",\n        )\n      ),\n      \" is often not necessary on an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::CatHandle\",\n        )\n      ),\n      \", as merely exhausting all the input closes all the handles that\\nneed to be closed.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:skip-test(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"compile time error\"),\n        )\n      ))},\n      paragraphs => (\n        \"with IO::CatHandle.new: \\\@bunch-of-handles \\\{\\n    say .readchars: 42;\\n    .close; # we are done; close all the open handles\\n}\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "close",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_close"
				},
				｢en#type/IO/CatHandle#030｣ => {
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#030\")},\n      paragraphs  => (\n        \"method unlock\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method unlock(IO::CatHandle:D:)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle.unlock\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle#method_unlock\",\n        )\n      ),\n      \". Returns\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \" if the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"source handle queue has been exhausted\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Unlocks only the currently active source handle. The\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".on-switch\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_on-switch\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Callable\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Callable\",\n        )\n      ),\n      \" can be\\nused to conveniently lock/unlock the handles as they're being processed\\nby the CatHandle.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "unlock",
					｢targ-in-fn｣ => "method_unlock"
				},
				｢en#type/IO/CatHandle#007｣ => {
					｢subkind｣    => "method",
					｢name｣       => "encoding",
					｢targ-in-fn｣ => "method_encoding",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#007\")},\n      paragraphs  => (\n        \"method encoding\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi method encoding(IO::CatHandle:D:)\\nmulti method encoding(IO::CatHandle:D: \\\$new-encoding)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Sets the invocant's \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$.encoding\",\n        )\n      ),\n      \" attribute to the provided value. Valid values\\nare the same as those accepted by\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle.encoding\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle#method_encoding\",\n        )\n      ),\n      \" (use value\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \" to switch to binary mode). All source handles, including the active one\\nwill use the provided \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$.encoding\",\n        )\n      ),\n      \" value.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: 'I ♥ Raku';\\n(my \\\$f2 = 'bar'.IO).spurt: 'meow';\\nwith IO::CatHandle.new: \\\$f1, \\\$f2 \\\{\\n    # .encoding is 'utf8' by default:\\n    .readchars(5).say; # OUTPUT: «I ♥ R␤»\\n\\n    .encoding: Nil; # switch to binary mode\\n    .slurp.say; # OUTPUT: «Buf[uint8]:0x<6B 75 6D 65 6F 77>␤»\\n}\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#type/IO/CatHandle#020｣ => {
					｢name｣       => "path",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#020\")},\n      paragraphs  => (\n        \"method path\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method path(IO::CatHandle:D:)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the value of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".path\",\n            )\n          ),\n          \" attribute\",\n        ),\n        meta   => (\n          \"/type/IO::Handle#method_path\",\n        )\n      ),\n      \"\\nof the currently active source handle, or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \" if the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"source handle queue\\nhas been exhausted\",\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_next-handle\",\n        )\n      ),\n      \". Basically, if your\\nCatHandle is based on files, this is the way to get the path of the file the\\nCatHandle is currently reading from.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: \\\"A\\\\nB\\\\nC\\\";\\n(my \\\$f2 = 'bar'.IO).spurt: \\\"D\\\\nE\\\";\\n\\nmy \\\$line;\\nmy \\\$cat = IO::CatHandle.new: :on-switch\\\{ \\\$line = 1 }, \\\$f1, \\\$f2;\\nsay \\\"\\\{\\\$cat.path}:\\\{\\\$line++} \\\$_\\\" for \\\$cat.lines;\\n# OUTPUT:\\n# foo:1 A\\n# foo:2 B\\n# foo:3 C\\n# bar:1 D\\n# bar:2 E\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_path",
					｢kind｣       => "routine"
				},
				｢en#type/IO/CatHandle#013｣ => {
					｢subkind｣    => "method",
					｢name｣       => "lines",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#013\")},\n      paragraphs  => (\n        \"method lines\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method lines(IO::CatHandle:D: \\\$limit = Inf, :\\\$close --> Seq:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Handle.lines\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Handle#routine_lines\",\n        )\n      ),\n      \". Note that\\na boundary between source handles is considered to be a newline break.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(my \\\$f1 = 'foo'.IO).spurt: \\\"foo\\\\nbar\\\";\\n(my \\\$f2 = 'bar'.IO).spurt: 'meow';\\nIO::CatHandle.new(\\\$f1, \\\$f2).lines.raku.say;\\n# OUTPUT: «(\\\"foo\\\", \\\"bar\\\", \\\"meow\\\").Seq␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note: if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$close\",\n        )\n      ),\n      \" is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \", fully-consumed handles are \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"still\",\n        )\n      ),\n      \" going\\nto be closed.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_lines"
				},
				｢en#type/IO/CatHandle#006｣ => {
					｢targ-in-fn｣ => "method_DESTROY",
					｢name｣       => "DESTROY",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/CatHandle#006\")},\n      paragraphs  => (\n        \"method DESTROY\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method DESTROY(IO::CatHandle:D:)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Calls \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".close\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::CatHandle#method_close\",\n        )\n      ),\n      \".\\nThis method isn't to be used directly, but is something that's called during\\ngarbage collection.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢subkind｣    => "method"
				}
			},
			｢type｣       => "primary",
			｢subtitle｣   => "Use multiple IO handles as if they were one"
		},
		｢type/IO/Spec/Unix｣                 => {
			｢xtrk-targs｣ => {},
			｢index｣      => {},
			｢title｣      => "class IO::Spec::Unix",
			｢config｣     => {
				｢category｣ => "domain-specific",
				｢subkind｣  => "class",
				｢kind｣     => "Type"
			},
			｢subtitle｣   => "Platform specific operations on file and directory paths for POSIX",
			｢defns｣      => {
				｢en#type/IO/Spec/Unix#020｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#020\")},\n      paragraphs  => (\n        \"method tmpdir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"        \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method tmpdir(--> IO::Path:D)\\n\\n\",\n      )\n    ),\n    \"Attempts to locate a system's temporary directory by checking several typical directories and environment variables. Uses current directory if no suitable directories are found.\\n\\n\",\n  )\n)",
					｢subkind｣    => "method",
					｢name｣       => "tmpdir",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_tmpdir"
				},
				｢en#type/IO/Spec/Unix#007｣ => {
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_curdir",
					｢name｣       => "curdir",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#007\")},\n      paragraphs  => (\n        \"method curdir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method curdir()\\n\\n\",\n      )\n    ),\n    \"Returns a string representing the current directory:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say '.' eq \\\$*SPEC.curdir; # OUTPUT: «True␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Spec/Unix#002｣ => {
					｢targ-in-fn｣ => "method_basename",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#002\")},\n      paragraphs  => (\n        \"method basename\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method basename(Str:D \\\$path --> Str:D)\\n\\n\",\n      )\n    ),\n    \"Takes a path as a string and returns a possibly-empty portion after the\\nlast slash:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Unix.basename(\\\"foo/bar/\\\") .raku.say; # OUTPUT: «\\\"\\\"␤»\\nIO::Spec::Unix.basename(\\\"foo/bar/.\\\").raku.say; # OUTPUT: «\\\".\\\"␤»\\nIO::Spec::Unix.basename(\\\"foo/bar\\\")  .raku.say; # OUTPUT: «\\\"bar\\\"␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "basename",
					｢subkind｣    => "method",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Spec/Unix#001｣ => {
					｢targ-in-fn｣ => "method_abs2rel",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#001\")},\n      paragraphs  => (\n        \"method abs2rel\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method abs2rel(IO::Path:D \\\$path, IO::Path:D \\\$base = \\\$*CWD --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a string that represents \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \", but relative to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$base\",\n        )\n      ),\n      \"\\npath. Both \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$base\",\n        )\n      ),\n      \" may be relative paths. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$base\",\n        )\n      ),\n      \"\\ndefaults to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*CWD\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "abs2rel",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Spec/Unix#019｣ => {
					｢targ-in-fn｣ => "method_splitpath",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#019\")},\n      paragraphs  => (\n        \"method splitpath\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method splitpath(Cool:D \\\$path, :\\\$nofile --> List:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Splits the given \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" into a list of 3 strings: volume,\\ndirname, and file. The volume is always an empty string, returned for API\\ncompatibility with other \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Spec\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Spec\",\n        )\n      ),\n      \" types. If \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$nofile\",\n        )\n      ),\n      \" named argument is\\nset to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \", the content of the file string is undefined and should be\\nignored; this is a means to get a performance boost, as implementations may use\\nfaster code path when file is not needed.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"IO::Spec::Unix.splitpath('C:\\\\foo/bar.txt').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"C:\\\\\\\\foo/\\\", \\\"bar.txt\\\")␤»\\n\\nIO::Spec::Unix.splitpath('C:\\\\foo/bar.txt', :nofile).raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"C:\\\\\\\\foo/bar.txt\\\", \\\"\\\")␤»\\n\\nIO::Spec::Unix.splitpath('/foo/').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"/foo/\\\", \\\"\\\")␤»\\n\\nIO::Spec::Unix.splitpath('/foo/', :nofile).raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"/foo/\\\", \\\"\\\")␤»\\n\\nIO::Spec::Unix.splitpath('///').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"///\\\", \\\"\\\")␤»\\n\\nIO::Spec::Unix.splitpath('./').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"./\\\", \\\"\\\")␤»\\n\\nIO::Spec::Unix.splitpath('.').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"\\\", \\\".\\\")␤»\\n\\nIO::Spec::Unix.splitpath('').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"\\\", \\\"\\\")␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢name｣       => "splitpath",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Spec/Unix#006｣ => {
					｢subkind｣    => "method",
					｢name｣       => "catpath",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_catpath",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#006\")},\n      paragraphs  => (\n        \"method catpath\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method catpath (\\\$, Str:D \\\$part1, Str:D \\\$part2 --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Takes two path fragments and concatenates them, adding or removing a\\npath separator, if necessary. The first argument is ignored (it exists\\nto maintain consistent interface with other \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Spec\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Spec\",\n        )\n      ),\n      \" types for\\nsystems that have volumes).\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Unix.catpath(\\\$, 'some/dir', 'and/more').say;\\n# OUTPUT: «some/dir/and/more␤»\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#type/IO/Spec/Unix#005｣ => {
					｢name｣       => "catfile",
					｢targ-in-fn｣ => "method_catfile",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#005\")},\n      paragraphs  => (\n        \"method catfile\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Alias for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"catdir\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/catdir\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Spec/Unix#018｣ => {
					｢targ-in-fn｣ => "method_splitdir",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#018\")},\n      paragraphs  => (\n        \"method splitdir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method splitdir(Cool:D \\\$path --> List:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Splits the given \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" on slashes.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"IO::Spec::Unix.splitdir('C:\\\\foo/bar.txt').raku.say;\\n# OUTPUT: «(\\\"C:\\\\\\\\foo\\\", \\\"bar.txt\\\")␤»\\n\\nIO::Spec::Unix.splitdir('/foo/').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"foo\\\", \\\"\\\")␤»\\n\\nIO::Spec::Unix.splitdir('///').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"\\\", \\\"\\\", \\\"\\\")␤»\\n\\nIO::Spec::Unix.splitdir('./').raku.say;\\n# OUTPUT: «(\\\".\\\", \\\"\\\")␤»\\n\\nIO::Spec::Unix.splitdir('.').raku.say;\\n# OUTPUT: «(\\\".\\\",)␤»\\n\\nIO::Spec::Unix.splitdir('').raku.say;\\n# OUTPUT: «(\\\"\\\",)␤»\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢name｣       => "splitdir"
				},
				｢en#type/IO/Spec/Unix#008｣ => {
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢name｣       => "curupdir",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#008\")},\n      paragraphs  => (\n        \"method curupdir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method curupdir()\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Block\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Block\",\n        )\n      ),\n      \" taking an argument. This block\\nreturns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if its argument is neither the string representing the\\ncurrent directory nor the string representing the directory one up from\\nthe current one.  It returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \" otherwise.\\nThis block is intended to be used with\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"smartmatching\",\n        ),\n        meta   => (\n          \"/language/operators#infix_~~\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"say \\\$*SPEC.curupdir;\\n# OUTPUT: «-> str \\\$dir \\\{ #`(Block|65335808) ... }␤»\\n\\nmy \\\@dirs = <. foo .. bar>;\\nsay \\\@dirs.grep: \\\{ \\\$_ ~~ \\\$*SPEC.curupdir };\\n# OUTPUT: «(foo bar)␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Neither \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"foo\",\n        )\n      ),\n      \" nor \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"bar\",\n        )\n      ),\n      \" are equal to the representation of the current\\nor parent directory, that is why they are returned by \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"grep\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Note\",\n        )\n      ),\n      \": Before Rakudo version 2020.06 a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"none\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/none\",\n        )\n      ),\n      \"\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \" was returned instead of a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Block\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Block\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_curupdir"
				},
				｢en#type/IO/Spec/Unix#010｣ => {
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#010\")},\n      paragraphs  => (\n        \"method dir-sep\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method dir-sep(--> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the string \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\"/\\\"\",\n        )\n      ),\n      \" representing canonical directory separator\\ncharacter.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"IO::Spec::Unix.dir-sep.say; # OUTPUT: «/␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "dir-sep",
					｢targ-in-fn｣ => "method_dir-sep",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Spec/Unix#014｣ => {
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢name｣       => "path",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#014\")},\n      paragraphs  => (\n        \"method path\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method path(--> Seq:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Splits the value of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"\\\%*EN\",\n          RakuAST::Doc::Markup.new(\n            letter => \"V\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"PATH\",\n            )\n          ),\n        )\n      ),\n      \" on colons (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\":\\\"\",\n        )\n      ),\n      \"), replaces empty parts with\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\".\\\"\",\n        )\n      ),\n      \", and returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \" with each of the resultant parts. Returns\\nan empty \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"\\\%*EN\",\n          RakuAST::Doc::Markup.new(\n            letter => \"V\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"PATH\",\n            )\n          ),\n        )\n      ),\n      \" is not set or is an empty string.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        RakuAST::Doc::Paragraph.new(\n          \"\\\%*EN\",\n          RakuAST::Doc::Markup.new(\n            letter => \"V\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"PATH\",\n            )\n          ),\n          \" = 'foo:bar/ber::foo:';\\nIO::Spec::Unix.path.raku.say;\\n# OUTPUT: «(\\\"foo\\\", \\\"bar/ber\\\", \\\".\\\", \\\"foo\\\", \\\".\\\").Seq␤»\\n\\n\"\n        ),\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_path"
				},
				｢en#type/IO/Spec/Unix#012｣ => {
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#012\")},\n      paragraphs  => (\n        \"method is-absolute\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method is-absolute(Str:D \\\$path --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" starts with a slash (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\"/\\\"\",\n        )\n      ),\n      \"), even if it\\nhas combining character on it:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say IO::Spec::Unix.is-absolute: \\\"/foo\\\";        # OUTPUT: «True␤»\\nsay IO::Spec::Unix.is-absolute: \\\"/\\\\x[308]foo\\\"; # OUTPUT: «True␤»\\nsay IO::Spec::Unix.is-absolute: \\\"bar\\\";         # OUTPUT: «False␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_is-absolute",
					｢subkind｣    => "method",
					｢name｣       => "is-absolute"
				},
				｢en#type/IO/Spec/Unix#003｣ => {
					｢kind｣       => "routine",
					｢name｣       => "canonpath",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#003\")},\n      paragraphs  => (\n        \"method canonpath\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method canonpath(Str() \\\$path, :\\\$parent --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a string that is a canonical representation of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \". If\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$parent\",\n        )\n      ),\n      \" is set to true, will also clean up references to parent\\ndirectories. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NOTE:\",\n        )\n      ),\n      \" the routine does not access the filesystem, so no\\nsymlinks are followed.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Unix.canonpath(\\\"foo//../bar/../ber\\\").say;\\n# OUTPUT: «foo/../bar/../ber␤»\\n\\nIO::Spec::Unix.canonpath(\\\"foo///./../bar/../ber\\\").say;\\n# OUTPUT: «foo/../bar/../ber␤»\\n\\nIO::Spec::Unix.canonpath(\\\"foo///./../bar/../ber\\\", :parent).say;\\n# OUTPUT: «ber␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_canonpath"
				},
				｢en#type/IO/Spec/Unix#004｣ => {
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#004\")},\n      paragraphs  => (\n        \"method catdir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method catdir (*\\\@parts --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Concatenates multiple path fragments and returns the canonical\\nrepresentation of the resultant path as a string. The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@parts\",\n        )\n      ),\n      \" are\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" objects and are allowed to contain path separators.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Unix.catdir(<foo/bar ber raku>).say; # OUTPUT: «foo/bar/ber/raku␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_catdir",
					｢subkind｣    => "method",
					｢name｣       => "catdir"
				},
				｢en#type/IO/Spec/Unix#009｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#009\")},\n      paragraphs  => (\n        \"method devnull\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method devnull(--> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the string \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\"/dev/null\\\"\",\n        )\n      ),\n      \" representing the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\"Null device\\\"\",\n        ),\n        meta   => (\n          \"https://en.wikipedia.org/wiki/Null_device\",\n        )\n      ),\n      \":\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"\\\$*SPEC.devnull.IO.spurt: \\\"foo bar baz\\\";\\n\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_devnull",
					｢kind｣       => "routine",
					｢name｣       => "devnull",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Spec/Unix#021｣ => {
					｢name｣       => "updir",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#021\")},\n      paragraphs  => (\n        \"method updir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method updir()\\n\\n\",\n      )\n    ),\n    \"Returns a string representing the directory one up from current:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say '..' eq \\\$*SPEC.updir; # OUTPUT: «True␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_updir"
				},
				｢en#type/IO/Spec/Unix#016｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#016\")},\n      paragraphs  => (\n        \"method rootdir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method rootdir(--> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns string \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"'/'\",\n        )\n      ),\n      \", representing root directory.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢name｣       => "rootdir",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_rootdir"
				},
				｢en#type/IO/Spec/Unix#015｣ => {
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#015\")},\n      paragraphs  => (\n        \"method rel2abs\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method rel2abs(Str() \\\$path, \\\$base = \\\$*CWD --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a string representing \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" converted to absolute path, based at\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$base\",\n        )\n      ),\n      \", which defaults to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*CWD\",\n        )\n      ),\n      \". If \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$base\",\n        )\n      ),\n      \" is not an absolute path,\\nit will be made absolute relative to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*CWD\",\n        )\n      ),\n      \", unless \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*CWD\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$base\",\n        )\n      ),\n      \"\\nare the same.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"say \\\$*CWD;                                  # OUTPUT: «\\\"/home/camelia\\\".IO␤»\\n\\nsay IO::Spec::Unix.rel2abs: 'foo';          # OUTPUT: «/home/camelia/foo␤»\\nsay IO::Spec::Unix.rel2abs: './';           # OUTPUT: «/home/camelia␤»\\nsay IO::Spec::Unix.rel2abs: 'foo/../../';   # OUTPUT: «/home/camelia/foo/../..␤»\\nsay IO::Spec::Unix.rel2abs: '/foo/';        # OUTPUT: «/foo␤»\\n\\nsay IO::Spec::Unix.rel2abs: 'foo', 'bar';   # OUTPUT: «/home/camelia/bar/foo␤»\\nsay IO::Spec::Unix.rel2abs: './', '/bar';   # OUTPUT: «/bar␤»\\nsay IO::Spec::Unix.rel2abs: '/foo/', 'bar'; # OUTPUT: «/foo␤»\\n\\nsay IO::Spec::Unix.rel2abs: 'foo/../../', 'bar';\\n# OUTPUT: «/home/camelia/bar/foo/../..␤»\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_rel2abs",
					｢subkind｣    => "method",
					｢name｣       => "rel2abs"
				},
				｢en#type/IO/Spec/Unix#011｣ => {
					｢targ-in-fn｣ => "method_extension",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#011\")},\n      paragraphs  => (\n        \"method extension\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NOTE:\",\n        )\n      ),\n      \" Most users would want to use the higher-level routine\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Path.extension\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Path#method_extension\",\n        )\n      ),\n      \" instead of this\\nlower-level version.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method extension(Str:D \\\$path --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Takes a string representing a base name and returns the characters after\\nthe last dot (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\".\\\"\",\n        )\n      ),\n      \"), or empty string if no dots are present. The\\nroutine makes no attempt to detect path separators and will return\\neverything after the last dot.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"\\\$*SPEC.extension('foo.'      ).raku.say;  # OUTPUT: «\\\"\\\"␤»\\n\\\$*SPEC.extension('foo.txt'   ).raku.say;  # OUTPUT: «\\\"txt\\\"␤»\\n\\\$*SPEC.extension('foo.tar.gz').raku.say;  # OUTPUT: «\\\"gz\\\"␤»\\n\\\$*SPEC.extension('foo'       ).raku.say;  # OUTPUT: «\\\"\\\"␤»\\n\\\$*SPEC.extension('bar.foo/foo').raku.say; # OUTPUT: «\\\"foo/foo\\\"␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢name｣       => "extension"
				},
				｢en#type/IO/Spec/Unix#017｣ => {
					｢name｣       => "split",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#017\")},\n      paragraphs  => (\n        \"method split\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method split(IO::Spec::Unix: Cool:D \\\$path)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Creates an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Path::Parts\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Path::Parts\",\n        )\n      ),\n      \" for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \",\\nwith an empty string as its \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"volume\",\n        )\n      ),\n      \" attribute's value.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"IO::Spec::Unix.split('C:/foo/bar.txt').raku.say;\\n# OUTPUT: «IO::Path::Parts.new(\\\"\\\",\\\"C:/foo\\\",\\\"bar.txt\\\")␤»\\n\\nIO::Spec::Unix.split('/foo/').raku.say;\\n# OUTPUT: «IO::Path::Parts.new(\\\"\\\",\\\"/\\\",\\\"foo\\\")␤»\\n\\nIO::Spec::Unix.split('///').raku.say;\\n# OUTPUT: «IO::Path::Parts.new(\\\"\\\",\\\"/\\\",\\\"/\\\")␤»\\n\\nIO::Spec::Unix.split('./').raku.say;\\n# OUTPUT: «IO::Path::Parts.new(\\\"\\\",\\\".\\\",\\\".\\\")␤»\\n\\nIO::Spec::Unix.split('.').raku.say;\\n# OUTPUT: «IO::Path::Parts.new(\\\"\\\",\\\".\\\",\\\".\\\")␤»\\n\\nIO::Spec::Unix.split('').raku.say;\\n# OUTPUT: «IO::Path::Parts.new(\\\"\\\",\\\"\\\",\\\"\\\")␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Note\",\n        )\n      ),\n      \": Before Rakudo version 2020.06 this method split the given\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" into \\\"volume\\\", \\\"dirname\\\", and \\\"basename\\\" and returned the result\\nas a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"List\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/List\",\n        )\n      ),\n      \" of three \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \"s, in that order.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_split"
				},
				｢en#type/IO/Spec/Unix#013｣ => {
					｢name｣       => "join",
					｢targ-in-fn｣ => "method_join",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Unix#013\")},\n      paragraphs  => (\n        \"method join\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method join (\\\$, Str:D \\\$dir, Str:D \\\$file --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Similar to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"catpath\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/catpath\",\n        )\n      ),\n      \", takes two path fragments and\\nconcatenates them, adding or removing a path separator, if necessary,\\nexcept it will return just \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$file\",\n        )\n      ),\n      \" if both \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$dir\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$file\",\n        )\n      ),\n      \" are\\nstring \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"'/'\",\n        )\n      ),\n      \" or if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$dir\",\n        )\n      ),\n      \" is the string \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"'.'\",\n        )\n      ),\n      \". The first argument is\\nignored (it exists to maintain consistent interface with other\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Spec\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Spec\",\n        )\n      ),\n      \" types for systems that have volumes).\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Unix.join(\\\$, 'foo', 'bar').say; # OUTPUT: «foo/bar␤»\\nIO::Spec::Unix.join(\\\$, '/', '/').say;     # OUTPUT: «/␤»\\nIO::Spec::Unix.join(\\\$, '.', 'foo').say;   # OUTPUT: «foo␤»\\nsay \\\$*SPEC.join(True,\\\".\\\",\\\"/foo\\\");         # OUTPUT: «/foo␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢kind｣       => "routine"
				}
			},
			｢toc｣        => [
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢caption｣    => "Methods",
						｢target｣     => "Methods"
				},
				{
						｢target｣     => "method_abs2rel",
						｢caption｣    => "method abs2rel",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢target｣     => "method_basename",
						｢caption｣    => "method basename",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "method canonpath",
						｢numeration｣ => "",
						｢target｣     => "method_canonpath",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢target｣     => "method_catdir",
						｢caption｣    => "method catdir",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "method catfile",
						｢target｣     => "method_catfile",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_catpath",
						｢caption｣    => "method catpath"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "method_curdir",
						｢level｣      => "2",
						｢caption｣    => "method curdir"
				},
				{
						｢target｣     => "method_curupdir",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method curupdir"
				},
				{
						｢target｣     => "method_devnull",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "method devnull"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method dir-sep",
						｢target｣     => "method_dir-sep"
				},
				{
						｢caption｣    => "method extension",
						｢target｣     => "method_extension",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "method is-absolute",
						｢numeration｣ => "",
						｢target｣     => "method_is-absolute",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method join",
						｢numeration｣ => "",
						｢target｣     => "method_join"
				},
				{
						｢target｣     => "method_path",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "method path"
				},
				{
						｢target｣     => "method_rel2abs",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method rel2abs"
				},
				{
						｢target｣     => "method_rootdir",
						｢caption｣    => "method rootdir",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "method split",
						｢target｣     => "method_split",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_splitdir",
						｢caption｣    => "method splitdir"
				},
				{
						｢target｣     => "method_splitpath",
						｢level｣      => "2",
						｢caption｣    => "method splitpath",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_tmpdir",
						｢caption｣    => "method tmpdir"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "method updir",
						｢target｣     => "method_updir"
				},
				{
						｢caption｣    => "Class relation diagram",
						｢numeration｣ => "",
						｢target｣     => "Class_relation_diagram",
						｢level｣      => 1
				}
			],
			｢modified｣   => "Instant.from-posix(1730070864.910096394)",
			｢type｣       => "primary"
		},
		｢type/IO/ArgFiles｣                  => {
			｢defns｣      => {},
			｢toc｣        => [
				{
						｢caption｣    => "Variables",
						｢numeration｣ => "",
						｢level｣      => 1,
						｢target｣     => "Variables"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "<span class=\"code\">\$*ARGFILES</span>",
						｢target｣     => "\$*ARGFILES",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢target｣     => "Class_relation_diagram",
						｢caption｣    => "Class relation diagram",
						｢level｣      => 1
				}
			],
			｢type｣       => "primary",
			｢config｣     => {
				｢category｣ => "domain-specific",
				｢kind｣     => "Type",
				｢subkind｣  => "class"
			},
			｢xtrk-targs｣ => {},
			｢subtitle｣   => "Iterate over contents of files specified on command line",
			｢index｣      => {},
			｢title｣      => "class IO::ArgFiles",
			｢modified｣   => "Instant.from-posix(1730070864.910096394)"
		},
		｢routine/close｣                     => {
			｢subtitle｣ => "From: en/type/IO/Pipe, en/type/IO/Socket, en/type/IO/Socket/Async, en/type/IO/CatHandle.",
			｢title｣    => "The <b>close</b> routine",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢type｣     => "composite",
			｢modified｣ => "Instant.from-posix(1742118642.311330952)"
		},
		｢routine/connect｣                   => {
			｢modified｣ => "Instant.from-posix(1742118640.833535901)",
			｢config｣   => {
				｢kind｣  => "routine",
				｢index｣ => False
			},
			｢subtitle｣ => "From: en/type/IO/Socket/Async, en/type/IO/Socket/Async.",
			｢type｣     => "composite",
			｢title｣    => "The <b>connect</b> routine"
		},
		｢routine/abs2rel｣                   => {
			｢subtitle｣ => "From: en/type/IO/Spec/Cygwin, en/type/IO/Spec/Unix.",
			｢title｣    => "The <b>abs2rel</b> routine",
			｢config｣   => {
				｢kind｣  => "routine",
				｢index｣ => False
			},
			｢type｣     => "composite",
			｢modified｣ => "Instant.from-posix(1742118641.202029512)"
		},
		｢type/IO/Notification/Change｣       => {
			｢toc｣        => [
				{
						｢caption｣    => "Methods",
						｢target｣     => "Methods",
						｢numeration｣ => "",
						｢level｣      => 1
				},
				{
						｢target｣     => "method_path",
						｢caption｣    => "method path",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method event",
						｢target｣     => "method_event"
				},
				{
						｢caption｣    => "method IO",
						｢numeration｣ => "",
						｢target｣     => "method_IO",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "method gist",
						｢numeration｣ => "",
						｢target｣     => "method_gist",
						｢level｣      => "2"
				},
				{
						｢target｣     => "Class_relation_diagram",
						｢level｣      => 1,
						｢numeration｣ => "",
						｢caption｣    => "Class relation diagram"
				}
			],
			｢config｣     => {
				｢kind｣     => "Type",
				｢subkind｣  => "class",
				｢category｣ => "domain-specific"
			},
			｢modified｣   => "Instant.from-posix(1716570626.140091333)",
			｢title｣      => "class IO::Notification::Change",
			｢index｣      => {},
			｢xtrk-targs｣ => {},
			｢subtitle｣   => "Changes in a file, produced by watch-file",
			｢defns｣      => {
				｢en#type/IO/Notification/Change#004｣ => {
					｢targ-in-fn｣ => "method_gist",
					｢kind｣       => "routine",
					｢name｣       => "gist",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Notification/Change#004\")},\n      paragraphs  => (\n        \"method gist\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi method gist(IO::Notification::Change:D:)\\n\\n\",\n      )\n    ),\n    \"Returns the path and event attributes, separated by semicolon.\\n\\n\",\n  )\n)"
				},
				｢en#type/IO/Notification/Change#001｣ => {
					｢targ-in-fn｣ => "method_path",
					｢kind｣       => "routine",
					｢name｣       => "path",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Notification/Change#001\")},\n      paragraphs  => (\n        \"method path\\n\\n\",\n      )\n    ),\n    \"Returns the path of the file that's being watched.\\n\\n\",\n  )\n)"
				},
				｢en#type/IO/Notification/Change#002｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Notification/Change#002\")},\n      paragraphs  => (\n        \"method event\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the type of event: \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"FileChanged\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"FileRenamed\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_event",
					｢subkind｣    => "method",
					｢name｣       => "event",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Notification/Change#003｣ => {
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_IO",
					｢name｣       => "IO",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Notification/Change#003\")},\n      paragraphs  => (\n        \"method IO\\n\\n\",\n      )\n    ),\n    \"Returns a handle of the file that's being watched.\\n\\n\",\n  )\n)"
				}
			},
			｢type｣       => "primary"
		},
		｢language/operators｣                => {
			｢index｣      => {
				｢Postcircumfix operators｣ => {
					｢sub-index｣ => {
						｢array indexing operator｣  => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-array_indexing_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "postcircumfix <span class=\"code\">[ ]</span>"
								}
							]
						},
						｢hash subscript operator｣  => {
							｢refs｣      => [
								{
										｢place｣         => "postcircumfix <span class=\"code\">\{ }</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-hash_indexing_operator"
								}
							],
							｢sub-index｣ => {}
						},
						｢hash indexing operator｣   => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "postcircumfix <span class=\"code\">\{ }</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-hash_indexing_operator"
								}
							]
						},
						｢array subscript operator｣ => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-array_indexing_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "postcircumfix <span class=\"code\">[ ]</span>"
								}
							]
						}
					},
					｢refs｣      => []
				},
				｢Listop operators｣        => {
					｢refs｣      => [],
					｢sub-index｣ => {
						｢Fatal stub operator｣ => {
							｢refs｣      => [
								{
										｢place｣         => "listop <span class=\"code\">...</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢stub operator｣       => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">::=</span>",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						}
					}
				},
				｢Syntax｣                  => {
					｢sub-index｣ => {
						｢methodop .^｣          => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "methodop <span class=\"code\">.=</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢method call｣          => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "methodop <span class=\"code\">.</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢methodop .*｣          => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "methodop <span class=\"code\">.+</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢methodop .&｣          => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "methodop <span class=\"code\">.</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢.[ ]｣                 => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "methodop <span class=\"code\">».</span> / methodop <span class=\"code\">\&gt;\&gt;.</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢methodop .+｣          => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "methodop <span class=\"code\">.?</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢methodop .?｣          => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "methodop <span class=\"code\">.^</span>"
								}
							]
						},
						｢methodop ».｣          => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "methodop <span class=\"code\">.*</span>"
								}
							]
						},
						｢methodop >>.｣         => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "methodop <span class=\"code\">.*</span>"
								}
							]
						},
						｢.{ }｣                 => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "methodop <span class=\"code\">».</span> / methodop <span class=\"code\">\&gt;\&gt;.</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢.( )｣                 => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "methodop <span class=\"code\">».</span> / methodop <span class=\"code\">\&gt;\&gt;.</span>",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢mutating method call｣ => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "methodop <span class=\"code\">.=</span>",
										｢target｣        => "index-entry-mutating_method_call"
								}
							]
						},
						｢list =｣               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "List prefix precedence",
										｢target｣        => "index-entry-_0"
								}
							]
						}
					},
					｢refs｣      => []
				},
				｢Circumfix operators｣     => {
					｢refs｣      => [],
					｢sub-index｣ => {
						｢Array constructor｣ => {
							｢refs｣      => [
								{
										｢place｣         => "circumfix <span class=\"code\">[ ]</span>",
										｢target｣        => "index-entry-Array_constructor",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						}
					}
				},
				｢Infix operators｣         => {
					｢refs｣      => [],
					｢sub-index｣ => {
						｢Multiplication operator｣                   => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Multiplication_operator",
										｢place｣         => "infix <span class=\"code\">*</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢Not a subset of operator｣                  => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Not_a_subset_of_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">⊄</span>"
								}
							]
						},
						｢pair constructor｣                          => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "infix <span class=\"code\">=\&gt;</span>",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢Numeric less than operator｣                => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">\&lt;</span>",
										｢target｣        => "index-entry-Numeric_less_than_operator"
								}
							],
							｢sub-index｣ => {}
						},
						｢Numeric equality operator｣                 => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Numeric_equality_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">==</span>, infix <span class=\"code\">⩵</span>"
								}
							]
						},
						｢integer right bit shift operator｣          => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "infix <span class=\"code\">+\&gt;</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢greatest common divisor operator｣          => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "infix <span class=\"code\">gcd</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢smartmatch operator｣                       => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">=:=</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢Numeric greater than or equal to operator｣ => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Numeric_greater_than_or_equal_to_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">\&gt;=</span>, infix <span class=\"code\">≥</span>"
								}
							]
						},
						｢Superset of or equal to operator｣          => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">(\&gt;=)</span>, infix <span class=\"code\">⊇</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Superset_of_or_equal_to_operator"
								}
							]
						},
						｢…｣                                         => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "infix_...",
										｢place｣         => "infix <span class=\"code\">...</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢Integer bitwise OR operator｣               => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">+|</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Integer_bitwise_OR_operator"
								}
							],
							｢sub-index｣ => {}
						},
						｢^…｣                                        => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "infix_...",
										｢place｣         => "infix <span class=\"code\">...</span>",
										｢is-in-heading｣ => True
								}
							]
						},
						｢Not a superset of nor equal to operator｣   => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Not_a_superset_of_nor_equal_to_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">⊉</span>"
								}
							]
						},
						｢//｣                                        => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">//</span>",
										｢target｣        => "index-entry-infix_//"
								}
							]
						},
						｢Division operator｣                         => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">/</span>",
										｢target｣        => "index-entry-Division_operator"
								}
							]
						},
						｢Membership operator (elem)｣                => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Membership_operator",
										｢place｣         => "infix (elem), infix ∈"
								}
							]
						},
						｢binding operator｣                          => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">:=</span>",
										｢target｣        => "index-entry-Binding_operator",
										｢is-in-heading｣ => False
								}
							]
						},
						｢String less than operator｣                 => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">lt</span>",
										｢target｣        => "index-entry-String_less_than_operator"
								}
							],
							｢sub-index｣ => {}
						},
						｢o｣                                         => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">o</span>, infix <span class=\"code\">∘</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢equivalence operator｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-equivalence_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">eqv</span>"
								}
							]
						},
						｢Zip operator｣                              => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">Z</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Zip_operator"
								}
							]
						},
						｢orelse｣                                    => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "infix <span class=\"code\">or</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢Integer modulo operator｣                   => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Integer_modulo_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">mod</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢String repetition operator｣                => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">x</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-String_repetition_operator"
								}
							]
						},
						｢integer left bit shift operator｣           => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "infix <span class=\"code\">+\&lt;</span>"
								}
							]
						},
						｢Baggy addition operator｣                   => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">(+)</span>, infix <span class=\"code\">⊎</span>",
										｢target｣        => "index-entry-Baggy_addition_operator",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢Set inequality operator｣                   => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">≢</span>",
										｢target｣        => "index-entry-Set_inequality_operator"
								}
							]
						},
						｢Subset of operator｣                        => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Subset_of_operator",
										｢place｣         => "infix <span class=\"code\">(\&lt;)</span>, infix <span class=\"code\">⊂</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢Generic three-way comparator｣              => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Generic,_\&quot;smart\&quot;_three-way_comparator",
										｢place｣         => "infix <span class=\"code\">cmp</span>"
								}
							]
						},
						｢String inequality operator｣                => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-String_inequality_operator",
										｢place｣         => "infix <span class=\"code\">ne</span>"
								}
							]
						},
						｢function composition operator｣             => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">o</span>, infix <span class=\"code\">∘</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-function_composition_operator"
								}
							],
							｢sub-index｣ => {}
						},
						｢Numeric less than or equal to operator｣    => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Numeric_less_than_or_equal_to_operator",
										｢place｣         => "infix <span class=\"code\">\&lt;=</span>, infix <span class=\"code\">≤</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢Intersection operator｣                     => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Intersection_operator",
										｢place｣         => "infix <span class=\"code\">(\&amp;)</span>, infix <span class=\"code\">∩</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢...｣                                       => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "infix <span class=\"code\">...</span>",
										｢target｣        => "infix_..."
								}
							],
							｢sub-index｣ => {}
						},
						｢Boolean logical XOR operator｣              => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Boolean_logical_XOR_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">?^</span>"
								}
							]
						},
						｢String greater than or equal to operator｣  => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">ge</span>",
										｢target｣        => "index-entry-String_greater_than_or_equal_to_operator",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢String three-way comparator｣               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">leg</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-String_three-way_comparator"
								}
							]
						},
						｢feed｣                                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-feed",
										｢place｣         => "infix <span class=\"code\">==\&gt;</span>"
								}
							]
						},
						｢List repetition operator｣                  => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-List_repetition_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">xx</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢String greater than operator｣              => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">gt</span>",
										｢target｣        => "index-entry-String_greater_than_operator"
								}
							]
						},
						｢Boolean logical AND operator｣              => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Boolean_logical_AND_operator",
										｢place｣         => "infix <span class=\"code\">?\&amp;</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢sequence operator｣                         => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">...</span>",
										｢target｣        => "index-entry-sequence_operator"
								}
							]
						},
						｢Left-open range operator｣                  => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">^..</span>",
										｢target｣        => "index-entry-Left-open_range_operator",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢Short-circuit exclusive-or｣                => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Short-circuit_exclusive-or",
										｢place｣         => "infix <span class=\"code\">^^</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢Numeric greater than operator｣             => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Numeric_greater_than_operator",
										｢place｣         => "infix <span class=\"code\">\&gt;</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢All junction operator｣                     => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">\&amp;</span>",
										｢target｣        => "index-entry-All_junction_operator",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢Integer division operator｣                 => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Integer_division_operator",
										｢place｣         => "infix <span class=\"code\">div</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢Boolean logical OR operator｣               => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Boolean_logical_OR_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">?|</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢Subset of or equal to operator｣            => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Subset_of_or_equal_to_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">(\&lt;=)</span>, infix <span class=\"code\">⊆</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢Not a superset of operator｣                => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">⊅</span>",
										｢target｣        => "index-entry-Not_a_superset_of_operator",
										｢is-in-heading｣ => False
								}
							]
						},
						｢String equality operator｣                  => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-String_equality_operator",
										｢place｣         => "infix <span class=\"code\">eq</span>",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢Read-only binding operator｣                => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">::=</span>",
										｢target｣        => "index-entry-Read-only_binding_operator"
								}
							]
						},
						｢^...｣                                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "infix <span class=\"code\">...</span>",
										｢target｣        => "infix_..."
								}
							]
						},
						｢Numeric three-way comparator｣              => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Numeric_three-way_comparator",
										｢place｣         => "infix <span class=\"code\">\&lt;=\&gt;</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢List assignment operator｣                  => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "List prefix precedence"
								}
							]
						},
						｢Not a subset of nor equal to operator｣     => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">⊈</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Not_a_subset_of_nor_equal_to_operator"
								}
							],
							｢sub-index｣ => {}
						},
						｢string concatenation operator｣             => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-string_concatenation_operator",
										｢place｣         => "infix <span class=\"code\">~</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢Addition operator｣                         => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Addition_operator",
										｢place｣         => "infix <span class=\"code\">+</span>"
								}
							]
						},
						｢Set equality operator｣                     => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Set_equality_operator",
										｢place｣         => "infix <span class=\"code\">(==)</span>, infix <span class=\"code\">≡</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢spaceship operator｣                        => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">\&lt;=\&gt;</span>",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢Integer bitwise XOR operator｣              => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">+^</span>",
										｢target｣        => "index-entry-Integer_bitwise_XOR_operator"
								}
							],
							｢sub-index｣ => {}
						},
						｢notandthen｣                                => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">notandthen</span>",
										｢is-in-heading｣ => True,
										｢target｣        => "infix_notandthen"
								}
							],
							｢sub-index｣ => {}
						},
						｢Numeric inequality operator｣               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">!=</span>, infix <span class=\"code\">≠</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Numeric_inequality_operator"
								}
							]
						},
						｢Symmetric set difference operator｣         => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Symmetric_set_difference_operator",
										｢place｣         => "infix <span class=\"code\">(^)</span>, infix <span class=\"code\">⊖</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢…^｣                                        => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">...</span>",
										｢is-in-heading｣ => True,
										｢target｣        => "infix_..."
								}
							]
						},
						｢≅｣                                         => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">≅</span>",
										｢target｣        => "index-entry-≅"
								}
							]
						},
						｢Subtraction operator｣                      => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">-</span>",
										｢target｣        => "index-entry-Subtraction_operator"
								}
							],
							｢sub-index｣ => {}
						},
						｢Superset of operator｣                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Superset_of_operator",
										｢place｣         => "infix <span class=\"code\">(\&gt;)</span>, infix <span class=\"code\">⊃</span>"
								}
							]
						},
						｢least common multiple operator｣            => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">lcm</span>",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							]
						},
						｢Baggy multiplication operator｣             => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">(.)</span>, infix <span class=\"code\">⊍</span>",
										｢target｣        => "index-entry-Baggy_multiplication_operator"
								}
							]
						},
						｢flipflop｣                                  => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">?? !!</span>",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							]
						},
						｢Non-membership operator (cont)｣            => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Non-membership_operator_0",
										｢place｣         => "infix <span class=\"code\">∌</span>",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢Container identity operator｣               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">=:=</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Container_identity_operator"
								}
							]
						},
						｢Range operator｣                            => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">..</span>",
										｢target｣        => "index-entry-Range_operator"
								}
							]
						},
						｢Set difference operator｣                   => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">(-)</span>, infix <span class=\"code\">∖</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Set_difference_operator"
								}
							]
						},
						｢leftward feed｣                             => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-leftward_feed",
										｢place｣         => "infix <span class=\"code\">\&lt;==</span>",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢Modulo operator｣                           => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">\%</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Modulo_operator"
								}
							],
							｢sub-index｣ => {}
						},
						｢Right-open range operator｣                 => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">..^</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Right-open_range_operator"
								}
							],
							｢sub-index｣ => {}
						},
						｢Value identity operator｣                   => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Value_identity_operator",
										｢place｣         => "infix <span class=\"code\">⩶</span>"
								}
							]
						},
						｢Union operator｣                            => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Union_operator",
										｢place｣         => "infix <span class=\"code\">(|)</span>, infix <span class=\"code\">∪</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢Membership operator (cont)｣                => {
							｢refs｣      => [
								{
										｢place｣         => "infix (cont), infix ∋",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Membership_operator_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢Non-membership operator (elem)｣            => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Non-membership_operator",
										｢place｣         => "infix <span class=\"code\">∉</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢...^｣                                      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "infix_...",
										｢is-in-heading｣ => True,
										｢place｣         => "infix <span class=\"code\">...</span>"
								}
							]
						},
						｢One junction operator｣                     => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-One_junction_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">^</span>"
								}
							]
						},
						｢^...^｣                                     => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "infix_...",
										｢is-in-heading｣ => True,
										｢place｣         => "infix <span class=\"code\">...</span>"
								}
							]
						},
						｢Divisibility operator｣                     => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Divisibility_operator",
										｢place｣         => "infix <span class=\"code\">\%\%</span>",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢Numeric bitwise AND operator｣              => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "infix <span class=\"code\">+\&amp;</span>"
								}
							]
						},
						｢X｣                                         => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">Z</span>",
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢Any junction operator｣                     => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">|</span>",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢defined-or operator｣                       => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">//</span>",
										｢target｣        => "index-entry-defined-or_operator"
								}
							]
						},
						｢cross product operator｣                    => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">Z</span>"
								}
							]
						},
						｢String less than or equal to operator｣     => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-String_less_than_or_equal_to_operator",
										｢place｣         => "infix <span class=\"code\">le</span>",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢^…^｣                                       => {
							｢refs｣      => [
								{
										｢target｣        => "infix_...",
										｢place｣         => "infix <span class=\"code\">...</span>",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢Open range operator｣                       => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Open_range_operator",
										｢place｣         => "infix <span class=\"code\">^..^</span>",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						}
					}
				},
				｢Metaoperators｣           => {
					｢refs｣      => [],
					｢sub-index｣ => {
						｢S｣                                        => {
							｢refs｣      => [
								{
										｢target｣        => "Sequential_operators",
										｢place｣         => "Sequential operators",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢[] (reduction metaoperators)｣             => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "Hyper operators"
								}
							]
						},
						｢X (cross metaoperator)｣                   => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢place｣         => "Cross metaoperators",
										｢target｣        => "Cross_metaoperators"
								}
							]
						},
						｢! (negation metaoperator)｣                => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "Negated relational operators",
										｢is-in-heading｣ => True,
										｢target｣        => "Negated_relational_operators"
								}
							]
						},
						｢R｣                                        => {
							｢refs｣      => [
								{
										｢place｣         => "Reversed operators",
										｢is-in-heading｣ => True,
										｢target｣        => "Reversed_operators"
								}
							],
							｢sub-index｣ => {}
						},
						｢[\] (triangular reduction metaoperators)｣ => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "Reduction metaoperators"
								}
							],
							｢sub-index｣ => {}
						},
						｢reverse metaoperator｣                     => {
							｢refs｣      => [
								{
										｢place｣         => "Reversed operators",
										｢is-in-heading｣ => True,
										｢target｣        => "Reversed_operators"
								}
							],
							｢sub-index｣ => {}
						},
						｢[+] (reduction metaoperators)｣            => {
							｢refs｣      => [
								{
										｢place｣         => "Hyper operators",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢Z (zip metaoperator)｣                     => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "Zip_metaoperator",
										｢place｣         => "Zip metaoperator"
								}
							]
						},
						｢sequential metaoperator｣                  => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "Sequential_operators",
										｢place｣         => "Sequential operators",
										｢is-in-heading｣ => True
								}
							]
						}
					}
				},
				｢Terms｣                   => {
					｢refs｣      => [],
					｢sub-index｣ => {
						｢hash constructor｣  => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "term <span class=\"code\">\{ }</span>"
								}
							]
						},
						｢block constructor｣ => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "term <span class=\"code\">\{ }</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢grouping operator｣ => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-grouping_operator",
										｢place｣         => "term <span class=\"code\">( )</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢quote-words｣       => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-quote-words",
										｢is-in-heading｣ => False,
										｢place｣         => "term <span class=\"code\">\&lt; \&gt;</span>"
								}
							]
						},
						｢qw｣                => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-quote-words",
										｢is-in-heading｣ => False,
										｢place｣         => "term <span class=\"code\">\&lt; \&gt;</span>"
								}
							]
						}
					}
				},
				｢Operators｣               => {
					｢refs｣      => [],
					｢sub-index｣ => {
						｢s/// in-place substitution｣            => {
							｢refs｣      => [
								{
										｢place｣         => "Substitution operators",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢»｣                                     => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "Hyper operators",
										｢target｣        => "Hyper_operators",
										｢is-in-heading｣ => True
								}
							]
						},
						｢Boolean context operator｣              => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Boolean_context_operator",
										｢place｣         => "prefix <span class=\"code\">?</span>",
										｢is-in-heading｣ => False
								},
								{
										｢target｣        => "index-entry-Boolean_context_operator_0",
										｢is-in-heading｣ => False,
										｢place｣         => "prefix <span class=\"code\">//</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢<<｣                                    => {
							｢refs｣      => [
								{
										｢place｣         => "Hyper operators",
										｢target｣        => "Hyper_operators",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢«｣                                     => {
							｢refs｣      => [
								{
										｢place｣         => "Hyper operators",
										｢target｣        => "Hyper_operators",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢»=«｣                                   => {
							｢refs｣      => [
								{
										｢place｣         => "Hyper operators",
										｢target｣        => "Hyper_operators",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢Numeric context operator｣              => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Numeric_context_operator",
										｢place｣         => "prefix <span class=\"code\">+</span>"
								}
							]
						},
						｢prefix decrement operator｣             => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0",
										｢place｣         => "prefix <span class=\"code\">++</span>"
								}
							]
						},
						｢ternary｣                               => {
							｢refs｣      => [
								{
										｢place｣         => "Conditional operator precedence",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢postfix increment operator｣            => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "prefix <span class=\"code\">--</span>",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							]
						},
						｢TR/// non-destructive transliteration｣ => {
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">tr///</span> in-place transliteration",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢and｣                                   => {
							｢refs｣      => [
								{
										｢place｣         => "infix <span class=\"code\">and</span>",
										｢target｣        => "infix_and",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢Safe call operator｣                    => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Safe_call_operator",
										｢is-in-heading｣ => False,
										｢place｣         => "methodop <span class=\"code\">.?</span>"
								}
							]
						},
						｢andthen｣                               => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "infix_andthen",
										｢place｣         => "infix <span class=\"code\">andthen</span>",
										｢is-in-heading｣ => True
								}
							]
						},
						｢>>｣                                    => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "Hyper operators",
										｢target｣        => "Hyper_operators",
										｢is-in-heading｣ => True
								}
							]
						},
						｢S/// non-destructive substitution｣     => {
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">s///</span> in-place substitution",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						},
						｢prefix increment operator｣             => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "Autoincrement precedence"
								}
							],
							｢sub-index｣ => {}
						},
						｢conditional｣                           => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "Conditional operator precedence",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢item =｣                                => {
							｢refs｣      => [
								{
										｢place｣         => "Item assignment precedence",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢exponentiation operator｣               => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "infix <span class=\"code\">**</span>",
										｢target｣        => "index-entry-exponentiation_operator"
								}
							],
							｢sub-index｣ => {}
						},
						｢postfix decrement operator｣            => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "postfix <span class=\"code\">++</span>",
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢Negated Boolean context operator｣      => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "prefix <span class=\"code\">!</span>",
										｢target｣        => "index-entry-Negated_Boolean_context_operator"
								}
							],
							｢sub-index｣ => {}
						},
						｢Admonitory stub operator｣              => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "listop <span class=\"code\">!!!</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢«=»｣                                   => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "Hyper operators",
										｢target｣        => "Hyper_operators",
										｢is-in-heading｣ => True
								}
							]
						},
						｢call operator｣                         => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-call_operator",
										｢place｣         => "postcircumfix <span class=\"code\">( )</span>",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢tr/// in-place transliteration｣        => {
							｢refs｣      => [
								{
										｢place｣         => "<span class=\"code\">S///</span> non-destructive substitution",
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-_0"
								}
							],
							｢sub-index｣ => {}
						}
					}
				},
				｢Language｣                => {
					｢refs｣      => [],
					｢sub-index｣ => {
						｢metamethod call｣             => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "methodop <span class=\"code\">.^</span>",
										｢target｣        => "index-entry-metamethod_call"
								}
							]
						},
						｢postcircumfix operator｣      => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "Operator classification",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							]
						},
						｢method operators｣            => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False,
										｢place｣         => "Operator classification"
								}
							]
						},
						｢infix operator｣              => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "Operator classification",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							]
						},
						｢hyper method call operator｣  => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "methodop <span class=\"code\">».</span> / methodop <span class=\"code\">\&gt;\&gt;.</span>",
										｢target｣        => "index-entry-hyper_method_call_operator",
										｢is-in-heading｣ => False
								}
							]
						},
						｢postfix operator call｣       => {
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "methodop <span class=\"code\">.postfix</span> / <span class=\"code\">.postcircumfix</span>",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢prefix operator｣             => {
							｢refs｣      => [
								{
										｢place｣         => "Operator classification",
										｢target｣        => "index-entry-",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢circumfix operator｣          => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "Operator classification",
										｢target｣        => "index-entry-_0"
								}
							]
						},
						｢postfix operator｣            => {
							｢refs｣      => [
								{
										｢place｣         => "Operator classification",
										｢target｣        => "index-entry-_0",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢class-qualified method call｣ => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢place｣         => "methodop <span class=\"code\">.::</span>",
										｢target｣        => "index-entry-class-qualified_method_call"
								}
							],
							｢sub-index｣ => {}
						}
					}
				},
				｢Postfix operators｣       => {
					｢sub-index｣ => {
						｢postfix ++｣ => {
							｢refs｣      => [
								{
										｢target｣        => "postfix_++",
										｢is-in-heading｣ => True,
										｢place｣         => "postfix <span class=\"code\">++</span>"
								}
							],
							｢sub-index｣ => {}
						},
						｢postfix --｣ => {
							｢refs｣      => [
								{
										｢is-in-heading｣ => True,
										｢target｣        => "postfix_--",
										｢place｣         => "postfix <span class=\"code\">--</span>"
								}
							],
							｢sub-index｣ => {}
						}
					},
					｢refs｣      => []
				},
				｢Prefix operators｣        => {
					｢sub-index｣ => {
						｢prefix --｣                         => {
							｢refs｣      => [
								{
										｢place｣         => "prefix <span class=\"code\">--</span>",
										｢is-in-heading｣ => True,
										｢target｣        => "prefix_--"
								}
							],
							｢sub-index｣ => {}
						},
						｢Negative numeric context operator｣ => {
							｢refs｣      => [
								{
										｢place｣         => "prefix <span class=\"code\">-</span>",
										｢target｣        => "index-entry-Negative_numeric_context_operator",
										｢is-in-heading｣ => False
								}
							],
							｢sub-index｣ => {}
						},
						｢prefix ++｣                         => {
							｢refs｣      => [
								{
										｢place｣         => "prefix <span class=\"code\">++</span>",
										｢target｣        => "prefix_++",
										｢is-in-heading｣ => True
								}
							],
							｢sub-index｣ => {}
						},
						｢upto operator｣                     => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-_0",
										｢place｣         => "prefix <span class=\"code\">^</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢String context operator｣           => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢place｣         => "prefix <span class=\"code\">~</span>",
										｢target｣        => "index-entry-String_context_operator",
										｢is-in-heading｣ => False
								}
							]
						},
						｢Boolean bitwise negation operator｣ => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢target｣        => "index-entry-Boolean_bitwise_negation_operator",
										｢place｣         => "prefix <span class=\"code\">?^</span>",
										｢is-in-heading｣ => False
								}
							]
						},
						｢Integer bitwise negation operator｣ => {
							｢sub-index｣ => {},
							｢refs｣      => [
								{
										｢is-in-heading｣ => False,
										｢target｣        => "index-entry-Integer_bitwise_negation_operator",
										｢place｣         => "prefix <span class=\"code\">+^</span>"
								}
							]
						}
					},
					｢refs｣      => []
				}
			},
			｢toc｣        => [
				{
						｢caption｣    => "Operator precedence",
						｢level｣      => 1,
						｢target｣     => "Operator_precedence",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "Operator associativity",
						｢target｣     => "Operator_associativity",
						｢level｣      => 1
				},
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢caption｣    => "Operator classification",
						｢target｣     => "Operator_classification"
				},
				{
						｢caption｣    => "Substitution operators",
						｢level｣      => 1,
						｢target｣     => "Substitution_operators",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "s///_in-place_substitution",
						｢caption｣    => "<span class=\"code\">s///</span> in-place substitution",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "<span class=\"code\">S///</span> non-destructive substitution",
						｢target｣     => "S///_non-destructive_substitution",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "<span class=\"code\">tr///</span> in-place transliteration",
						｢target｣     => "tr///_in-place_transliteration",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "<span class=\"code\">TR///</span> non-destructive transliteration",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "TR///_non-destructive_transliteration"
				},
				{
						｢target｣     => "Assignment_operators",
						｢caption｣    => "Assignment operators",
						｢numeration｣ => "",
						｢level｣      => 1
				},
				{
						｢target｣     => "Metaoperators",
						｢level｣      => 1,
						｢caption｣    => "Metaoperators",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "Negated relational operators",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "Negated_relational_operators"
				},
				{
						｢level｣      => "2",
						｢target｣     => "Reversed_operators",
						｢caption｣    => "Reversed operators",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "Hyper operators",
						｢level｣      => "2",
						｢target｣     => "Hyper_operators"
				},
				{
						｢target｣     => "Reduction_metaoperators",
						｢caption｣    => "Reduction metaoperators",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "Cross metaoperators",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "Cross_metaoperators"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "Zip_metaoperator",
						｢caption｣    => "Zip metaoperator",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "Sequential_operators",
						｢caption｣    => "Sequential operators",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢target｣     => "Nesting_of_metaoperators",
						｢caption｣    => "Nesting of metaoperators",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢caption｣    => "Term precedence",
						｢target｣     => "Term_precedence"
				},
				{
						｢caption｣    => "term <span class=\"code\">\&lt; \&gt;</span>",
						｢target｣     => "term_\&lt;_\&gt;",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "2",
						｢caption｣    => "term <span class=\"code\">( )</span>",
						｢target｣     => "term_(_)",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "term_\{_}",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "term <span class=\"code\">\{ }</span>"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "circumfix <span class=\"code\">[ ]</span>",
						｢target｣     => "circumfix_[_]"
				},
				{
						｢level｣      => 1,
						｢caption｣    => "Terms",
						｢target｣     => "Terms",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢target｣     => "Method_postfix_precedence",
						｢level｣      => 1,
						｢caption｣    => "Method postfix precedence"
				},
				{
						｢target｣     => "postcircumfix_[_]",
						｢caption｣    => "postcircumfix <span class=\"code\">[ ]</span>",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "postcircumfix <span class=\"code\">\{ }</span>",
						｢target｣     => "postcircumfix_\{_}",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "postcircumfix <span class=\"code\">\&lt;\&gt;</span>",
						｢target｣     => "postcircumfix_\&lt;\&gt;"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "postcircumfix <span class=\"code\">\&lt; \&gt;</span>",
						｢target｣     => "postcircumfix_\&lt;_\&gt;",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢target｣     => "postcircumfix_«_»",
						｢numeration｣ => "",
						｢caption｣    => "postcircumfix <span class=\"code\">« »</span>"
				},
				{
						｢caption｣    => "postcircumfix <span class=\"code\">( )</span>",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "postcircumfix_(_)"
				},
				{
						｢target｣     => "methodop_.",
						｢caption｣    => "methodop <span class=\"code\">.</span>",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "methodop <span class=\"code\">.\&amp;</span>",
						｢target｣     => "methodop_.\&amp;"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "methodop_.=",
						｢caption｣    => "methodop <span class=\"code\">.=</span>"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "methodop <span class=\"code\">.^</span>",
						｢level｣      => "2",
						｢target｣     => "methodop_.^"
				},
				{
						｢target｣     => "methodop_.?",
						｢level｣      => "2",
						｢caption｣    => "methodop <span class=\"code\">.?</span>",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "methodop <span class=\"code\">.+</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "methodop_.+"
				},
				{
						｢level｣      => "2",
						｢target｣     => "methodop_.*",
						｢numeration｣ => "",
						｢caption｣    => "methodop <span class=\"code\">.*</span>"
				},
				{
						｢target｣     => "methodop_».__/_methodop_\&gt;\&gt;.",
						｢numeration｣ => "",
						｢caption｣    => "methodop <span class=\"code\">».</span> / methodop <span class=\"code\">\&gt;\&gt;.</span>",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "methodop_.postfix_/_.postcircumfix",
						｢caption｣    => "methodop <span class=\"code\">.postfix</span> / <span class=\"code\">.postcircumfix</span>",
						｢level｣      => "2"
				},
				{
						｢target｣     => "methodop_.:\&lt;prefix_operator\&gt;",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "methodop <span class=\"code\">.:\&lt;prefix operator\&gt;</span>"
				},
				{
						｢caption｣    => "methodop <span class=\"code\">.::</span>",
						｢numeration｣ => "",
						｢target｣     => "methodop_.::",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "postfix <span class=\"code\">,=</span>",
						｢level｣      => "2",
						｢target｣     => "postfix_,="
				},
				{
						｢level｣      => 1,
						｢numeration｣ => "",
						｢caption｣    => "Autoincrement precedence",
						｢target｣     => "Autoincrement_precedence"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "prefix_++",
						｢caption｣    => "prefix <span class=\"code\">++</span>"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "prefix_--",
						｢level｣      => "2",
						｢caption｣    => "prefix <span class=\"code\">--</span>"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "postfix <span class=\"code\">++</span>",
						｢target｣     => "postfix_++"
				},
				{
						｢target｣     => "postfix_--",
						｢level｣      => "2",
						｢caption｣    => "postfix <span class=\"code\">--</span>",
						｢numeration｣ => ""
				},
				{
						｢level｣      => 1,
						｢target｣     => "Exponentiation_precedence",
						｢caption｣    => "Exponentiation precedence",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "infix <span class=\"code\">**</span>",
						｢level｣      => "2",
						｢target｣     => "infix_**",
						｢numeration｣ => ""
				},
				{
						｢level｣      => 1,
						｢caption｣    => "Symbolic unary precedence",
						｢target｣     => "Symbolic_unary_precedence",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "prefix_?",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "prefix <span class=\"code\">?</span>"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "prefix <span class=\"code\">!</span>",
						｢level｣      => "2",
						｢target｣     => "prefix_!"
				},
				{
						｢level｣      => "2",
						｢target｣     => "prefix_//",
						｢numeration｣ => "",
						｢caption｣    => "prefix <span class=\"code\">//</span>"
				},
				{
						｢target｣     => "prefix_+",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "prefix <span class=\"code\">+</span>"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "prefix_-",
						｢caption｣    => "prefix <span class=\"code\">-</span>"
				},
				{
						｢target｣     => "prefix_~",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "prefix <span class=\"code\">~</span>"
				},
				{
						｢target｣     => "prefix_|",
						｢caption｣    => "prefix <span class=\"code\">|</span>",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "prefix <span class=\"code\">+^</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "prefix_+^"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "prefix <span class=\"code\">~^</span>",
						｢target｣     => "prefix_~^"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "prefix_?^",
						｢caption｣    => "prefix <span class=\"code\">?^</span>"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "prefix_^",
						｢level｣      => "2",
						｢caption｣    => "prefix <span class=\"code\">^</span>"
				},
				{
						｢target｣     => "Dotty_infix_precedence",
						｢caption｣    => "Dotty infix precedence",
						｢numeration｣ => "",
						｢level｣      => 1
				},
				{
						｢caption｣    => "infix <span class=\"code\">.=</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_.="
				},
				{
						｢caption｣    => "infix <span class=\"code\">.</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_.",
						｢level｣      => "2"
				},
				{
						｢target｣     => "Multiplicative_precedence",
						｢numeration｣ => "",
						｢caption｣    => "Multiplicative precedence",
						｢level｣      => 1
				},
				{
						｢target｣     => "infix_*",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">*</span>",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "infix_/",
						｢caption｣    => "infix <span class=\"code\">/</span>",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢target｣     => "infix_div",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">div</span>",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "infix <span class=\"code\">\%</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_\%"
				},
				{
						｢target｣     => "infix_\%\%",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">\%\%</span>",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">mod</span>",
						｢target｣     => "infix_mod",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_+\&amp;",
						｢caption｣    => "infix <span class=\"code\">+\&amp;</span>"
				},
				{
						｢target｣     => "infix_+\&lt;",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">+\&lt;</span>",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">+\&gt;</span>",
						｢level｣      => "2",
						｢target｣     => "infix_+\&gt;",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "infix <span class=\"code\">~\&amp;</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_~\&amp;",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">~\&lt;</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_~\&lt;"
				},
				{
						｢caption｣    => "infix <span class=\"code\">~\&gt;</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_~\&gt;"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_?\&amp;",
						｢caption｣    => "infix <span class=\"code\">?\&amp;</span>"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">gcd</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_gcd"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "infix_lcm",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">lcm</span>"
				},
				{
						｢caption｣    => "Additive precedence",
						｢level｣      => 1,
						｢numeration｣ => "",
						｢target｣     => "Additive_precedence"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">+</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_+"
				},
				{
						｢caption｣    => "infix <span class=\"code\">-</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_-"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">+|</span>",
						｢target｣     => "infix_+|"
				},
				{
						｢caption｣    => "infix <span class=\"code\">+^</span>",
						｢level｣      => "2",
						｢target｣     => "infix_+^",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "infix_~|",
						｢caption｣    => "infix <span class=\"code\">~|</span>"
				},
				{
						｢caption｣    => "infix <span class=\"code\">~^</span>",
						｢target｣     => "infix_~^",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">?^</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_?^",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">?|</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_?|"
				},
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢target｣     => "Replication_precedence",
						｢caption｣    => "Replication precedence"
				},
				{
						｢target｣     => "infix_x",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">x</span>"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "infix_xx",
						｢caption｣    => "infix <span class=\"code\">xx</span>"
				},
				{
						｢level｣      => 1,
						｢target｣     => "Concatenation",
						｢numeration｣ => "",
						｢caption｣    => "Concatenation"
				},
				{
						｢caption｣    => "infix <span class=\"code\">~</span>",
						｢target｣     => "infix_~",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢target｣     => "infix_o,_infix_∘",
						｢caption｣    => "infix <span class=\"code\">o</span>, infix <span class=\"code\">∘</span>",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢caption｣    => "Junctive AND (all) precedence",
						｢target｣     => "Junctive_AND_(all)_precedence"
				},
				{
						｢caption｣    => "infix <span class=\"code\">\&amp;</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_\&amp;"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">(\&amp;)</span>, infix <span class=\"code\">∩</span>",
						｢target｣     => "infix_(\&amp;),_infix_∩",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">(.)</span>, infix <span class=\"code\">⊍</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_(.),_infix_⊍",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "Junctive_OR_(any)_precedence",
						｢caption｣    => "Junctive OR (any) precedence",
						｢level｣      => 1
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_|",
						｢caption｣    => "infix <span class=\"code\">|</span>"
				},
				{
						｢target｣     => "infix_(|),_infix_∪",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">(|)</span>, infix <span class=\"code\">∪</span>",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "2",
						｢target｣     => "infix_(+),_infix_⊎",
						｢caption｣    => "infix <span class=\"code\">(+)</span>, infix <span class=\"code\">⊎</span>",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "infix_(-),_infix_∖",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">(-)</span>, infix <span class=\"code\">∖</span>",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "infix_^",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">^</span>"
				},
				{
						｢caption｣    => "infix <span class=\"code\">(^)</span>, infix <span class=\"code\">⊖</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_(^),_infix_⊖",
						｢level｣      => "2"
				},
				{
						｢level｣      => 1,
						｢target｣     => "Named_unary_precedence",
						｢numeration｣ => "",
						｢caption｣    => "Named unary precedence"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "prefix <span class=\"code\">temp</span>",
						｢target｣     => "prefix_temp"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "prefix <span class=\"code\">let</span>",
						｢target｣     => "prefix_let",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "Nonchaining binary precedence",
						｢level｣      => 1,
						｢numeration｣ => "",
						｢target｣     => "Nonchaining_binary_precedence"
				},
				{
						｢level｣      => "2",
						｢target｣     => "infix_does",
						｢caption｣    => "infix <span class=\"code\">does</span>",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "infix <span class=\"code\">but</span>",
						｢level｣      => "2",
						｢target｣     => "infix_but",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢target｣     => "infix_cmp",
						｢caption｣    => "infix <span class=\"code\">cmp</span>",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "infix_coll",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">coll</span>"
				},
				{
						｢target｣     => "infix_unicmp",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">unicmp</span>",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢target｣     => "infix_leg",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">leg</span>"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_\&lt;=\&gt;",
						｢caption｣    => "infix <span class=\"code\">\&lt;=\&gt;</span>"
				},
				{
						｢caption｣    => "infix <span class=\"code\">..</span>",
						｢target｣     => "infix_..",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢target｣     => "infix_..^",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">..^</span>"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">^..</span>",
						｢level｣      => "2",
						｢target｣     => "infix_^.."
				},
				{
						｢caption｣    => "infix <span class=\"code\">^..^</span>",
						｢target｣     => "infix_^..^",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "Chaining_binary_precedence",
						｢level｣      => 1,
						｢caption｣    => "Chaining binary precedence"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">==</span>, infix <span class=\"code\">⩵</span>",
						｢target｣     => "infix_==,_infix_⩵"
				},
				{
						｢caption｣    => "infix <span class=\"code\">!=</span>, infix <span class=\"code\">≠</span>",
						｢target｣     => "infix_!=,_infix_≠",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "infix_\&lt;",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">\&lt;</span>"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "infix_\&lt;=,_infix_≤",
						｢caption｣    => "infix <span class=\"code\">\&lt;=</span>, infix <span class=\"code\">≤</span>"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">\&gt;</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_\&gt;"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">\&gt;=</span>, infix <span class=\"code\">≥</span>",
						｢target｣     => "infix_\&gt;=,_infix_≥",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">eq</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_eq"
				},
				{
						｢target｣     => "infix_ne",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">ne</span>"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "infix_gt",
						｢caption｣    => "infix <span class=\"code\">gt</span>"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">ge</span>",
						｢level｣      => "2",
						｢target｣     => "infix_ge"
				},
				{
						｢target｣     => "infix_lt",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">lt</span>",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "infix <span class=\"code\">le</span>",
						｢target｣     => "infix_le",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢target｣     => "infix_before",
						｢caption｣    => "infix <span class=\"code\">before</span>",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">after</span>",
						｢target｣     => "infix_after",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">eqv</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_eqv",
						｢level｣      => "2"
				},
				{
						｢target｣     => "infix_===",
						｢caption｣    => "infix <span class=\"code\">===</span>",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢target｣     => "infix_⩶",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">⩶</span>"
				},
				{
						｢level｣      => "2",
						｢target｣     => "infix_=:=",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">=:=</span>"
				},
				{
						｢level｣      => "2",
						｢target｣     => "infix_~~",
						｢caption｣    => "infix <span class=\"code\">~~</span>",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">=~=</span>",
						｢level｣      => "2",
						｢target｣     => "infix_=~="
				},
				{
						｢caption｣    => "infix <span class=\"code\">≅</span>",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "infix_≅"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "infix (elem), infix ∈",
						｢level｣      => "2",
						｢target｣     => "infix_(elem),_infix_∈"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_∉",
						｢caption｣    => "infix <span class=\"code\">∉</span>"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "infix_(==),_infix_≡",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">(==)</span>, infix <span class=\"code\">≡</span>"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "infix_≢",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">≢</span>"
				},
				{
						｢target｣     => "infix_(cont),_infix_∋",
						｢level｣      => "2",
						｢caption｣    => "infix (cont), infix ∋",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "infix <span class=\"code\">∌</span>",
						｢target｣     => "infix_∌",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "infix <span class=\"code\">(\&lt;)</span>, infix <span class=\"code\">⊂</span>",
						｢target｣     => "infix_(\&lt;),_infix_⊂",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">⊄</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_⊄"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "infix_(\&lt;=),_infix_⊆",
						｢caption｣    => "infix <span class=\"code\">(\&lt;=)</span>, infix <span class=\"code\">⊆</span>"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">⊈</span>",
						｢target｣     => "infix_⊈"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "infix_(\&gt;),_infix_⊃",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">(\&gt;)</span>, infix <span class=\"code\">⊃</span>"
				},
				{
						｢caption｣    => "infix <span class=\"code\">⊅</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_⊅"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "infix_(\&gt;=),_infix_⊇",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">(\&gt;=)</span>, infix <span class=\"code\">⊇</span>"
				},
				{
						｢caption｣    => "infix <span class=\"code\">⊉</span>",
						｢target｣     => "infix_⊉",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">≼</span>, infix <span class=\"code\">≽</span>",
						｢level｣      => "2",
						｢target｣     => "infix_≼,_infix_≽",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "Tight AND precedence",
						｢target｣     => "Tight_AND_precedence",
						｢numeration｣ => "",
						｢level｣      => 1
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">\&amp;\&amp;</span>",
						｢target｣     => "infix_\&amp;\&amp;"
				},
				{
						｢target｣     => "Tight_OR_precedence",
						｢numeration｣ => "",
						｢caption｣    => "Tight OR precedence",
						｢level｣      => 1
				},
				{
						｢target｣     => "infix_||",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">||</span>",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">^^</span>",
						｢level｣      => "2",
						｢target｣     => "infix_^^"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">//</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_//"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_min",
						｢caption｣    => "infix <span class=\"code\">min</span>"
				},
				{
						｢caption｣    => "infix <span class=\"code\">max</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_max"
				},
				{
						｢caption｣    => "infix <span class=\"code\">minmax</span>",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "infix_minmax"
				},
				{
						｢caption｣    => "Conditional operator precedence",
						｢level｣      => 1,
						｢target｣     => "Conditional_operator_precedence",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "infix_??__!!",
						｢caption｣    => "infix <span class=\"code\">?? !!</span>"
				},
				{
						｢caption｣    => "infix <span class=\"code\">ff</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_ff",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">^ff</span>",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_^ff"
				},
				{
						｢level｣      => "2",
						｢target｣     => "infix_ff^",
						｢caption｣    => "infix <span class=\"code\">ff^</span>",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "infix_^ff^",
						｢caption｣    => "infix <span class=\"code\">^ff^</span>",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢target｣     => "infix_fff",
						｢caption｣    => "infix <span class=\"code\">fff</span>",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢target｣     => "infix_^fff",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">^fff</span>",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">fff^</span>",
						｢target｣     => "infix_fff^",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "infix_^fff^",
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">^fff^</span>"
				},
				{
						｢target｣     => "Item_assignment_precedence",
						｢caption｣    => "Item assignment precedence",
						｢numeration｣ => "",
						｢level｣      => 1
				},
				{
						｢caption｣    => "infix <span class=\"code\">=</span> (item assignment)",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_=_(item_assignment)"
				},
				{
						｢target｣     => "infix_=\&gt;",
						｢caption｣    => "infix <span class=\"code\">=\&gt;</span>",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "Loose unary precedence",
						｢numeration｣ => "",
						｢target｣     => "Loose_unary_precedence",
						｢level｣      => 1
				},
				{
						｢level｣      => "2",
						｢caption｣    => "prefix <span class=\"code\">not</span>",
						｢target｣     => "prefix_not",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "prefix <span class=\"code\">so</span>",
						｢target｣     => "prefix_so",
						｢level｣      => "2"
				},
				{
						｢level｣      => 1,
						｢target｣     => "Comma_operator_precedence",
						｢caption｣    => "Comma operator precedence",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "infix <span class=\"code\">,</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_,",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">:</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_:"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "List_infix_precedence",
						｢level｣      => 1,
						｢caption｣    => "List infix precedence"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "infix_Z",
						｢caption｣    => "infix <span class=\"code\">Z</span>"
				},
				{
						｢target｣     => "infix_X",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">X</span>",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "infix <span class=\"code\">...</span>",
						｢target｣     => "infix_...",
						｢numeration｣ => ""
				},
				{
						｢level｣      => 1,
						｢caption｣    => "List prefix precedence",
						｢target｣     => "List_prefix_precedence",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">=</span> (list assignment)",
						｢target｣     => "infix_=_(list_assignment)"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "infix_:=",
						｢caption｣    => "infix <span class=\"code\">:=</span>",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">::=</span>",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "infix_::="
				},
				{
						｢level｣      => "2",
						｢target｣     => "listop_...",
						｢caption｣    => "listop <span class=\"code\">...</span>",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "2",
						｢caption｣    => "listop <span class=\"code\">!!!</span>",
						｢numeration｣ => "",
						｢target｣     => "listop_!!!"
				},
				{
						｢target｣     => "listop_???",
						｢caption｣    => "listop <span class=\"code\">???</span>",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "Reduction operators",
						｢target｣     => "Reduction_operators"
				},
				{
						｢caption｣    => "Loose AND precedence",
						｢numeration｣ => "",
						｢level｣      => 1,
						｢target｣     => "Loose_AND_precedence"
				},
				{
						｢caption｣    => "infix <span class=\"code\">and</span>",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "infix_and"
				},
				{
						｢target｣     => "infix_andthen",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">andthen</span>",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">notandthen</span>",
						｢target｣     => "infix_notandthen"
				},
				{
						｢target｣     => "Loose_OR_precedence",
						｢numeration｣ => "",
						｢level｣      => 1,
						｢caption｣    => "Loose OR precedence"
				},
				{
						｢caption｣    => "infix <span class=\"code\">or</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_or",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "infix <span class=\"code\">orelse</span>",
						｢level｣      => "2",
						｢target｣     => "infix_orelse",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "infix <span class=\"code\">xor</span>",
						｢numeration｣ => "",
						｢target｣     => "infix_xor",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "Sequencer precedence",
						｢target｣     => "Sequencer_precedence",
						｢numeration｣ => "",
						｢level｣      => 1
				},
				{
						｢level｣      => "2",
						｢target｣     => "infix_==\&gt;",
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">==\&gt;</span>"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "infix <span class=\"code\">\&lt;==</span>",
						｢target｣     => "infix_\&lt;==",
						｢level｣      => "2"
				},
				{
						｢target｣     => "Identity",
						｢caption｣    => "Identity",
						｢numeration｣ => "",
						｢level｣      => 1
				}
			],
			｢subtitle｣   => "Common Raku infixes, prefixes, postfixes, and more!",
			｢title｣      => "Operators",
			｢defns｣      => {
				｢en#language/operators#135｣ => {
					｢subkind｣    => "infix",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_,",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#135\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \",\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<,>(*\\\@a --> List:D) is assoc<list>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Constructs a higher-order \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Cool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Cool\",\n        )\n      ),\n      \" from its arguments.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@list = :god('Þor'), ['is',\\\"mighty\\\"];\\nsay \\\@list;      # OUTPUT: «[god => Þor [is mighty]]␤»\\nmy \\\%hash = :god('Þor'), :is(\\\"mighty\\\");\\nsay \\\%hash.raku; # OUTPUT: «\\\{:god(\\\"Þor\\\"), :is(\\\"mighty\\\")}␤»\\nmy \\\%a = :11a, :22b;\\nsay \\\%(\\\%a, :33x);  # OUTPUT: «\\\{a => 11, b => 22, x => 33}␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"In the first case it returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"List\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/List\",\n        )\n      ),\n      \", in the second case, since the\\narguments are \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \"s, it builds a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Hash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Hash\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"It can also be used for constructing variables from other variables, collating\\nelements of different types, in this case a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Hash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Hash\",\n        )\n      ),\n      \" and a\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \":\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:preamble(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"my \\\%hash\"),\n        )\n      ))},\n      paragraphs => (\n        \"my \\\%features = \\\%hash, :wields(\\\"hammer\\\");\\nsay \\\%features;  # OUTPUT: «\\\{god => Þor, is => mighty, wields => hammer}␤»\\n\",\n      )\n    ),\n    \"The comma is also used syntactically as the separator of arguments in\\ncalls.\\n\\n\\n\",\n  )\n)",
					｢name｣       => ","
				},
				｢en#language/operators#032｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#032\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"div\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<div>(Int:D, Int:D --> Int:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Integer division operator\",\n        ),\n        meta   => (\n          \"Infix operators,Integer division operator\",\n        )\n      ),\n      \". Rounds down.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note there is also \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"/\",\n            )\n          ),\n        ),\n        meta   => (\n          \"#infix_/\",\n        )\n      ),\n      \" for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \" division.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_div",
					｢subkind｣    => "infix",
					｢name｣       => "div"
				},
				｢en#language/operators#009｣ => {
					｢kind｣       => "operator",
					｢subkind｣    => "postcircumfix",
					｢name｣       => "« »",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#009\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"postcircumfix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"« »\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Shortcut for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"postcircumfix \\\{ }\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/\\\{ }#(Operators)_postcircumfix_\\\{_}\",\n        )\n      ),\n      \"\\nthat quotes its argument using the same rules as the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"interpolating quote-words operator\",\n        ),\n        meta   => (\n          \"/language/quoting#Word_quoting_with_interpolation_and_quote_protection:_«_»\",\n        )\n      ),\n      \"\\nof the same name.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\%color = kiwi => \\\"green\\\", banana => \\\"yellow\\\", cherry => \\\"red\\\";\\nmy \\\$fruit = \\\"kiwi\\\";\\nsay \\\%color«cherry \\\"\\\$fruit\\\"».raku;   # OUTPUT: «(\\\"red\\\", \\\"green\\\")␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Technically, not a real operator; it's syntactic sugar that's turned into the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\{ }\",\n        )\n      ),\n      \" postcircumfix operator at compile-time.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "postcircumfix_«_»"
				},
				｢en#language/operators#111｣ => {
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_⊅",
					｢name｣       => "⊅",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#111\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⊅\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<⊅>(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Not a superset of operator\",\n        ),\n        meta   => (\n          \"Infix operators,Not a superset of operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"not\",\n        )\n      ),\n      \" a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"strict superset\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \".  Equivalent to\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"!(>)\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say (1,2,3) ⊅ (2,3,1); # OUTPUT: «True␤»\\nsay (1,2,3) ⊅ (2,3);   # OUTPUT: «False␤»\\nsay 4 !(>) (1,2,3);    # OUTPUT: «True␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#118｣ => {
					｢name｣       => "//",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_//",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#118\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"//\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"defined-or operator\",\n        ),\n        meta   => (\n          \"Infix operators,defined-or operator\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"infix //\",\n        ),\n        meta   => (\n          \"Infix operators,//\",\n        )\n      ),\n      \" returns the first defined operand, or else the last\\noperand. Short-circuits.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say Any // 0 // 42;         # OUTPUT: «0␤»\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#087｣ => {
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#087\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"gt\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<gt>(Mu,    Mu)\\nmulti infix:<gt>(Str:D, Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"String greater than operator\",\n        ),\n        meta   => (\n          \"Infix operators,String greater than operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" (if necessary); returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if\\nthe first is larger than the second, as determined by lexicographic\\ncomparison.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Mnemonic: \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"greater than\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "gt",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_gt"
				},
				｢en#language/operators#055｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#055\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"~\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<~>(Any,   Any)\\nmulti infix:<~>(Str:D, Str:D)\\nmulti infix:<~>(Buf:D, Buf:D)\\nmulti infix:<~>(Blob:D \\\$a, Blob:D \\\$b)\\nmulti infix:<~>(Junction:D \\\\a, Junction:D \\\\b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This is the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"string concatenation operator\",\n        ),\n        meta   => (\n          \"Infix operators,string concatenation operator\",\n        )\n      ),\n      \", which coerces both\\narguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" and concatenates them. If both arguments\\nare \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Buf\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Buf\",\n        )\n      ),\n      \", a combined buffer is returned.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"say 'ab' ~ 'c';     # OUTPUT: «abc␤»\\nmy \\\$bob = Blob.new([1,2,3]);\\nmy \\\$bao = Blob.new([3,4,5]);\\nsay \\\$bao ~ \\\$bob;     # OUTPUT: «Blob:0x<03 04 05 01 02 03>␤»\\n\\n\",\n      )\n    ),\n    \"The arity-1 version of this operator will be called when the hyper version of\\nthe operator is used on an array or list with a single element, or simply an\\nelement\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"say [~] Blob.new([3,4,5]);     # OUTPUT: «Blob:0x<03 04 05>␤»\\nsay [~] 1|2;                   # OUTPUT: «any(1, 2)␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "~",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_~",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#044｣ => {
					｢name｣       => "lcm",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_lcm",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#044\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"lcm\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<lcm>(\\\$a, \\\$b --> Int:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \" and returns the least common multiple; that is,\\nthe smallest integer that is evenly divisible by both arguments.\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,least common multiple operator\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#062｣ => {
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_(+),_infix_⊎",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#062\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"(+)\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⊎\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<(+)>(**\\\@p)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Baggy addition operator\",\n        ),\n        meta   => (\n          \"Infix operators,Baggy addition operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the Baggy \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"addition\",\n        )\n      ),\n      \" of its arguments.  This creates a new\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bag\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bag\",\n        )\n      ),\n      \" from each element of the arguments with the weights of the\\nelement added together to get the new weight, if none of the arguments are a\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mix\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mix\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"MixHash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/MixHash\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say <a a b c a d> (+) <a a b c c>; # OUTPUT: «Bag(a(5) b(2) c(3) d)␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If any of the arguments is a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mixy\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mixy\",\n        )\n      ),\n      \", the result is a new \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mix\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mix\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say <a b c> (+) (a => 2.5, b => 3.14).Mix; # OUTPUT: «Mix(a(3.5) b(4.14) c)␤»\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "(+), infix ⊎"
				},
				｢en#language/operators#040｣ => {
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_~\&lt;",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#040\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"~<\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces the left argument to a non-variable-encoding string buffer type (e.g. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf8\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf16\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf32\",\n        )\n      ),\n      \")\\nand then performs a numeric bitwise left shift on the bits of the buffer.\\n\\n\"\n    ),\n    \"Please note that this has not yet been implemented.\\n\\n\",\n  )\n)",
					｢name｣       => "~<"
				},
				｢en#language/operators#083｣ => {
					｢subkind｣    => "infix",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#083\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \">\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:«>»(Int:D, Int:D)\\nmulti infix:«>»(Num:D, Num:D)\\nmulti infix:«>»(Real:D, Real:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Numeric greater than operator\",\n        ),\n        meta   => (\n          \"Infix operators,Numeric greater than operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Real\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Real\",\n        )\n      ),\n      \" (if necessary); returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if the first argument\\nis larger than the second.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_\&gt;",
					｢name｣       => ">"
				},
				｢en#language/operators#008｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#008\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"postcircumfix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"< >\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Shortcut for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"postcircumfix \\\{ }\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/\\\{ }#(Operators)_postcircumfix_\\\{_}\",\n        )\n      ),\n      \"\\nthat quotes its argument using the same rules as the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"quote-words operator\",\n        ),\n        meta   => (\n          \"#term_<_>\",\n        )\n      ),\n      \"\\nof the same name.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\%color = kiwi => \\\"green\\\", banana => \\\"yellow\\\", cherry => \\\"red\\\";\\nsay \\\%color<banana>;               # OUTPUT: «yellow␤»\\nsay \\\%color<cherry kiwi>.raku;     # OUTPUT: «(\\\"red\\\", \\\"green\\\")␤»\\nsay \\\%color<strawberry>:exists;    # OUTPUT: «False␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Technically, not a real operator; it's syntactic sugar that's turned into the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\{ }\",\n        )\n      ),\n      \" postcircumfix operator at compile-time.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "postcircumfix",
					｢targ-in-fn｣ => "postcircumfix_\&lt;_\&gt;",
					｢name｣       => "< >"
				},
				｢en#language/operators#012｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#012\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"«\",\n                closer => \"»\",\n                atoms  => (\n                  \"++\",\n                )\n              ),\n            ),\n            meta   => (\n              \"Prefix operators,prefix ++\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<++>(\\\$x is rw) is assoc<non>\\n\\n\",\n      )\n    ),\n    \"Increments its argument by one and returns the updated value.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$x = 3;\\nsay ++\\\$x;   # OUTPUT: «4␤»\\nsay \\\$x;     # OUTPUT: «4␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"It works by calling the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"succ\",\n        ),\n        meta   => (\n          \"/routine/succ\",\n        )\n      ),\n      \" method (for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"successor\",\n        )\n      ),\n      \") on its\\nargument, which gives custom types the freedom to implement their own increment\\nsemantics.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Operators,prefix decrement operator\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "prefix_++",
					｢kind｣       => "operator",
					｢subkind｣    => "prefix",
					｢name｣       => "++"
				},
				｢en#language/operators#001｣ => {
					｢name｣       => "< >",
					｢targ-in-fn｣ => "term_\&lt;_\&gt;",
					｢kind｣       => "routine",
					｢subkind｣    => "term",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#001\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"term \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"< >\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"quote-words\",\n        ),\n        meta   => (\n          \"Terms,qw;Terms,quote-words\",\n        )\n      ),\n      \" construct breaks up the contents on whitespace\\nand returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"List\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/List\",\n        )\n      ),\n      \" of the words. If a word looks like a number\\nliteral or a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \" literal, it's converted to the appropriate number.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say <a b c>[1];   # OUTPUT: «b␤»\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#133｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#133\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"not\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<not>(Mu \\\$x --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Evaluates its argument in Boolean context (and thus collapses \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \"s),\\nand negates the result. Please note that \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"not\",\n        )\n      ),\n      \" is easy to misuse. See\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"traps\",\n        ),\n        meta   => (\n          \"/language/traps#Loose_Boolean_operators\",\n        )\n      ),\n      \".\\n\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "prefix",
					｢targ-in-fn｣ => "prefix_not",
					｢kind｣       => "operator",
					｢name｣       => "not"
				},
				｢en#language/operators#151｣ => {
					｢targ-in-fn｣ => "infix_xor",
					｢name｣       => "xor",
					｢subkind｣    => "infix",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#151\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"xor\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"^^\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/\\\$CIRCUMFLEX_ACCENT\\\$CIRCUMFLEX_ACCENT\",\n        )\n      ),\n      \", except with looser precedence.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the operand that evaluates to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" in Boolean context, if and\\nonly if the other operand evaluates to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \" in Boolean context. If\\nboth operands evaluate to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \", returns the last argument. If both\\noperands evaluate to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \", returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"When chaining, returns the operand that evaluates to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \", if and\\nonly if there is one such operand. If more than one operand is true,\\nit short-circuits after evaluating the second and returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \". If all\\noperands are false, returns the last one.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#153｣ => {
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_\&lt;==",
					｢kind｣       => "operator",
					｢name｣       => "<==",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#153\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"<==\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"leftward feed\",\n        ),\n        meta   => (\n          \"Infix operators,leftward feed\",\n        )\n      ),\n      \" operator takes the result from the right and passes\\nit to the previous (left) routine as the last parameter. This\\nelucidates the right-to-left dataflow for a series of list manipulating\\nfunctions.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"# Traditional structure, read bottom-to-top\\nmy \\\@result =\\n    sort                   # (4) Sort, result is <Earth People>\\n    grep \\\{ /<[PE]>/ },     # (3) Look for P or E\\n    map \\\{ .tc },           # (2) Capitalize the words\\n    <people of earth>;     # (1) Start with the input\\n\\n# Feed (right-to-left) with parentheses, read bottom-to-top\\nmy \\\@result = (\\n    sort()                 # (4) Sort, result is <Earth People>\\n    <== grep(\\\{ /<[PE]>/ }) # (3) Look for P or E\\n    <== map(\\\{ .tc })       # (2) Capitalize the words\\n    <== <people of earth>  # (1) Start with the input\\n);\\n\\n# To assign without parentheses, use another feed operator\\nmy \\\@result\\n    <== sort()              # (4) Sort, result is <Earth People>\\n    <== grep(\\\{ /<[PE]>/ })  # (3) Look for P or E\\n    <== map(\\\{ .tc })        # (2) Capitalize the words\\n    <== <people of earth>;  # (1) Start with the input\\n\\n# It can be useful to capture a partial result\\nmy \\\@result\\n    <== sort()\\n    <== grep(\\\{ /<[PE]>/ })\\n    <== my \\\@caps            # unlike ==>, there's no need for additional statement\\n    <== map(\\\{ .tc })\\n    <== <people of earth>;\\n\\n\",\n      )\n    ),\n    \"Unlike the rightward feed operator, the result is not closely mappable\\nto method-chaining. However, compared to the traditional structure above\\nwhere each argument is separated by a line, the resulting code is more\\ndemonstrative than commas. The leftward feed operator also allows you\\nto \\\"break into\\\" the statement and capture an intermediary result which\\ncan be extremely useful for debugging or to take that result and create\\nanother variation on the final result.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"Note: In the future, this operator will see some change as it gains the\\nability to run list operations in parallel. It will enforce that the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"right\",\n        )\n      ),\n      \" operand is enclosable as a closure (that can be cloned and run in\\na subthread).\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#025｣ => {
					｢subkind｣    => "prefix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#025\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"~^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces the argument to a non-variable-encoding string buffer type (e.g. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf8\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf16\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf32\",\n        )\n      ),\n      \")\\nand then flips each bit in that buffer.\\n\\n\"\n    ),\n    \"Please note that this has not yet been implemented.\\n\\n\",\n  )\n)",
					｢name｣       => "~^",
					｢targ-in-fn｣ => "prefix_~^",
					｢kind｣       => "operator"
				},
				｢en#language/operators#068｣ => {
					｢targ-in-fn｣ => "infix_does",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#068\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"does\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<does>(Mu \\\$obj, Mu \\\$role) is assoc<non>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Mixes \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$role\",\n        )\n      ),\n      \" into \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$obj\",\n        )\n      ),\n      \" at runtime. Requires \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$obj\",\n        )\n      ),\n      \" to be mutable.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Similar to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"but\",\n        ),\n        meta   => (\n          \"/routine/but\",\n        )\n      ),\n      \" operator, if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$role\",\n        )\n      ),\n      \" supplies exactly one\\nattribute, an initializer can be passed in parentheses.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Similar to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"but\",\n        ),\n        meta   => (\n          \"/routine/but\",\n        )\n      ),\n      \" operator, the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$role\",\n        )\n      ),\n      \" can instead be an instantiated object,\\nin which case, the operator will create a role for you automatically.\\nThe role will contain a single method named the same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$obj.^name\",\n        )\n      ),\n      \"\\nand that returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$obj\",\n        )\n      ),\n      \":\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$o = class \\\{ method Str \\\{ \\\"original\\\" } }.new;\\nput \\\$o;            # OUTPUT: «original␤»\\n\\\$o does \\\"modded\\\";\\nput \\\$o;            # OUTPUT: «modded␤»\\n\\n\",\n      )\n    ),\n    \"If methods of the same name are present already, the last mixed in role takes\\nprecedence.\\n\\n\",\n  )\n)",
					｢subkind｣    => "infix",
					｢name｣       => "does"
				},
				｢en#language/operators#095｣ => {
					｢targ-in-fn｣ => "infix_⩶",
					｢subkind｣    => "infix",
					｢kind｣       => "operator",
					｢name｣       => "⩶",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#095\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⩶\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<⩶>(Any, Any)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"⩶\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Value identity operator\",\n        ),\n        meta   => (\n          \"Infix operators,Value identity operator\",\n        )\n      ),\n      \". Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if both arguments are the same\\nobject, disregarding any containerization.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my class A \\\{ };\\nmy \\\$a = A.new;\\nsay \\\$a ⩶ \\\$a;              # OUTPUT: «True␤»\\nsay A.new ⩶ A.new;        # OUTPUT: «False␤»\\nsay A ⩶ A;                # OUTPUT: «True␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"For value types, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"⩶\",\n        )\n      ),\n      \" behaves like \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"eqv\",\n        )\n      ),\n      \":\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say 'a' ⩶ 'a';            # OUTPUT: «True␤»\\nsay 'a' ⩶ 'b';            # OUTPUT: «False␤»\\n\\nmy \\\$b = 'a';\\nsay \\\$b ⩶ 'a';             # OUTPUT: «True␤»\\n\\n# different types\\nsay 1 ⩶ 1.0;              # OUTPUT: «False␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"⩶\",\n        )\n      ),\n      \" uses the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"WHICH\",\n        ),\n        meta   => (\n          \"/routine/WHICH\",\n        )\n      ),\n      \" method to obtain the object identity.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If you want to create a class that should act as a value type, then that\\nclass must create an instance method \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"WHICH\",\n        )\n      ),\n      \", that should return a\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"ValueObjAt\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/ValueObjAt\",\n        )\n      ),\n      \" object that won't change for the lifetime of\\nthe object.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The ASCII equivalent of this operator is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"===\",\n            )\n          ),\n        ),\n        meta   => (\n          \"#infix_===\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#122｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "??  !!",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#122\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"?? !!\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Also called \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"ternary\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"conditional\",\n        )\n      ),\n      \" operator, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$condition ?? \\\$true !!\\n\\\$false\",\n        )\n      ),\n      \" evaluates \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$condition\",\n        )\n      ),\n      \" and returns the expression right behind ??,\\nin this case \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$true\",\n        )\n      ),\n      \" if it is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \", otherwise evaluates and returns\\nthe expression behind !!, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$false\",\n        )\n      ),\n      \" in this case.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,flipflop\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_??__!!",
					｢kind｣       => "operator"
				},
				｢en#language/operators#138｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#138\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"X\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<X>(+lol, :\\\&with! --> Seq:D)\\nmulti infix:<X>(+lol --> Seq:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Creates a cross product from all the lists, ordered so that the\\nrightmost elements vary most rapidly, and returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \":\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"1..3 X <a b c> X 9\\n# produces ((1 a 9) (1 b 9) (1 c 9)\\n#           (2 a 9) (2 b 9) (2 c 9)\\n#           (3 a 9) (3 b 9) (3 c 9))\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"X\",\n        )\n      ),\n      \" operator also exists as a metaoperator, in which case the inner\\nlists are replaced by the value from applying the operator to the list:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"1..3 X~ <a b c> X~ 9\\n# produces (1a9 1b9 1c9 2a9 2b9 2c9 3a9 3b9 3c9)\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_X",
					｢name｣       => "X"
				},
				｢en#language/operators#035｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "mod",
					｢targ-in-fn｣ => "infix_mod",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#035\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"mod\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<mod>(Int:D \\\$a, Int:D \\\$b --> Int:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Integer modulo operator\",\n        ),\n        meta   => (\n          \"Infix operators,Integer modulo operator\",\n        )\n      ),\n      \". Returns the remainder of an integer modulo operation.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note there is also \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\%\",\n            )\n          ),\n        ),\n        meta   => (\n          \"#infix_\\\%\",\n        )\n      ),\n      \" for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \" modulo.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#090｣ => {
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_le",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#090\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"le\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<le>(Mu,    Mu)\\nmulti infix:<le>(Str:D, Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"String less than or equal to operator\",\n        ),\n        meta   => (\n          \"Infix operators,String less than or equal to operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" (if necessary); returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if\\nthe first is equal to or smaller than the second, as determined by lexicographic\\ncomparison.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Mnemonic: \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"less or equal\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "le"
				},
				｢en#language/operators#033｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#033\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"\\\%\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<\\\%>(\\\$x, \\\$y --> Numeric:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Modulo operator\",\n        ),\n        meta   => (\n          \"Infix operators,Modulo operator\",\n        )\n      ),\n      \". Coerces to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \" first.\\n\\n\"\n    ),\n    \"Generally the following identity holds:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my (\\\$x, \\\$y) = 1,2;\\n\\\$x \\\% \\\$y == \\\$x - floor(\\\$x / \\\$y) * \\\$y\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note there is also \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"mod\",\n            )\n          ),\n        ),\n        meta   => (\n          \"#infix_\\\%\",\n        )\n      ),\n      \" for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \" modulo.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢name｣       => "\%",
					｢targ-in-fn｣ => "infix_\%"
				},
				｢en#language/operators#141｣ => {
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#141\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \":=\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Binding operator\",\n        ),\n        meta   => (\n          \"Infix operators,binding operator\",\n        )\n      ),\n      \". Whereas \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$x = \\\$y\",\n        )\n      ),\n      \" puts the value in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$y\",\n        )\n      ),\n      \" into\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$x\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$x := \\\$y\",\n        )\n      ),\n      \" makes \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$x\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$y\",\n        )\n      ),\n      \" the same thing.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$a = 42;\\nmy \\\$b = \\\$a;\\n\\\$b++;\\nsay \\\$a;\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This will output 42, because \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" both contained the number\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"42\",\n        )\n      ),\n      \", but the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"containers\",\n        ),\n        meta   => (\n          \"/language/containers#Binding\",\n        )\n      ),\n      \" were\\ndifferent.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$a = 42;\\nmy \\\$b := \\\$a;\\n\\\$b++;\\nsay \\\$a;\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This will output 43, since \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" both represented the same\\nobject.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If type constrains on variables or containers are present a type check\\nwill be performed at runtime. On failure \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"X::TypeCheck::BindingType\",\n        )\n      ),\n      \"\\nwill be thrown.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Please note that \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":=\",\n        )\n      ),\n      \" is a compile time operator. As such it can not\\nbe referred to at runtime and thus can't be used as an argument to\\nmetaoperators.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_:=",
					｢name｣       => ":="
				},
				｢en#language/operators#110｣ => {
					｢targ-in-fn｣ => "infix_(\&gt;),_infix_⊃",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#110\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"(>)\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⊃\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:«(>)»(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Superset of operator\",\n        ),\n        meta   => (\n          \"Infix operators,Superset of operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"strict superset\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \", i.e., that all the\\nelements of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" are elements of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" but \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is a larger set than \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say (1,2,3) (>) (2,3,1); # OUTPUT: «False␤»\\nsay (1,2,3) (>) (2,3);   # OUTPUT: «True␤»\\nsay 4 ⊃ (1,2,3);         # OUTPUT: «False␤»\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "(>), infix ⊃"
				},
				｢en#language/operators#091｣ => {
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#091\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"before\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<before>(Any,       Any)\\nmulti infix:<before>(Real:D,    Real:D)\\nmulti infix:<before>(Str:D,     Str:D)\\nmulti infix:<before>(Version:D, Version:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Generic ordering, uses the same semantics as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"cmp\",\n        ),\n        meta   => (\n          \"/routine/cmp\",\n        )\n      ),\n      \".\\nReturns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if the first argument is smaller than the second.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢name｣       => "before",
					｢targ-in-fn｣ => "infix_before"
				},
				｢en#language/operators#063｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#063\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"(-)\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"∖\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<(-)>(**\\\@p)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Set difference operator\",\n        ),\n        meta   => (\n          \"Infix operators,Set difference operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"set difference\",\n        )\n      ),\n      \" of all its arguments.  This creates a new\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Set\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Set\",\n        )\n      ),\n      \" that contains all the elements the first argument has but the\\nrest of the arguments don't, i.e., of all the elements of the first argument,\\nminus the elements from the other arguments.  But only if none of the arguments\\nare a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bag\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bag\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"BagHash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/BagHash\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mix\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mix\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"MixHash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/MixHash\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say <a a b c a d> (-) <a a b c c>; # OUTPUT: «Set(d)␤»\\nsay <a b c d e> (-) <a b c> (-) <a b d>; # OUTPUT: «Set(e)␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If any of the arguments are \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Baggy\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Baggy\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mixy\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mixy\",\n        )\n      ),\n      \",\\nthe result is a new \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bag\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bag\",\n        )\n      ),\n      \" (or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mix\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mix\",\n        )\n      ),\n      \") containing all the elements remaining\\nafter the first argument with its weight subtracted by the weight of that\\nelement in each of the other arguments.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say <a a b c a d> (-) bag(<a b c c>); # OUTPUT: «Bag(a(2) d)␤»\\nsay <a a b c a d>  ∖  mix(<a b c c>); # OUTPUT: «Mix(a(2) c(-1) d)␤»\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "infix",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_(-),_infix_∖",
					｢name｣       => "(-), infix ∖"
				},
				｢en#language/operators#021｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#021\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"-\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<->(Any --> Numeric:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Negative numeric context operator\",\n        ),\n        meta   => (\n          \"Prefix operators,Negative numeric context operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces the argument to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \" by calling the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Numeric\",\n        )\n      ),\n      \" method on it,\\nand then negates the result.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "prefix",
					｢targ-in-fn｣ => "prefix_-",
					｢name｣       => "-"
				},
				｢en#language/operators#078｣ => {
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_^..^",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#078\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"^..^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<^..^>(\\\$a, \\\$b --> Range:D) is assoc<non>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Open range operator\",\n        ),\n        meta   => (\n          \"Infix operators,Open range operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Constructs a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Range\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Range\",\n        )\n      ),\n      \" from the arguments, excluding both start and end point.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "^..^"
				},
				｢en#language/operators#048｣ => {
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_+^",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#048\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"+^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<+^>(\\\$a, \\\$b --> Int:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Integer bitwise XOR operator\",\n        ),\n        meta   => (\n          \"Infix operators,Integer bitwise XOR operator\",\n        )\n      ),\n      \": Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \" and\\ndoes a bitwise \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"XOR\",\n        )\n      ),\n      \" (exclusive OR) operation.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"say (0b00001101 +^ 0b00001001).base(2); # OUTPUT: «100␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢name｣       => "+^"
				},
				｢en#language/operators#093｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#093\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"eqv\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<eqv>(Any, Any)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This could be called an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"equivalence operator\",\n        ),\n        meta   => (\n          \"Infix operators,equivalence operator\",\n        )\n      ),\n      \", and it will return \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if\\nthe two arguments are structurally the same, i.e. from the same type and\\n(recursively) contain equivalent values.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say [1, 2, 3] eqv [1, 2, 3];    # OUTPUT: «True␤»\\nsay Any eqv Any;                # OUTPUT: «True␤»\\nsay 1 eqv 2;                    # OUTPUT: «False␤»\\nsay 1 eqv 1.0;                  # OUTPUT: «False␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Lazy \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Iterable\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Iterable\",\n        )\n      ),\n      \"s cannot be compared, as\\nthey're assumed to be infinite. However, the operator will do its best and\\nreturn \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \" if the two lazy \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Iterable\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Iterable\",\n        )\n      ),\n      \"s are of different types or\\nif only one \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Iterable\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Iterable\",\n        )\n      ),\n      \" is lazy.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say (1…∞) eqv (1…∞).List; # Both lazy, but different types;   OUTPUT: «False␤»\\nsay (1…∞) eqv (1…3);      # Same types, but only one is lazy; OUTPUT: «False␤»\\n(try say (1…∞) eqv (1…∞)) # Both lazy and of the same type. Cannot compare; throws.\\n    orelse say \\\$!.^name;  # OUTPUT: «X::Cannot::Lazy␤»\\n\\n\",\n      )\n    ),\n    \"In some cases, it will be able to compare lazy operands, as long as they can\\nbe iterated\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"my \\\$a = lazy ^2;\\nmy \\\$b = \\\$a;\\n\\\$a.cache;\\nsay \\\$a eqv \\\$b; # OUTPUT: «True␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"When cached, the two lazy \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \"s can be iterated over, and thus compared.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The default \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"eqv\",\n        )\n      ),\n      \" operator even works with arbitrary objects. E.g., \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"eqv\",\n        )\n      ),\n      \"\\nwill consider two instances of the same object as being structurally\\nequivalent:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my class A \\\{\\n    has \\\$.a;\\n}\\nsay A.new(a => 5) eqv A.new(a => 5);  # OUTPUT: «True␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Although the above example works as intended, the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"eqv\",\n        )\n      ),\n      \" code might fall back\\nto a slower code path in order to do its job. One way to avoid this is to\\nimplement an appropriate infix \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"eqv\",\n        )\n      ),\n      \" operator:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my class A \\\{\\n    has \\\$.a;\\n}\\nmulti infix:<eqv>(A \\\$l, A \\\$r) \\\{ \\\$l.a eqv \\\$r.a }\\nsay A.new(a => 5) eqv A.new(a => 5);            # OUTPUT: «True␤»\\n\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note that \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"eqv\",\n        )\n      ),\n      \" does not work recursively on every kind of container type,\\ne.g. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Set\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Set\",\n        )\n      ),\n      \":\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my class A \\\{\\n    has \\\$.a;\\n}\\nsay Set(A.new(a => 5)) eqv Set(A.new(a => 5));  # OUTPUT: «False␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Even though the contents of the two sets are \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"eqv\",\n        )\n      ),\n      \", the sets are not.\\nThe reason is that \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"eqv\",\n        )\n      ),\n      \" delegates the equality check to the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Set\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Set\",\n        )\n      ),\n      \" object\\nwhich relies on element-wise \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"===\",\n        )\n      ),\n      \" comparison. Turning the class \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"A\",\n        )\n      ),\n      \"\\ninto a value type (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"ValueObjAt\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/ValueObjAt\",\n        )\n      ),\n      \") by giving it a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"WHICH\",\n        )\n      ),\n      \" method\\nproduces the expected behavior:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my class A \\\{\\n    has \\\$.a;\\n    method WHICH \\\{\\n        ValueObjAt.new: \\\"A|\\\$!a.WHICH()\\\"\\n    }\\n}\\nsay Set(A.new(a => 5)) eqv Set(A.new(a => 5));  # OUTPUT: «True␤»\\n\\n\",\n      )\n    ),\n    \"You can call a single-argument version of the operator by using its full\\nname; it will always return true.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"say infix:<eqv>(33);    # OUTPUT: «True␤»\\nsay infix:<eqv>(False); # OUTPUT: «True␤»\\n\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_eqv",
					｢name｣       => "eqv",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#124｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#124\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"^ff\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<^ff>(Mu \\\$a, Mu \\\$b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Works like \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"ff\",\n        ),\n        meta   => (\n          \"/routine/ff\",\n        )\n      ),\n      \", except it does not return \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" for items\\nmatching the start condition (including items also matching the stop\\ncondition).\\n\\n\"\n    ),\n    \"A comparison:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@list = <X A B C Y>;\\nsay \\\$_ if /A/ ff /C/ for \\\@list;    # OUTPUT: «A␤B␤C␤»\\nsay \\\$_ if /A/ ^ff /C/ for \\\@list;   # OUTPUT: «B␤C␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The sed-like version can be found in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"^fff\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/\\\$CIRCUMFLEX_ACCENTfff\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"This operator cannot be overloaded, as it's handled specially by the compiler.\\n\\n\",\n  )\n)",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_^ff",
					｢subkind｣    => "infix",
					｢name｣       => "^ff"
				},
				｢en#language/operators#042｣ => {
					｢subkind｣    => "infix",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#042\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"?\\\&\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<?\\\&>(Mu \\\$x = Bool::True)\\nmulti infix:<?\\\&>(Mu \\\\a, Mu \\\\b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Boolean logical AND operator\",\n        ),\n        meta   => (\n          \"Infix operators,Boolean logical AND operator\",\n        )\n      ),\n      \". Coerces the argument(s) to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bool\",\n        )\n      ),\n      \"\\nand performs logical AND on it(them): it will return True if and only if both\\narguments are True. On a single argument it behaves as identity, returning\\nthe coerced value.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "?\&",
					｢targ-in-fn｣ => "infix_?\&amp;"
				},
				｢en#language/operators#148｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#148\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"«\",\n                closer => \"»\",\n                atoms  => (\n                  \"notandthen\",\n                )\n              ),\n            ),\n            meta   => (\n              \"Infix operators,notandthen\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"notandthen\",\n        )\n      ),\n      \" operator returns\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Empty\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Slip#constant_Empty\",\n        )\n      ),\n      \" upon encountering the first\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"defined\",\n        ),\n        meta   => (\n          \"/routine/defined\",\n        )\n      ),\n      \" argument, otherwise the last argument. Last argument\\nis returned as-is, without being checked for definedness at all. Short-circuits.\\nThe result of the left side is bound to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" for the right side, or passed as\\narguments if the right side is a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Callable\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Callable\",\n        )\n      ),\n      \", whose\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"count\",\n        ),\n        meta   => (\n          \"/routine/count\",\n        )\n      ),\n      \" must be \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"0\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"1\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"At first glance, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"notandthen\",\n        ),\n        meta   => (\n          \"/routine/notandthen\",\n        )\n      ),\n      \" might appear to be the same\\nthing as the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"orelse\",\n        ),\n        meta   => (\n          \"/routine/orelse\",\n        )\n      ),\n      \" operator. The difference is subtle:\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"notandthen\",\n        ),\n        meta   => (\n          \"/routine/notandthen\",\n        )\n      ),\n      \" returns\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Empty\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Slip#constant_Empty\",\n        )\n      ),\n      \" when it encounters a\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"defined\",\n        ),\n        meta   => (\n          \"/routine/defined\",\n        )\n      ),\n      \" item (that isn't the last item), whereas\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"orelse\",\n        ),\n        meta   => (\n          \"/routine/orelse\",\n        )\n      ),\n      \" returns that item. In other words,\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"notandthen\",\n        ),\n        meta   => (\n          \"/routine/notandthen\",\n        )\n      ),\n      \" is a means to act when items aren't defined,\\nwhereas \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"orelse\",\n        ),\n        meta   => (\n          \"/routine/orelse\",\n        )\n      ),\n      \" is a means to obtain the first defined item:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"sub all-sensors-down     \\\{ [notandthen] |\\\@_, True             }\\nsub first-working-sensor \\\{ [orelse]     |\\\@_, 'default sensor' }\\n\\nall-sensors-down Nil, Nil, Nil\\n  and say 'OMG! All sensors are down!'; # OUTPUT:«OMG! All sensors are down!␤»\\nsay first-working-sensor Nil, Nil, Nil; # OUTPUT:«default sensor␤»\\n\\nall-sensors-down Nil, 42, Nil\\n  and say 'OMG! All sensors are down!'; # No output\\nsay first-working-sensor Nil, 42, Nil;  # OUTPUT:«42␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"notandthen\",\n        )\n      ),\n      \" operator is a close relative of the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"without\",\n            )\n          ),\n          \" statement\\nmodifier\",\n        ),\n        meta   => (\n          \"/language/control#with_orwith_without\",\n        )\n      ),\n      \", and some compilers\\ncompile \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"without\",\n        )\n      ),\n      \" to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"notandthen\",\n        )\n      ),\n      \", meaning these two lines have equivalent\\nbehavior:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"sub good-things \\\{ fail }\\n\\n'boo'.say without good-things;\\ngood-things() notandthen 'boo'.say;\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_notandthen",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢name｣       => "notandthen"
				},
				｢en#language/operators#006｣ => {
					｢targ-in-fn｣ => "postcircumfix_\{_}",
					｢name｣       => "\{ }",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#006\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"postcircumfix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"\\\{ }\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub postcircumfix:<\\\{ }>(\\\%container, **\\\@key,\\n                        :\\\$k, :\\\$v, :\\\$kv, :\\\$p, :\\\$exists, :\\\$delete)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Universal interface for associative access to zero or more elements of a\\n\\\%container, a.k.a. \\\"\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"hash indexing operator\",\n        ),\n        meta   => (\n          \"Postcircumfix operators,hash indexing operator;Postcircumfix operators,hash subscript operator\",\n        )\n      ),\n      \"\\\".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\%color = kiwi => \\\"green\\\", banana => \\\"yellow\\\", cherry => \\\"red\\\";\\nsay \\\%color\\\{\\\"banana\\\"};                 # OUTPUT: «yellow␤»\\nsay \\\%color\\\{\\\"cherry\\\", \\\"kiwi\\\"}.raku;    # OUTPUT: «(\\\"red\\\", \\\"green\\\")␤»\\nsay \\\%color\\\{\\\"strawberry\\\"}:exists;      # OUTPUT: «False␤»\\n\\n\\\%color\\\{\\\"banana\\\", \\\"lime\\\"} = \\\"yellowish\\\", \\\"green\\\";\\n\\\%color\\\{\\\"cherry\\\"}:delete; # note that value is always returned but removal only happens when delete is true.\\nsay \\\%color;             # OUTPUT: «banana => yellowish, kiwi => green, lime => green␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"postcircumfix < >\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/language/operators#postcircumfix_<_>\",\n        )\n      ),\n      \" and\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"postcircumfix « »\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/« »#(Operators)_postcircumfix_«_»\",\n        )\n      ),\n      \" for convenient\\nshortcuts, and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Subscripts\",\n        ),\n        meta   => (\n          \"/language/subscripts\",\n        )\n      ),\n      \" for a more detailed\\nexplanation of this operator's behavior and how to implement support for it\\nin custom types.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "postcircumfix"
				},
				｢en#language/operators#036｣ => {
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#036\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"+\\\&\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<+\\\&>(\\\$a, \\\$b --> Int:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Numeric bitwise \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"AND\",\n        )\n      ),\n      \" operator. Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \" and does a bitwise\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"AND\",\n        )\n      ),\n      \" operation assuming two's complement.\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,Numeric bitwise AND operator\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "+\&",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_+\&amp;"
				},
				｢en#language/operators#132｣ => {
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_=\&gt;",
					｢name｣       => "=>",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#132\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"=>\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:«=>»(\\\$key, Mu \\\$value --> Pair:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \" constructor.\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,pair constructor\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Constructs a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \" object with the left-hand side as the key and the\\nright-hand side as the value.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note that the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"=>\",\n        )\n      ),\n      \" operator is syntactically special-cased, in that\\nit allows unquoted identifier on the left-hand side.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$p = a => 1;\\nsay \\\$p.key;         # OUTPUT: «a␤»\\nsay \\\$p.value;       # OUTPUT: «1␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"A \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \" within an argument list with an unquoted identifier on the left\\nis interpreted as a named argument.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"the Terms language documentation\",\n        ),\n        meta   => (\n          \"/language/terms#Pair\",\n        )\n      ),\n      \" for more ways to\\ncreate \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \" objects.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#027｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#027\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<^>(Any --> Range:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"upto\",\n        )\n      ),\n      \" operator.\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Prefix operators,upto operator\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces the argument to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \", and generates a range from 0 up to (but\\nexcluding) the argument.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say ^5;         # OUTPUT: «0..^5␤»\\nfor ^5 \\\{ }      # 5 iterations\\n\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "^",
					｢targ-in-fn｣ => "prefix_^",
					｢subkind｣    => "prefix",
					｢kind｣       => "operator"
				},
				｢en#language/operators#004｣ => {
					｢subkind｣    => "circumfix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#004\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"circumfix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"[ ]\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Array constructor\",\n        ),\n        meta   => (\n          \"Circumfix operators,Array constructor\",\n        )\n      ),\n      \" returns an itemized \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Array\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Array\",\n        )\n      ),\n      \" that does not flatten\\nin list context. Check this:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say .raku for [3,2,[1,0]]; # OUTPUT: «3␤2␤\\\$[1, 0]␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This array is itemized, in the sense that every element constitutes an item, as\\nshown by the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$\",\n        )\n      ),\n      \" preceding the last element of the array, the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"(list) item contextualizer\",\n        ),\n        meta   => (\n          \"/type/Any#index-entry-\\\%24_\\\%28item_contextualizer\\\%29\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "circumfix_[_]",
					｢name｣       => "[ ]"
				},
				｢en#language/operators#037｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "+<",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#037\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"+<\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:«+<»(\\\$a, \\\$b --> Int:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Integer bit shift to the left.\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,integer left bit shift operator\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_+\&lt;"
				},
				｢en#language/operators#064｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#064\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<^>(\\\$a, \\\$b --> Junction:D) is assoc<list>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"One junction operator\",\n        ),\n        meta   => (\n          \"Infix operators,One junction operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Creates a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"one\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \" from its arguments. See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \" for more\\ndetails.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "^",
					｢targ-in-fn｣ => "infix_^",
					｢kind｣       => "operator",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#129｣ => {
					｢kind｣       => "operator",
					｢name｣       => "fff^",
					｢targ-in-fn｣ => "infix_fff^",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#129\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"fff^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<fff^>(Mu \\\$a, Mu \\\$b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Like \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"fff\",\n        ),\n        meta   => (\n          \"/routine/fff\",\n        )\n      ),\n      \", except it does not return true for matches to the right\\nargument.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@list = <X A B C Y>;\\nsay \\\$_ if /A/ fff /C/ for \\\@list;   # OUTPUT: «A␤B␤C␤»\\nsay \\\$_ if /A/ fff^ /C/ for \\\@list;  # OUTPUT: «A␤B␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"For the non-sed version, see \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"ff^\",\n        ),\n        meta   => (\n          \"/routine/ff\\\$CIRCUMFLEX_ACCENT\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"This operator cannot be overloaded, as it's handled specially by the compiler.\\n\\n\",\n  )\n)"
				},
				｢en#language/operators#051｣ => {
					｢name｣       => "?^",
					｢subkind｣    => "infix",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_?^",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#051\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"?^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<?^>(Mu \\\$x = Bool::False)\\nmulti infix:<?^>(Mu \\\\a, Mu \\\\b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Boolean logical XOR operator\",\n        ),\n        meta   => (\n          \"Infix operators,Boolean logical XOR operator\",\n        )\n      ),\n      \". Coerces the argument(s) to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bool\",\n        )\n      ),\n      \"\\nand performs logical XOR on it(them): it will return True if and only if just one of\\nthe argument is True. On a single argument it behaves as identity, returning\\nthe coerced value.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#007｣ => {
					｢name｣       => "<>",
					｢subkind｣    => "postcircumfix",
					｢targ-in-fn｣ => "postcircumfix_\&lt;\&gt;",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#007\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"postcircumfix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"<>\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    \"Decontainerization operator, which extracts the value from a container and makes\\nit independent of the container type.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:skip-test(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"need to mock JSON::Tiny\"),\n        )\n      ))},\n      paragraphs => (\n        \"use JSON::Tiny;\\n\\nmy \\\$config = from-json('\\\{ \\\"files\\\": 3, \\\"path\\\": \\\"/home/some-user/raku.rakudoc\\\" }');\\nsay \\\$config.raku;      # OUTPUT: «\\\$\\\{:files(3), :path(\\\"/home/some-user/raku.rakudoc\\\")}␤»\\nmy \\\%config-hash = \\\$config<>;\\nsay \\\%config-hash.raku; # OUTPUT: «\\\{:files(3), :path(\\\"/home/some-user/raku.rakudoc\\\")}␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"It's a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Hash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Hash\",\n        )\n      ),\n      \" in both cases, and it can be used like that; however, in the\\nfirst case it was in item context, and in the second case it has been extracted\\nto its proper context.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#102｣ => {
					｢name｣       => "(==), infix ≡",
					｢targ-in-fn｣ => "infix_(==),_infix_≡",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#102\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"(==)\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"≡\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<(==)>(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Set equality operator\",\n        ),\n        meta   => (\n          \"Infix operators,Set equality operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" are \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"identical\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say (1, 2, 3) (==) (1, 3, 2); # OUTPUT: «True␤»\\nsay (1, 2, 3) ≡ (1, 2, 4); # OUTPUT: «False␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#146｣ => {
					｢name｣       => "and",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_and",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#146\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"«\",\n                closer => \"»\",\n                atoms  => (\n                  \"and\",\n                )\n              ),\n            ),\n            meta   => (\n              \"Operators,and\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"infix \\\&\\\&\",\n        ),\n        meta   => (\n          \"#infix_\\\%26\\\%26\",\n        )\n      ),\n      \", except with looser\\nprecedence.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Short-circuits so that it returns the first operand that evaluates to\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \", otherwise returns the last operand. Note that \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"and\",\n        )\n      ),\n      \" is easy\\nto misuse, see \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"traps\",\n        ),\n        meta   => (\n          \"/language/traps#Loose_Boolean_operators\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#134｣ => {
					｢targ-in-fn｣ => "prefix_so",
					｢kind｣       => "operator",
					｢name｣       => "so",
					｢subkind｣    => "prefix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#134\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"so\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<so>(Mu \\\$x --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Evaluates its argument in Boolean context (and thus collapses\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \"s), and returns the result.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#085｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#085\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"eq\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<eq>(Any,   Any)\\nmulti infix:<eq>(Str:D, Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"String equality operator\",\n        ),\n        meta   => (\n          \"Infix operators,String equality operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" (if necessary); returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if both\\nare equal.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Mnemonic: \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"equal\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_eq",
					｢subkind｣    => "infix",
					｢name｣       => "eq",
					｢kind｣       => "operator"
				},
				｢en#language/operators#116｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "||",
					｢targ-in-fn｣ => "infix_||",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#116\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"||\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the first argument that evaluates to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" in Boolean context,\\notherwise returns the last argument.\\n\\n\"\n    ),\n    \"Note that this short-circuits; i.e., if one of the arguments evaluates to a\\ntrue value, the remaining arguments are not evaluated.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub a \\\{ 0 }\\nsub b \\\{ 1 }\\nsub c \\\{ die \\\"never called\\\" };\\nsay a() || b() || c();      # OUTPUT: «1␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#061｣ => {
					｢targ-in-fn｣ => "infix_(|),_infix_∪",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#061\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"(|)\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"∪\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<(|)>(**\\\@p)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Union operator\",\n        ),\n        meta   => (\n          \"Infix operators,Union operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"'|' as in left hand side arguments 'or' right hand side arguments.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"union\",\n        )\n      ),\n      \" of all of its arguments. This creates a new\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Set\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Set\",\n        )\n      ),\n      \" that contains all the elements its arguments contain if none\\nof the arguments are a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bag\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bag\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"BagHash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/BagHash\",\n        )\n      ),\n      \",\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mix\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mix\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"MixHash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/MixHash\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say <a b d> ∪ bag(<a a b c>); # OUTPUT: «Bag(a(2) b c d)␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If any of the arguments are \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Baggy\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Baggy\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mixy\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mixy\",\n        )\n      ),\n      \",\\nthe result is a new \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bag\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bag\",\n        )\n      ),\n      \" (or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mix\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mix\",\n        )\n      ),\n      \") containing all the elements, each\\nweighted by the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"highest\",\n        )\n      ),\n      \" weight that appeared for that element.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say <a b d> ∪ bag(<a a b c>); # OUTPUT: «Bag(a(2) b c d)␤»\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "(|), infix ∪",
					｢kind｣       => "operator"
				},
				｢en#language/operators#084｣ => {
					｢kind｣       => "operator",
					｢name｣       => ">=, infix ≥",
					｢targ-in-fn｣ => "infix_\&gt;=,_infix_≥",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#084\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \">=\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"≥\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:«>=»(Int:D, Int:D)\\nmulti infix:«>=»(Num:D, Num:D)\\nmulti infix:«>=»(Real:D, Real:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Numeric greater than or equal to operator\",\n        ),\n        meta   => (\n          \"Infix operators,Numeric greater than or equal to operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Real\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Real\",\n        )\n      ),\n      \" (if necessary); returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if\\nthe first argument is larger than or equal to the second.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#065｣ => {
					｢targ-in-fn｣ => "infix_(^),_infix_⊖",
					｢name｣       => "(^), infix ⊖",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#065\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"(^)\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⊖\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<(^)>(\\\$a, \\\$b)\\nmulti infix:<(^)>(**\\\@p)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Symmetric set difference operator\",\n        ),\n        meta   => (\n          \"Infix operators,Symmetric set difference operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"symmetric set difference\",\n        )\n      ),\n      \" of all its arguments. This creates a\\nnew \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Set\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Set\",\n        )\n      ),\n      \" made up of all the elements that \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" has but \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \"\\ndoesn't and all the elements \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" has but \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" doesn't if none of the\\narguments are a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bag\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bag\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"BagHash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/BagHash\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mix\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mix\",\n        )\n      ),\n      \"\\nor \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"MixHash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/MixHash\",\n        )\n      ),\n      \". Equivalent to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"(\\\$a ∖ \\\$b) ∪ (\\\$b ∖ \\\$a)\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say <a b> (^) <b c>; # OUTPUT: «Set(a c)␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If any of the arguments are \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Baggy\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Baggy\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mixy\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mixy\",\n        )\n      ),\n      \",\\nthe result is a new \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bag\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bag\",\n        )\n      ),\n      \" (or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mix\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mix\",\n        )\n      ),\n      \").\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say <a b> ⊖ bag(<b c>); # OUTPUT: «Bag(a c)␤»\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#002｣ => {
					｢targ-in-fn｣ => "term_(_)",
					｢name｣       => "( )",
					｢subkind｣    => "term",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#002\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"term \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"( )\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"grouping operator\",\n        ),\n        meta   => (\n          \"Terms,grouping operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"An empty group \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"()\",\n        )\n      ),\n      \" creates an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"empty list\",\n        ),\n        meta   => (\n          \"/type/List#index-entry-()_(empty_list)\",\n        )\n      ),\n      \".\\nParentheses around non-empty expressions simply structure the expression, but do\\nnot have additional semantics.\\n\\n\"\n    ),\n    \"In an argument list, putting parenthesis around an argument prevents it from\\nbeing interpreted as a named argument.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi p(:\\\$a!) \\\{ say 'named'      }\\nmulti p(\\\$a)   \\\{ say 'positional' }\\np a => 1;           # OUTPUT: «named␤»\\np (a => 1);         # OUTPUT: «positional␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine"
				},
				｢en#language/operators#114｣ => {
					｢name｣       => "≼, infix ≽",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#114\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"≼\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"≽\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    \"Deprecated.  These were removed in v6.d, please use ⊆ and ⊇ operators instead.\\n\\n\",\n  )\n)",
					｢targ-in-fn｣ => "infix_≼,_infix_≽",
					｢kind｣       => "operator",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#013｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#013\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"«\",\n                closer => \"»\",\n                atoms  => (\n                  \"--\",\n                )\n              ),\n            ),\n            meta   => (\n              \"Prefix operators,prefix --\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<-->(\\\$x is rw) is assoc<non>\\n\\n\",\n      )\n    ),\n    \"Decrements its argument by one and returns the updated value.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$x = 3;\\nsay --\\\$x;   # OUTPUT: «2␤»\\nsay \\\$x;     # OUTPUT: «2␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"It works by calling the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"pred\",\n        ),\n        meta   => (\n          \"/routine/pred\",\n        )\n      ),\n      \" method (for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"predecessor\",\n        )\n      ),\n      \") on its argument,\\nwhich gives custom types the freedom to implement their own decrement\\nsemantics.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Operators,postfix increment operator\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "prefix_--",
					｢subkind｣    => "prefix",
					｢kind｣       => "operator",
					｢name｣       => "--"
				},
				｢en#language/operators#023｣ => {
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#023\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"|\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Flattens objects of type \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Capture\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Capture\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"List\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/List\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Map\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Map\",\n        )\n      ),\n      \" and\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Hash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Hash\",\n        )\n      ),\n      \" into an argument list.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub slurpee( |args )\\\{\\n    say args.raku\\n};\\nslurpee( <a b c d>, \\\{ e => 3 }, 'e' => 'f' => 33 )\\n# OUTPUT: «\\\\((\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"), \\\{:e(3)}, :e(:f(33)))␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Please see the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"signature literals page, specially the section on\\nCaptures\",\n        ),\n        meta   => (\n          \"/language/signatures#Capture_parameters\",\n        )\n      ),\n      \" for more information on the\\nsubject.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Outside of argument lists, it returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Slip\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Slip\",\n        )\n      ),\n      \", which makes\\nit flatten into the outer list. Inside \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"argument\\nlist\",\n        ),\n        meta   => (\n          \"/language/list#Argument_list_(Capture)_context\",\n        )\n      ),\n      \"\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Positional\",\n            )\n          ),\n          \"s\",\n        ),\n        meta   => (\n          \"/type/Positional\",\n        )\n      ),\n      \" are turned into positional arguments\\nand \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Associative\",\n            )\n          ),\n          \"s\",\n        ),\n        meta   => (\n          \"/type/Associative\",\n        )\n      ),\n      \" are turned into named\\narguments.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "prefix",
					｢name｣       => "|",
					｢targ-in-fn｣ => "prefix_|"
				},
				｢en#language/operators#104｣ => {
					｢name｣       => "(cont), infix ∋",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#104\")},\n      paragraphs  => (\n        \"infix (cont), infix ∋\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<(cont)>(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Membership operator\",\n        ),\n        meta   => (\n          \"Infix operators,Membership operator (cont)\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"contains\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" as an element.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"say (1,2,3) (cont) 2; # OUTPUT: «True␤»\\nsay (1, 2, 3) ∋ 4;    # OUTPUT: «False␤»\\n\",\n      )\n    ),\n    \"Since release 2020.05, ∍ is an alias for this operator.\\n\\n\",\n  )\n)",
					｢targ-in-fn｣ => "infix_(cont),_infix_∋",
					｢kind｣       => "operator",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#038｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "+>",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#038\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"+>\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:«+>»(\\\$a, \\\$b --> Int:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Integer bit shift to the right.\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,integer right bit shift operator\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_+\&gt;",
					｢kind｣       => "operator"
				},
				｢en#language/operators#099｣ => {
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#099\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"≅\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<≅>(Any, Any)\\nmulti infix:<≅>(Int:D, Int:D)\\nmulti infix:<≅>(Num:D, Num:D)\\nmulti infix:<≅>(Rational:D, Rational:D)\\nmulti infix:<≅>(Real:D, Real:D)\\nmulti infix:<≅>(Complex:D, Complex:D)\\nmulti infix:<≅>(Numeric:D, Numeric:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The approximately-equal operator \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"≅\",\n            )\n          ),\n        ),\n        meta   => (\n          \"Infix operators,≅\",\n        )\n      ),\n      \"\\ncalculates the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"relative percentage difference\",\n        ),\n        meta   => (\n          \"https://en.wikipedia.org/wiki/Relative_change\",\n        )\n      ),\n      \"\\nbetween the left-hand and right-hand\\nsides and returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if the difference is less than \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*TOLERANCE\",\n        )\n      ),\n      \"\\n(which defaults to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"1e-15\",\n        )\n      ),\n      \"). However, if either side is zero then it checks that\\nthe absolute difference between the sides is less than \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*TOLERANCE\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The ASCII equivalent of this operator is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"=~=\",\n            )\n          ),\n        ),\n        meta   => (\n          \"#infix_=~=\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"Note that this operator is not arithmetically symmetrical (doesn't do ± Δ):\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$x = 1;\\nsay (\\\$x + \\\$*TOLERANCE) ≅ \\\$x;   # OUTPUT: «False␤»\\nsay (\\\$x - \\\$*TOLERANCE) ≅ \\\$x;   # OUTPUT: «True␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"You can change \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*TOLERANCE\",\n        )\n      ),\n      \" lexically:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"\\\{\\n    my \\\$*TOLERANCE = .1;\\n    say 11 ≅ 10;        # OUTPUT: «True␤»\\n}\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note that setting \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*TOLERANCE = 0\",\n        )\n      ),\n      \" will cause all comparisons to fail.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"\\\{\\n    my \\\$*TOLERANCE = 0;\\n    say 1 ≅ 1;        # OUTPUT: «False␤»\\n}\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢name｣       => "≅",
					｢targ-in-fn｣ => "infix_≅"
				},
				｢en#language/operators#098｣ => {
					｢name｣       => "=~=",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#098\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"=~=\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The ASCII equivalent of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"≅\",\n            )\n          ),\n        ),\n        meta   => (\n          \"#infix_≅\",\n        )\n      ),\n      \", the approximately-equal operator.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_=~=",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#136｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#136\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \":\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Used as an argument separator just like infix \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \",\",\n        )\n      ),\n      \" and marks the\\nargument to its left as the invocant. That turns what would otherwise be\\na function call into a method call.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"substr('abc': 1);       # same as 'abc'.substr(1)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Infix \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\",\n        )\n      ),\n      \" is only allowed after the first argument of a non-method call. In\\nother positions, it's a syntax error.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢name｣       => ":",
					｢targ-in-fn｣ => "infix_:"
				},
				｢en#language/operators#088｣ => {
					｢targ-in-fn｣ => "infix_ge",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#088\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"ge\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<ge>(Mu,    Mu)\\nmulti infix:<ge>(Str:D, Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"String greater than or equal to operator\",\n        ),\n        meta   => (\n          \"Infix operators,String greater than or equal to operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" (if necessary); returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if\\nthe first is equal to or larger than the second, as determined by lexicographic\\ncomparison.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Mnemonic: \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"greater or equal\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "infix",
					｢name｣       => "ge",
					｢kind｣       => "operator"
				},
				｢en#language/operators#081｣ => {
					｢targ-in-fn｣ => "infix_\&lt;",
					｢name｣       => "<",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#081\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"<\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:«<»(Int:D, Int:D)\\nmulti infix:«<»(Num:D, Num:D)\\nmulti infix:«<»(Real:D, Real:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Numeric less than operator\",\n        ),\n        meta   => (\n          \"Infix operators,Numeric less than operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Real\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Real\",\n        )\n      ),\n      \" (if necessary); returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if the first argument\\nis smaller than the second.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#150｣ => {
					｢targ-in-fn｣ => "infix_orelse",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#150\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"orelse\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"orelse\",\n        )\n      ),\n      \" operator is similar to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"infix //\",\n        )\n      ),\n      \", except with looser precedence\\nand \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" aliasing.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the first defined argument, or else the last argument. Last argument\\nis returned as-is, without being checked for definedness at all.\\nShort-circuits. The result of the left side is bound to\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" for the right side, or passed as an argument if the right side is a\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Callable\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Callable\",\n        )\n      ),\n      \", whose \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"count\",\n        ),\n        meta   => (\n          \"/routine/count\",\n        )\n      ),\n      \" must be \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"0\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"1\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This operator is useful for handling \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Failure\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Failure\",\n        )\n      ),\n      \"s returned by\\nroutines since the expected value is usually \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"defined\",\n        ),\n        meta   => (\n          \"/routine/defined\",\n        )\n      ),\n      \"\\nand \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Failure\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Failure\",\n        )\n      ),\n      \" never is:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub meows \\\{ ++\\\$ < 4 ?? fail 'out of meows!' !! '🐱' }\\n\\nsub meows-processor1 \\\{ meows() orelse .return } # return handled Failure\\nsub meows-processor2 \\\{ meows() orelse fail \\\$_ } # return re-armed Failure\\nsub meows-processor3 \\\{\\n    # Use non-Failure output, or else print a message that stuff's wrong\\n    meows() andthen .say orelse ‘something's wrong’.say;\\n}\\n\\nsay \\\"\\\{.^name}, \\\{.handled}\\\"  # OUTPUT: «Failure, True␤»\\n    given meows-processor1;\\nsay \\\"\\\{.^name}, \\\{.handled}\\\"  # OUTPUT: «Failure, False␤»\\n    given meows-processor2;\\nmeows-processor3;           # OUTPUT: «something's wrong␤»\\nmeows-processor3;           # OUTPUT: «🐱␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢name｣       => "orelse"
				},
				｢en#language/operators#125｣ => {
					｢targ-in-fn｣ => "infix_ff^",
					｢name｣       => "ff^",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#125\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"ff^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<ff^>(Mu \\\$a, Mu \\\$b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Works like \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"ff\",\n        ),\n        meta   => (\n          \"/routine/ff\",\n        )\n      ),\n      \", except it does not return \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" for items matching the\\nstop condition (including items that first matched the start condition).\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@list = <X A B C Y>;\\nsay \\\$_ if /A/ ff /C/ for \\\@list;    # OUTPUT: «A␤B␤C␤»\\nsay \\\$_ if /A/ ff^ /C/ for \\\@list;   # OUTPUT: «A␤B␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The sed-like version can be found in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"fff^\",\n        ),\n        meta   => (\n          \"/routine/fff\\\$CIRCUMFLEX_ACCENT\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"This operator cannot be overloaded, as it's handled specially by the compiler.\\n\\n\",\n  )\n)",
					｢subkind｣    => "infix",
					｢kind｣       => "operator"
				},
				｢en#language/operators#015｣ => {
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#015\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"postfix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"«\",\n                closer => \"»\",\n                atoms  => (\n                  \"--\",\n                )\n              ),\n            ),\n            meta   => (\n              \"Postfix operators,postfix --\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi postfix:<-->(\\\$x is rw) is assoc<non>\\n\\n\",\n      )\n    ),\n    \"Decrements its argument by one and returns the original value.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$x = 3;\\nsay \\\$x--;   # OUTPUT: «3␤»\\nsay \\\$x;     # OUTPUT: «2␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"It works by calling the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"pred\",\n        ),\n        meta   => (\n          \"/routine/pred\",\n        )\n      ),\n      \" method (for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"predecessor\",\n        )\n      ),\n      \") on its argument,\\nwhich gives custom types the freedom to implement their own decrement\\nsemantics.\\n\\n\"\n    ),\n    \"Note that this does not necessarily return its argument;e.g., for\\nundefined values, it returns 0:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$x;\\nsay \\\$x--;   # OUTPUT: «0␤»\\nsay \\\$x;     # OUTPUT: «-1␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Decrement on \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" will decrement the number part of a string and\\nassign the resulting string to the container. An \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"is rw\",\n        )\n      ),\n      \" container is required.\\nCrossing 0 is prohibited and throws \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"X::AdHoc\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/X::AdHoc\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$filename = \\\"somefile-003.txt\\\";\\nsay \\\$filename-- for 1..3;\\n# OUTPUT: «somefile-003.txt␤somefile-002.txt␤somefile-001.txt␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "postfix_--",
					｢name｣       => "--",
					｢subkind｣    => "postfix"
				},
				｢en#language/operators#003｣ => {
					｢targ-in-fn｣ => "term_\{_}",
					｢subkind｣    => "term",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#003\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"term \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"\\\{ }\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Block\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Block\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Hash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Hash\",\n        )\n      ),\n      \" constructor. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Terms,block constructor;Terms,hash constructor\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If the content is empty, or contains a single list that starts with a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \"\\nliteral or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\%\",\n        )\n      ),\n      \"-sigiled variable, and the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$_\",\n            )\n          ),\n          \" variable\",\n        ),\n        meta   => (\n          \"/syntax/\\\$_\",\n        )\n      ),\n      \" or\\nplaceholder parameters are not used, the constructor returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Hash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Hash\",\n        )\n      ),\n      \".\\nOtherwise it constructs a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Block\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Block\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"To force construction of a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Block\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Block\",\n        )\n      ),\n      \", follow the opening brace with a semicolon.\\nTo always ensure you end up with a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Hash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Hash\",\n        )\n      ),\n      \", you can use \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\%( )\",\n        )\n      ),\n      \" coercer or\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"hash\",\n        ),\n        meta   => (\n          \"/routine/hash\",\n        )\n      ),\n      \" routine instead:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"\\\{}.^name.say;        # OUTPUT: «Hash␤»\\n\\\{;}.^name.say;       # OUTPUT: «Block␤»\\n\\n\\\{:\\\$_}.^name.say;     # OUTPUT: «Block␤»\\n\\\%(:\\\$_).^name.say;    # OUTPUT: «Hash␤»\\nhash(:\\\$_).^name.say; # OUTPUT: «Hash␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢name｣       => "\{ }"
				},
				｢en#language/operators#106｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#106\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"(<)\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⊂\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:«(<)»(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Subset of operator\",\n        ),\n        meta   => (\n          \"Infix operators,Subset of operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"strict subset\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \", i.e., that all the\\nelements of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" are elements of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" but \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is a smaller set than \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say (1,2,3) (<) (2,3,1); # OUTPUT: «False␤»\\nsay (2,3) (<) (2,3,1);   # OUTPUT: «True␤»\\nsay 4 ⊂ (1,2,3);         # OUTPUT: «False␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_(\&lt;),_infix_⊂",
					｢name｣       => "(<), infix ⊂"
				},
				｢en#language/operators#017｣ => {
					｢targ-in-fn｣ => "prefix_?",
					｢subkind｣    => "prefix",
					｢name｣       => "?",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#017\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"?\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<?>(Mu --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Boolean context operator\",\n        ),\n        meta   => (\n          \"Operators,Boolean context operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces the argument to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bool\",\n        )\n      ),\n      \" by calling the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bool\",\n        )\n      ),\n      \" method on it.\\nNote that this collapses \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \"s.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#011｣ => {
					｢subkind｣    => "postfix",
					｢targ-in-fn｣ => "postfix_,=",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#011\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"postfix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \",=\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    \"Creates an object that concatenates, in a class-dependent way, the contents of\\nthe variable on the left hand side and the expression on the right hand side:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\%a = :11a, :22b;\\n\\\%a ,= :33x;\\nsay \\\%a # OUTPUT: «\\\{a => 11, b => 22, x => 33}␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => ",="
				},
				｢en#language/operators#020｣ => {
					｢targ-in-fn｣ => "prefix_+",
					｢name｣       => "+",
					｢kind｣       => "operator",
					｢subkind｣    => "prefix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#020\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"+\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<+>(Any --> Numeric:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Numeric context operator\",\n        ),\n        meta   => (\n          \"Operators,Numeric context operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces the argument to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \" by calling the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Numeric\",\n        )\n      ),\n      \" method on it.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#075｣ => {
					｢targ-in-fn｣ => "infix_..",
					｢name｣       => "..",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#075\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"..\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<..>(\\\$a, \\\$b --> Range:D) is assoc<non>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Range operator\",\n        ),\n        meta   => (\n          \"Infix operators,Range operator\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Constructs a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Range\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Range\",\n        )\n      ),\n      \" from the arguments.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#079｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "==, infix ⩵",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#079\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"==\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⩵\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<==>(Any, Any)\\nmulti infix:<==>(Int:D, Int:D)\\nmulti infix:<==>(Num:D, Num:D)\\nmulti infix:<==>(Rational:D, Rational:D)\\nmulti infix:<==>(Real:D, Real:D)\\nmulti infix:<==>(Complex:D, Complex:D)\\nmulti infix:<==>(Numeric:D, Numeric:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Numeric equality operator\",\n        ),\n        meta   => (\n          \"Infix operators,Numeric equality operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \" (if necessary); returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \"\\nif they are equal.\\n\\n\"\n    ),\n    \"Since Rakudo version 2021.07, ⩵ is an alias for this operator.\\n\\n\",\n  )\n)",
					｢targ-in-fn｣ => "infix_==,_infix_⩵"
				},
				｢en#language/operators#072｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#072\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"unicmp\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<unicmp>(Str:D \\\\a, Str:D \\\\b --> Order:D)\\nmulti infix:<unicmp>(Pair:D \\\\a, Pair:D \\\\b --> Order:D)\\nmulti infix:<coll>(Pair:D \\\\a, Pair:D \\\\b --> Order:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Unlike the cmp operator which sorts according to codepoint, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"unicmp\",\n        )\n      ),\n      \" and\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"coll\",\n        )\n      ),\n      \" sort according to how most users would expect, that is, disregarding\\naspects of the particular character like capitalization.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say 'a' unicmp 'Z'; # OUTPUT: «Less␤»\\nsay 'a' coll 'Z';   # OUTPUT: «Less␤»\\nsay 'a' cmp 'Z';    # OUTPUT: «More␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The main difference between \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"coll\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"unicmp\",\n        )\n      ),\n      \" is that the behavior of the\\nformer can be changed by the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$*COLLATION\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/language/variables#index-entry-\\\%24*COLLATION\",\n        )\n      ),\n      \" dynamic\\nvariable.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NOTE:\",\n        )\n      ),\n      \" These are not yet implemented in the JVM.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_unicmp",
					｢name｣       => "unicmp"
				},
				｢en#language/operators#127｣ => {
					｢targ-in-fn｣ => "infix_fff",
					｢name｣       => "fff",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#127\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"fff\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<fff>(Mu \\\$a, Mu \\\$b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Performs a sed-like flipflop operation, wherein it returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \" until the\\nleft argument smartmatches against \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \", then returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" until\\nthe right argument smartmatches against \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Works similarly to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"ff\",\n        ),\n        meta   => (\n          \"/routine/ff\",\n        )\n      ),\n      \", except that it only tries one argument per\\ninvocation. That is, if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" smartmatches the left argument, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"fff\",\n        )\n      ),\n      \" will \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"not\",\n        )\n      ),\n      \"\\nthen try to match that same \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" against the right argument.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"for <AB C D B E F> \\\{\\n    say \\\$_ if /A/ fff /B/;         # OUTPUT: «AB␤C␤D␤B␤»\\n}\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The non-sed-like flipflop (which after successfully matching the left argument\\nagainst \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" will try that same \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" against the right argument and act\\naccordingly). See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"ff\",\n        ),\n        meta   => (\n          \"/routine/ff\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"This operator cannot be overloaded, as it's handled specially by the compiler.\\n\\n\",\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#073｣ => {
					｢name｣       => "leg",
					｢targ-in-fn｣ => "infix_leg",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#073\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"leg\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<leg>(Any,   Any)\\nmulti infix:<leg>(Str:D, Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"String three-way comparator\",\n        ),\n        meta   => (\n          \"Infix operators,String three-way comparator\",\n        )\n      ),\n      \". Short for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"less, equal or greater?\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" and then does a lexicographic\\ncomparison.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say 'a' leg 'b';       # OUTPUT: «Less␤»\\nsay 'a' leg 'a';       # OUTPUT: «Same␤»\\nsay 'b' leg 'a';       # OUTPUT: «More␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#097｣ => {
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_~~",
					｢kind｣       => "operator",
					｢name｣       => "~~",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#097\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"~~\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The smartmatch operator aliases the left-hand side to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \", then evaluates\\nthe right-hand side and calls \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".ACCEPTS(\\\$_)\",\n        )\n      ),\n      \" on it. The semantics are left\\nto the type of the right-hand side operand.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Here is a partial list of some of the built-in smartmatching functionality. For\\nfull details, see \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"ACCEPTS\",\n        ),\n        meta   => (\n          \"/routine/ACCEPTS\",\n        )\n      ),\n      \" documentation\\nfor the type on the right-hand side of the operator.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"table\",\n      config     => \$\{:header-row(RakuAST::IntLiteral.new(0))},\n      paragraphs => (\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,20),\n          cells          => (\n            \"Right-hand side   \",\n            \"Comparison semantics\",\n          )\n        ),\n        \"===============     ====================\",\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,20),\n          cells          => (\n            \"Mu:U              \",\n            \"type check\",\n          )\n        ),\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,20),\n          cells          => (\n            \"Str               \",\n            \"string equality\",\n          )\n        ),\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,20),\n          cells          => (\n            \"Numeric           \",\n            \"numeric equality\",\n          )\n        ),\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,20),\n          cells          => (\n            \"Regex             \",\n            \"regex match\",\n          )\n        ),\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,20),\n          cells          => (\n            \"Callable          \",\n            \"Boolean result of invocation\",\n          )\n        ),\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,20),\n          cells          => (\n            \"Set/Bag           \",\n            \"equal element values\",\n          )\n        ),\n        RakuAST::Doc::LegacyRow.new(\n          column-offsets => (0,20),\n          cells          => (\n            \"Any:D             \",\n            \"object identity\",\n          )\n        ),\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#056｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "o, infix ∘",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#056\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"o\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"∘\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<o>()\\nmulti infix:<o>(\\\&f)\\nmulti infix:<o>(\\\&f, \\\&g --> Block:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,o\",\n        )\n      ),\n      \"\\nThe \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"function composition operator\",\n        ),\n        meta   => (\n          \"Infix operators,function composition operator\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"infix:<∘>\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"infix:<o>\",\n        )\n      ),\n      \"\\ncombines two functions, so that the left function is called with the\\nreturn value of the right function. If the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".count\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/count\",\n        )\n      ),\n      \"\\nof the left function is greater than 1, the return value of the right\\nfunction will be \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"slipped\",\n        ),\n        meta   => (\n          \"/type/Slip\",\n        )\n      ),\n      \" into the left function.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Both \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".count\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".arity\",\n        )\n      ),\n      \" of the right-hand side will be maintained, as\\nwell as the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".of\",\n        )\n      ),\n      \" of the left hand side.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"sub f(\\\$p)\\\{ say 'f'; \\\$p / 2 }\\nsub g(\\\$p)\\\{ say 'g'; \\\$p * 2 }\\n\\nmy \\\&composed = \\\&f ∘ \\\&g;\\nsay composed 2; # OUTPUT: «g␤f␤2␤»\\n# equivalent to:\\nsay 2.\\\&g.\\\&f;\\n# or to:\\nsay f g 2;\\nsay \\\&composed.arity; #  OUTPUT: «1␤»\\nsay \\\&composed.count; #  OUTPUT: «1␤»\\nsay \\\&composed.of;    #  OUTPUT: «(Mu)␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"sub f(\\\$a, \\\$b, \\\$c) \\\{ [~] \\\$c, \\\$b, \\\$a }\\nsub g(\\\$str)\\\{ \\\$str.comb }\\nmy \\\&composed = \\\&f ∘ \\\&g;\\nsay composed 'abc'; # OUTPUT: «cba␤»\\n# equivalent to:\\nsay f |g 'abc';\\n\",\n      )\n    ),\n    \"The single-arg candidate returns the given argument as is. The zero-arg candidate\\nreturns an identity routine that simply returns its argument.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\&composed = [∘] \\\&uc;\\nsay composed 'foo'; # OUTPUT: «FOO␤»\\n\\nmy \\\&composed = [∘];\\nsay composed 'foo'; # OUTPUT: «foo␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_o,_infix_∘"
				},
				｢en#language/operators#100｣ => {
					｢name｣       => "(elem), infix ∈",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_(elem),_infix_∈",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#100\")},\n      paragraphs  => (\n        \"infix (elem), infix ∈\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<(elem)>(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Membership operator\",\n        ),\n        meta   => (\n          \"Infix operators,Membership operator (elem)\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"element\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"say 2 (elem) (1, 2, 3); # OUTPUT: «True␤»\\nsay 4 ∈ (1, 2, 3);      # OUTPUT: «False␤»\\n\",\n      )\n    ),\n    \"Since release 2020.05, ∊ is an alias for this operator.\\n\\n\",\n  )\n)"
				},
				｢en#language/operators#039｣ => {
					｢targ-in-fn｣ => "infix_~\&amp;",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#039\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"~\\\&\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces each argument to a non-variable-encoding string buffer type (e.g. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf8\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf16\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf32\",\n        )\n      ),\n      \")\\nand then performs a numeric bitwise AND on corresponding integers of the two buffers, padding the\\nshorter buffer with zeroes.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢name｣       => "~\&",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#143｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#143\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"listop \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"...\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Called the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"yada, yada, yada\",\n        )\n      ),\n      \" operator or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"stub\",\n        )\n      ),\n      \" operator, if it's the\\nonly statement in a routine or type, it marks that routine or type as a\\nstub (which is significant in the context of pre-declaring types and\\ncomposing roles).\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"...\",\n        )\n      ),\n      \" statement is executed, it calls \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"fail\",\n        ),\n        meta   => (\n          \"/routine/fail\",\n        )\n      ),\n      \",\\nwith the default message \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Stub code executed\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"This operator can be used for forward declarations of classes:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"class Foo \\\{...}\\nclass Bar \\\{\\n    has Foo \\\$.foo;\\n}\\nclass Foo \\\{\\n    say \\\"This is a Foo object\\\";\\n}\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"or routines, such as this \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Sub\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Sub\",\n        )\n      ),\n      \":\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"sub a() \\\{ ... }\\nsay a;           # OUTPUT: «42␤»\\nsub a() \\\{ 42 }\\n\\n\",\n      )\n    ),\n    \"Please note that, in this case, it's not really necessary, and it will work\\nthe same without that forward declaration.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Listop operators,Fatal stub operator\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢name｣       => "...",
					｢subkind｣    => "listop",
					｢targ-in-fn｣ => "listop_..."
				},
				｢en#language/operators#074｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "<=>",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#074\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"<=>\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:«<=>»(\\\$a, \\\$b --> Order:D) is assoc<non>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Numeric three-way comparator\",\n        ),\n        meta   => (\n          \"Infix operators,Numeric three-way comparator\",\n        )\n      ),\n      \".\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,spaceship operator\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Real\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Real\",\n        )\n      ),\n      \" and then does a numeric comparison.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_\&lt;=\&gt;"
				},
				｢en#language/operators#026｣ => {
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "prefix_?^",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#026\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"?^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<?^>(Mu --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Boolean bitwise negation operator\",\n        ),\n        meta   => (\n          \"Prefix operators,Boolean bitwise negation operator\",\n        )\n      ),\n      \": Coerces the argument to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bool\",\n        )\n      ),\n      \"\\nand then does a bit flip, which makes it the same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"prefix:<!>\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "prefix",
					｢name｣       => "?^"
				},
				｢en#language/operators#080｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "!=, infix ≠",
					｢targ-in-fn｣ => "infix_!=,_infix_≠",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#080\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"!=\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"≠\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<!=>(Mu, Mu --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Numeric inequality operator\",\n        ),\n        meta   => (\n          \"Infix operators,Numeric inequality operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \" (if necessary); returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if they are\\ndistinct.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Is equivalent to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"!==\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#060｣ => {
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_|",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#060\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"|\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<|>(\\\$a, \\\$b --> Junction:D) is assoc<list>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,Any junction operator\",\n        )\n      ),\n      \"\\nCreates an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"any\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \" from its arguments.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$three-letters = /<[a b c]>/ | /<[i j k]>/ | /<[x y z]>/;\\nsay \\\$three-letters.raku; # OUTPUT: «any(/<[a b c]>/, /<[i j k]>/, /<[x y z]>/)␤»\\nsay 'b' ~~ \\\$three-letters; # OUTPUT: «True␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This first creates an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"any\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \" of three regular expressions\\n(every one of them matching any of 3 letters), and then uses\\nsmartmatching to check whether the letter \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"b\",\n        )\n      ),\n      \" matches any of them,\\nresulting in a positive match. See also \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \" for more details.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "|",
					｢kind｣       => "operator"
				},
				｢en#language/operators#092｣ => {
					｢name｣       => "after",
					｢targ-in-fn｣ => "infix_after",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#092\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"after\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<after>(Any,       Any)\\nmulti infix:<after>(Real:D,    Real:D)\\nmulti infix:<after>(Str:D,     Str:D)\\nmulti infix:<after>(Version:D, Version:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Generic ordering, uses the same semantics as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"cmp\",\n        ),\n        meta   => (\n          \"/routine/cmp\",\n        )\n      ),\n      \".\\nReturns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if the first argument is larger than the second.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#147｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#147\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"«\",\n                closer => \"»\",\n                atoms  => (\n                  \"andthen\",\n                )\n              ),\n            ),\n            meta   => (\n              \"Operators,andthen\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"andthen\",\n        )\n      ),\n      \" operator returns\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Empty\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Slip#constant_Empty\",\n        )\n      ),\n      \" upon encountering the\\nfirst \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"undefined\",\n        ),\n        meta   => (\n          \"/routine/defined\",\n        )\n      ),\n      \" argument, otherwise the last\\nargument. Last argument is returned as-is, without being checked for\\ndefinedness at all. Short-circuits. The result of the left side is bound\\nto \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" for the right side, or passed as arguments if the right side is\\na \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Callable\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Callable\",\n        )\n      ),\n      \", whose \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"count\",\n        ),\n        meta   => (\n          \"/routine/count\",\n        )\n      ),\n      \" must be \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"0\",\n        )\n      ),\n      \"\\nor \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"1\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"A handy use of this operator is to alias a routine's return value to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" and\\nto do additional manipulation with it, such as printing or returning it to\\ncaller. Since the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"andthen\",\n        )\n      ),\n      \" operator short-circuits, statements on the\\nright-hand side won't get executed, unless left-hand side is defined (tip:\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Failure\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Failure\",\n        )\n      ),\n      \"s are never defined, so you can handle them with\\nthis operator).\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub load-data \\\{\\n    rand  > .5 or return; # simulated load data failure; return Nil\\n    (rand > .3 ?? 'error' !! 'good data') xx 10 # our loaded data\\n}\\nload-data.first: /good/ andthen say \\\"\\\$_ is good\\\";\\n# OUTPUT: «(good data is good)␤»\\n\\nload-data() andthen .return; # return loaded data, if it's defined\\ndie \\\"Failed to load data!!\\\";\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The above example will print \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"good data is good\",\n        )\n      ),\n      \" only if the subroutine\\nreturned any items that match \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"/good/\",\n        )\n      ),\n      \" and will die unless loading data\\nreturned a defined value. The aliasing behavior lets us pipe the values across\\nthe operator.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"andthen\",\n        )\n      ),\n      \" operator is a close relative of the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"with\",\n            )\n          ),\n          \" statement\\nmodifier\",\n        ),\n        meta   => (\n          \"/language/control#with_orwith_without\",\n        )\n      ),\n      \", and some compilers\\ncompile \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"with\",\n        )\n      ),\n      \" to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"andthen\",\n        )\n      ),\n      \", meaning these two lines have equivalent\\nbehavior:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \".say with 42;\\n42 andthen .say;\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢name｣       => "andthen",
					｢targ-in-fn｣ => "infix_andthen",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#028｣ => {
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_.=",
					｢subkind｣    => "infix",
					｢name｣       => ".=",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#028\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \".=\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    \"Calls the right-side method on the value in the left-side container,\\nreplacing the resulting value in the left-side container.\\n\\n\",\n    \"In most cases, this behaves identically to the postfix mutator, but the\\nprecedence is lower:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"my \\\$a = -5;\\nsay ++\\\$a.=abs;\\n# OUTPUT: «6␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      config     => \$\{:skip-test(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"illustrates error\"),\n        )\n      ))},\n      paragraphs => (\n        \"say ++\\\$a .= abs;\\n# OUTPUT: «Cannot modify an immutable Int␤\\n#           in block <unit> at <tmp> line 1␤␤»\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#107｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#107\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⊄\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<⊄>(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Not a subset of operator\",\n        ),\n        meta   => (\n          \"Infix operators,Not a subset of operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"not\",\n        )\n      ),\n      \" a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"strict subset\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \".  Equivalent to\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"!(<)\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say (1,2,3) ⊄ (2,3,1); # OUTPUT: «True␤»\\nsay (2,3) ⊄ (2,3,1);   # OUTPUT: «False␤»\\nsay 4 !(<) (1,2,3);    # OUTPUT: «True␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢name｣       => "⊄",
					｢targ-in-fn｣ => "infix_⊄",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#137｣ => {
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#137\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"Z\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<Z>(**\\\@lists --> Seq:D) is assoc<list>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Zip operator\",\n        ),\n        meta   => (\n          \"Infix operators,Zip operator\",\n        )\n      ),\n      \" interleaves the lists passed to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Z\",\n        )\n      ),\n      \" like a zipper,\\ntaking index-corresponding elements from each operand. The returned \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \"\\ncontains nested lists, each with a value from every operand in the chain. If\\none of the operands runs out of elements prematurely, the zip operator will\\nstop.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"say (1, 2 Z <a b c> Z <+ ->).raku;\\n# OUTPUT: «((1, \\\"a\\\", \\\"+\\\"), (2, \\\"b\\\", \\\"-\\\")).Seq␤»\\nfor <a b c> Z <1 2 3 4> -> [\\\$l, \\\$r] \\\{\\n    say \\\"\\\$l:\\\$r\\\"\\n}\\n# OUTPUT: «a:1␤b:2␤c:3␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Z\",\n        )\n      ),\n      \" operator also exists as a metaoperator, in which case the inner\\nlists are replaced by the value from applying the operator to the\\nlist:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say 100, 200 Z+ 42, 23;             # OUTPUT: «(142 223)␤»\\nsay 1..3 Z~ <a b c> Z~ 'x' xx 3;    # OUTPUT: «(1ax 2bx 3cx)␤»\\n\\n\",\n      )\n    ),\n    \"As any other infix operator, it can be used under its full name:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"say infix:<Z>(<a b>,<c d>);             # OUTPUT: «((a c) (b d))␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If no argument is given, it will return an empty \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"say infix:<Z>();                        # OUTPUT: «()␤»\\n\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,cross product operator\",\n        )\n      ),\n      \"\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,X\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_Z",
					｢name｣       => "Z"
				},
				｢en#language/operators#069｣ => {
					｢name｣       => "but",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#069\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"but\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<but>(Mu \\\$obj1, Mu   \\\$role) is assoc<non>\\nmulti infix:<but>(Mu \\\$obj1, Mu:D \\\$obj2) is assoc<non>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Creates a copy of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$obj\",\n        )\n      ),\n      \" with \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$role\",\n        )\n      ),\n      \" mixed in. Since \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$obj\",\n        )\n      ),\n      \" is not\\nmodified, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"but\",\n        )\n      ),\n      \" can be used to create immutable values with mixins.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$role\",\n        )\n      ),\n      \" supplies exactly one attribute, an initializer can be passed in\\nparentheses:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"role Answerable \\\{\\n    has \\\$.answer;\\n}\\nmy \\\$ultimate-question = 'Life, the Universe and Everything' but Answerable(42);\\nsay \\\$ultimate-question;         # OUTPUT: «Life, the Universe and Everything␤»\\nsay \\\$ultimate-question.^name;   # OUTPUT: «Str+\\\{Answerable}␤»\\nsay \\\$ultimate-question.answer;  # OUTPUT: «42␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Instead of a role, you can provide an instantiated object. In this case,\\nthe operator will create a role for you automatically. The role will contain\\na single method named the same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$obj.^name\",\n        )\n      ),\n      \" and that returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$obj\",\n        )\n      ),\n      \":\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"my \\\$forty-two = 42 but 'forty two';\\nsay \\\$forty-two+33;    # OUTPUT: «75␤»\\nsay \\\$forty-two.^name; # OUTPUT: «Int+\\\{<anon|1>}␤»\\nsay \\\$forty-two.Str;   # OUTPUT: «forty two␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Calling \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^name\",\n        )\n      ),\n      \" shows that the variable is an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \" with an anonymous object\\nmixed in. However, that object is of type \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \", so the variable, through the\\nmixin, is endowed with a method with that name, which is what we use in the last\\nsentence.\\n\\n\"\n    ),\n    \"We can also mixin classes, even created on the fly.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"my \\\$s = 12 but class Warbles \\\{ method hi \\\{ 'hello' } }.new;\\nsay \\\$s.Warbles.hi;    # OUTPUT: «hello␤»\\nsay \\\$s + 42;          # OUTPUT: «54␤»\\n\",\n      )\n    ),\n    \"To access the mixed-in class, as above, we use the class name as is shown in the\\nsecond sentence. If methods of the same name are present already, the last mixed\\nin role takes precedence. A list of methods can be provided in parentheses\\nseparated by comma. In this case conflicts will be reported at runtime.\\n\\n\",\n  )\n)",
					｢targ-in-fn｣ => "infix_but",
					｢kind｣       => "operator",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#115｣ => {
					｢targ-in-fn｣ => "infix_\&amp;\&amp;",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢name｣       => "\&\&",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#115\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"\\\&\\\&\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the first argument that evaluates to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \" in Boolean context,\\notherwise returns the last argument.\\n\\n\"\n    ),\n    \"Note that this short-circuits, i.e. if one of the arguments evaluates to a\\nfalse value, the arguments to the right are never evaluated.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub a \\\{ 1 }\\nsub b \\\{ 0 }\\nsub c \\\{ die \\\"never called\\\" };\\nsay a() \\\&\\\& b() \\\&\\\& c();      # OUTPUT: «0␤»\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#123｣ => {
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢name｣       => "ff",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#123\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"ff\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<ff>(Mu \\\$a, Mu \\\$b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Also called the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"flipflop operator\",\n        )\n      ),\n      \", compares both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" (that is,\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_ ~~ \\\$a\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_ ~~ \\\$b\",\n        )\n      ),\n      \"). Evaluates to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \" until the left-hand\\nsmartmatch is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \", at which point it evaluates to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" until the\\nright-hand smartmatch is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"In effect, the left-hand argument is the \\\"start\\\" condition and the\\nright-hand is the \\\"stop\\\" condition. This construct is typically used to\\npick up only a certain section of lines. For example:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:allow(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"V\"),\n        )\n      ))},\n      paragraphs => (\n        RakuAST::Doc::Paragraph.new(\n          \"my \\\$excerpt = q:to/END/;\\nHere's some unimportant text.\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"V\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"=\",\n            )\n          ),\n          \"begin code\\n    This code block is what we're after.\\n    We'll use 'ff' to get it.\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"V\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"=\",\n            )\n          ),\n          \"end code\\nMore unimportant text.\\nEND\\n\\nmy \\\@codelines = gather for \\\$excerpt.lines \\\{\\n    take \\\$_ if \\\"=begin code\\\" ff \\\"=end code\\\"\\n}\\n# this will print four lines, starting with \\\"=begin code\\\" and ending with\\n# \\\"=end code\\\"\\nsay \\\@codelines.join(\\\"\\\\n\\\");\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"After matching the start condition, the operator will then match the\\nsame \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" to the stop condition and act accordingly if successful. In\\nthis example, only the first element is printed:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"for <AB C D B E F> \\\{\\n    say \\\$_ if /A/ ff /B/;  # OUTPUT: «AB␤»\\n}\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If you only want to test against a start condition and have no stop\\ncondition, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"*\",\n        )\n      ),\n      \" can be used as such.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"for <A B C D E> \\\{\\n    say \\\$_ if /C/ ff *;    # OUTPUT: «C␤D␤E␤»\\n}\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"For the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"sed\",\n        )\n      ),\n      \"-like version, which does \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"not\",\n        )\n      ),\n      \" try \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$_\",\n        )\n      ),\n      \" on the stop\\ncondition after succeeding on the start condition, see \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"fff\",\n        ),\n        meta   => (\n          \"/routine/fff\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"This operator cannot be overloaded, as it's handled specially by the\\ncompiler.\\n\\n\",\n  )\n)",
					｢targ-in-fn｣ => "infix_ff"
				},
				｢en#language/operators#059｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#059\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"(.)\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⊍\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<(.)>(**\\\@p)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Baggy multiplication operator\",\n        ),\n        meta   => (\n          \"Infix operators,Baggy multiplication operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the Baggy \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"multiplication\",\n        )\n      ),\n      \" of its arguments, i.e., a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bag\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bag\",\n        )\n      ),\n      \"\\nthat contains each element of the arguments with the weights of the element\\nacross the arguments multiplied together to get the new weight.  Returns a\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mix\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mix\",\n        )\n      ),\n      \" if any of the arguments is a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mixy\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mixy\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say <a b c> (.) <a b c d>; # OUTPUT: «Bag(a b c)␤»\\n                           # Since 1 * 0 == 0, in the case of 'd'\\nsay <a a b c a d> ⊍ bag(<a a b c c>); # OUTPUT: «Bag(a(6) b c(2))␤»\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "infix",
					｢name｣       => "(.), infix ⊍",
					｢targ-in-fn｣ => "infix_(.),_infix_⊍",
					｢kind｣       => "operator"
				},
				｢en#language/operators#071｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#071\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"coll\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<coll>(Str:D \\\\a, Str:D \\\\b --> Order:D)\\nmulti infix:<coll>(Cool:D \\\\a, Cool:D \\\\b --> Order:D)\\nmulti infix:<coll>(Pair:D \\\\a, Pair:D \\\\b --> Order:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"coll\",\n        )\n      ),\n      \" is a sorting operator that takes pairs of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \"s, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Cool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Cool\",\n        )\n      ),\n      \"s or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \"s\\nand returns an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Order\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Order\",\n        )\n      ),\n      \" that uses the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*COLLATION\",\n        )\n      ),\n      \" order. The default behavior\\ndisregards diacritic marks and capitalization, for instance.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say \\\"b\\\" cmp \\\"à\\\";  # OUTPUT: «Less␤»\\nsay \\\"b\\\" coll \\\"à\\\"; # OUTPUT: «More␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"In the first case, lexicographic or codepoint order is taken into account. In\\nthe second, which uses \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"coll\",\n        )\n      ),\n      \", the diacritic is not considered and sorting\\nhappens according to intuitive order.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NOTE:\",\n        )\n      ),\n      \" These are not yet implemented in the JVM.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "infix",
					｢name｣       => "coll",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_coll"
				},
				｢en#language/operators#086｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#086\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"ne\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<ne>(Mu,    Mu)\\nmulti infix:<ne>(Str:D, Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"String inequality operator\",\n        ),\n        meta   => (\n          \"Infix operators,String inequality operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" (if necessary); returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"False\",\n        )\n      ),\n      \" if both\\nare equal.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Mnemonic: \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"not equal\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_ne",
					｢subkind｣    => "infix",
					｢name｣       => "ne",
					｢kind｣       => "operator"
				},
				｢en#language/operators#131｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#131\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"=\",\n            )\n          ),\n          \" (item assignment)\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:skip-test(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"compile-time error\"),\n        )\n      ))},\n      paragraphs => (\n        \"sub infix:<=>(Mu \\\$a is rw, Mu \\\$b)\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Called the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"item assignment operator\",\n        )\n      ),\n      \". It copies the value of the right-hand\\nside into the Scalar container on the left-hand side.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The item assignment operator should be distinguished from the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"list assignment\\noperator\",\n        ),\n        meta   => (\n          \"#infix_=_(list_assignment)\",\n        )\n      ),\n      \", which uses the same\\noperator symbol \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"=\",\n        )\n      ),\n      \" but has a lower precedence. The context of the left-hand\\nside of the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"=\",\n        )\n      ),\n      \" symbol determines whether it is parsed as item assignment or\\nlist assignment. See the section on \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"item and list\\nassignment\",\n        ),\n        meta   => (\n          \"/language/variables#Item_and_list_assignment\",\n        )\n      ),\n      \" for a comparative\\ndiscussion of the two assignment types.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "infix",
					｢name｣       => "= (item assignment)",
					｢targ-in-fn｣ => "infix_=_(item_assignment)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#052｣ => {
					｢kind｣       => "operator",
					｢name｣       => "?|",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#052\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"?|\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<?|>(Mu \\\$x = Bool::False)\\nmulti infix:<?|>(Mu \\\\a, Mu \\\\b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Boolean logical OR operator\",\n        ),\n        meta   => (\n          \"Infix operators,Boolean logical OR operator\",\n        )\n      ),\n      \". Coerces the argument(s) to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bool\",\n        )\n      ),\n      \"\\nand performs logical OR (inclusive OR) on it(them): it will return True if at least one of\\nthe argument is True. On a single argument it behaves as identity, returning\\nthe coerced value.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_?|"
				},
				｢en#language/operators#109｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#109\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⊈\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<⊈>(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Not a subset of nor equal to operator\",\n        ),\n        meta   => (\n          \"Infix operators,Not a subset of nor equal to operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"not\",\n        )\n      ),\n      \" a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"subset\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \".  Equivalent to\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"!(<=)\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say (1,2,3) ⊈ (2,3,1); # OUTPUT: «False␤»\\nsay (2,3) ⊈ (2,3,1);   # OUTPUT: «False␤»\\nsay 4 !(<=) (1,2,3);   # OUTPUT: «True␤»\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_⊈",
					｢subkind｣    => "infix",
					｢kind｣       => "operator",
					｢name｣       => "⊈"
				},
				｢en#language/operators#057｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#057\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"\\\&\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<\\\&>(\\\$a, \\\$b --> Junction:D) is assoc<list>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"All junction operator\",\n        ),\n        meta   => (\n          \"Infix operators,All junction operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Creates an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"all\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \" from its arguments. See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \" for more\\ndetails.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_\&amp;",
					｢subkind｣    => "infix",
					｢name｣       => "\&",
					｢kind｣       => "operator"
				},
				｢en#language/operators#005｣ => {
					｢kind｣       => "operator",
					｢subkind｣    => "postcircumfix",
					｢name｣       => "[ ]",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#005\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"postcircumfix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"[ ]\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub postcircumfix:<[ ]>(\\\@container, **\\\@index,\\n                        :\\\$k, :\\\$v, :\\\$kv, :\\\$p, :\\\$exists, :\\\$delete)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Universal interface for positional access to zero or more elements of\\n\\\@container, a.k.a. \\\"\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"array indexing operator\",\n        ),\n        meta   => (\n          \"Postcircumfix operators,array indexing operator;Postcircumfix operators,array subscript operator\",\n        )\n      ),\n      \"\\\".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@alphabet = 'a' .. 'z';\\nsay \\\@alphabet[0];                   # OUTPUT: «a␤»\\nsay \\\@alphabet[1];                   # OUTPUT: «b␤»\\nsay \\\@alphabet[*-1];                 # OUTPUT: «z␤»\\nsay \\\@alphabet[100]:exists;          # OUTPUT: «False␤»\\nsay \\\@alphabet[17, 0, 10, 20].join;  # OUTPUT: «raku␤»\\nsay \\\@alphabet[23 .. *].raku;        # OUTPUT: «(\\\"x\\\", \\\"y\\\", \\\"z\\\")␤»\\n\\n\\\@alphabet[1, 2] = \\\"B\\\", \\\"C\\\";\\nsay \\\@alphabet[0..3].raku;           # OUTPUT: «(\\\"a\\\", \\\"B\\\", \\\"C\\\", \\\"d\\\")␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Subscripts\",\n        ),\n        meta   => (\n          \"/language/subscripts\",\n        )\n      ),\n      \", for a more detailed explanation of this\\noperator's behavior and for how to implement support for it in custom types.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "postcircumfix_[_]"
				},
				｢en#language/operators#152｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "==>",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#152\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"==>\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"feed\",\n        ),\n        meta   => (\n          \"Infix operators,feed\",\n        )\n      ),\n      \" operator takes the result from the left and passes it to the\\nnext (right) routine as the last parameter.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"     \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@array = (1, 2, 3, 4, 5);\\n\\\@array ==> sum() ==> say();   # OUTPUT: «15␤»\\n\\n\",\n      )\n    ),\n    \"This simple example, above, is the equivalent of writing:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"     \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@array = (1, 2, 3, 4, 5);\\nsay(sum(\\\@array));             # OUTPUT: «15␤»\\n\\n\",\n      )\n    ),\n    \"Or if using methods:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"     \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@array = (1, 2, 3, 4, 5);\\n\\\@array.sum.say;               # OUTPUT: «15␤»\\n\\n\",\n      )\n    ),\n    \"The precedence is very loose so you will need to use parentheses to\\nassign the result or you can even just use another feed operator! In the\\ncase of routines/methods that take a single argument or where the first argument\\nis a block, it's often required that you call with parentheses (though this\\nis not required for the very last routine/method).\\n\\n\",\n    \"This  \\\"traditional\\\" structure, read bottom-to-top, with the last two\\nlines creating the data structure that is going to be processed\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@fractions = <TWO THREE FOUR FIVE SEVEN> »~» \\\" \\\" X~ <FIFTHS SIXTHS EIGHTHS>;\\nmy \\\@result = map \\\{ .uniparse },                    # (3) Converts to unicode\\n    grep \\\{ .uniparse },                            # (2) Checks if it parses\\n    map( \\\{\\\"VULGAR FRACTION \\\" ~ \\\$^þ }, \\\@fractions); # (1) Adds string to input\\n\\n# \\\@result is [⅖ ⅗ ⅜ ⅘ ⅚ ⅝ ⅞]\\n\\n\",\n      )\n    ),\n    \"Now we use the feed operator (left-to-right) with parentheses, read\\ntop-to-bottom\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@result = (\\n    <TWO THREE FOUR FIVE SEVEN> »~» \\\" \\\" X~ <FIFTHS SIXTHS EIGHTHS> # (1) Input\\n    ==> map( \\\{\\\"VULGAR FRACTION \\\" ~ \\\$^þ } )                         # (2) Converts to Unicode name\\n    ==> grep(\\\{ .uniparse })                                        # (3) Filters only real names\\n    ==> map( \\\{ .uniparse} );                                       # (4) Converts to unicode\\n);\\n\\n\",\n      )\n    ),\n    \"For illustration, method chaining equivalent, read top-to-bottom, using the same sequence as above\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@result = ( <TWO THREE FOUR FIVE SEVEN> »~» \\\" \\\" X~ <FIFTHS SIXTHS EIGHTHS>)\\n    .map( \\\{\\\"VULGAR FRACTION \\\" ~ \\\$^þ } )\\n    .grep(\\\{ .uniparse })\\n    .map(\\\{ .uniparse });\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Although in this particular case the result is the same, the feed operator\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"==>\",\n        )\n      ),\n      \" more clearly shows intent with arrow pointing in the direction of the\\ndata flow.  To assign without the need of parentheses use another feed operator\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"<people of earth>\\n    ==> map(\\\{ .tc })\\n    ==> grep /<[PE]>/\\n    ==> sort()\\n    ==> my \\\@result;\\n\\n\",\n      )\n    ),\n    \"It can be useful to capture a partial result, however, unlike the\\nleftward feed operator, it does require parentheses or a semicolon\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"<people of earth>\\n    ==> map(\\\{ .tc })\\n    ==> my \\\@caps; \\\@caps   # also could wrap in parentheses: (my \\\@caps)\\n    ==> grep /<[PE]>/\\n    ==> sort()\\n    ==> my \\\@result;\\n\\n\",\n      )\n    ),\n    \"The feed operator lets you construct method-chaining-like patterns out of\\nroutines and the results of methods on unrelated data. In method-chaining,\\nyou are restricted to the methods available on the data or the result of\\nprevious method call. With feed operators, that restriction is gone.\\nThe resulting code could also be seen to be more readable than a series of\\nmethod calls broken over multiple lines.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"Note: In the future, this operator will see some change as it gains the\\nability to run list operations in parallel. It will enforce that the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"left\",\n        )\n      ),\n      \" operand is enclosable as a closure (that can be cloned and run in\\na subthread).\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_==\&gt;",
					｢kind｣       => "operator"
				},
				｢en#language/operators#121｣ => {
					｢targ-in-fn｣ => "infix_minmax",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#121\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"minmax\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Range\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Range\",\n        )\n      ),\n      \" starting from the lowest to the highest of the values,\\nas determined by the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"cmp\",\n        ),\n        meta   => (\n          \"/routine/cmp\",\n        )\n      ),\n      \" semantics.\\nFor instance:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"# numeric comparison\\n10 minmax 3;     # 3..10\\n\\n# string comparison\\n'10' minmax '3'; # \\\"10\\\"..\\\"3\\\"\\n'z' minmax 'k';  # \\\"k\\\"..\\\"z\\\"\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If the lowest and highest values coincide, the operator returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Range\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Range\",\n        )\n      ),\n      \"\\nmade by the same value:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"1 minmax 1;  # 1..1\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"When applied to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"List\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/List\",\n        )\n      ),\n      \"s, the operator evaluates the lowest and highest values\\namong all available values:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"(10,20,30) minmax (0,11,22,33);       # 0..33\\n('a','b','z') minmax ('c','d','w');   # \\\"a\\\"..\\\"z\\\"\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Similarly, when applied to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Hash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Hash\",\n        )\n      ),\n      \"es, it performs a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"cmp\",\n        ),\n        meta   => (\n          \"/routine/cmp\",\n        )\n      ),\n      \" way comparison:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"my \\\%winner = points => 30, misses => 10;\\nmy \\\%loser = points => 20, misses => 10;\\n\\\%winner cmp \\\%loser;      # More\\n\\\%winner minmax \\\%loser;\\n# \\\$\\\{:misses(10), :points(20)}..\\\$\\\{:misses(10), :points(30)}\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "minmax",
					｢kind｣       => "operator"
				},
				｢en#language/operators#022｣ => {
					｢name｣       => "~",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#022\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"~\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<~>(Any --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"String context operator\",\n        ),\n        meta   => (\n          \"Prefix operators,String context operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces the argument to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" by calling the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Str\",\n        ),\n        meta   => (\n          \"/type/List#method_Str\",\n        )\n      ),\n      \" method on it.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "prefix",
					｢targ-in-fn｣ => "prefix_~"
				},
				｢en#language/operators#094｣ => {
					｢name｣       => "===",
					｢targ-in-fn｣ => "infix_===",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#094\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"===\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<===>(Any, Any)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The ASCII equivalent of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"⩶\",\n            )\n          ),\n        ),\n        meta   => (\n          \"#infix_⩶\",\n        )\n      ),\n      \", the value identity operator.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Before Rakudo version 2021.07, the ASCII variant was the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"only\",\n        )\n      ),\n      \" variant.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#019｣ => {
					｢subkind｣    => "prefix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#019\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"//\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<//>(Any --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Boolean context operator\",\n        ),\n        meta   => (\n          \"Operators,Boolean context operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"Available as of 6.e language version (early implementation exists in Rakudo\\ncompiler 2022.12+).\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces the argument to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Boolean\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bool\",\n        )\n      ),\n      \" by calling the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"defined\",\n        )\n      ),\n      \" method on it.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "//",
					｢targ-in-fn｣ => "prefix_//",
					｢kind｣       => "operator"
				},
				｢en#language/operators#112｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "(>=), infix ⊇",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_(\&gt;=),_infix_⊇",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#112\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"(>=)\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⊇\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:«(>=)»(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Superset of or equal to operator\",\n        ),\n        meta   => (\n          \"Infix operators,Superset of or equal to operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"superset\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \", i.e., that all the\\nelements of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" are elements of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" but \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is a larger or equal sized\\nset than \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say (1,2,3) (>=) (2,3,1); # OUTPUT: «True␤»\\nsay (1,2,3) (>=) (2,3);   # OUTPUT: «True␤»\\nsay 4 ⊇ (1,2,3);          # OUTPUT: «False␤»\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#105｣ => {
					｢targ-in-fn｣ => "infix_∌",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#105\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"∌\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<∌>(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Non-membership operator\",\n        ),\n        meta   => (\n          \"Infix operators,Non-membership operator (cont)\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" does \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"not\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"contain\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \".  Equivalent to\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"!(cont)\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say (1,2,3) ∌ 4;       # OUTPUT: «True␤»\\nsay (1,2,3) !(cont) 2; # OUTPUT: «False␤»\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "∌",
					｢kind｣       => "operator"
				},
				｢en#language/operators#130｣ => {
					｢name｣       => "^fff^",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_^fff^",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#130\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"^fff^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<^fff^>(Mu \\\$a, Mu \\\$b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Like \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"fff\",\n        ),\n        meta   => (\n          \"/routine/fff\",\n        )\n      ),\n      \", except it does not return true for matches to either the left or\\nright argument.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@list = <X A B C Y>;\\nsay \\\$_ if /A/ fff /C/ for \\\@list;   # OUTPUT: «A␤B␤C␤»\\nsay \\\$_ if /A/ ^fff^ /C/ for \\\@list; # OUTPUT: «B␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"For the non-sed version, see \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"^ff^\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/\\\$CIRCUMFLEX_ACCENTff\\\$CIRCUMFLEX_ACCENT\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"This operator cannot be overloaded, as it's handled specially by the compiler.\\n\\n\",\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#128｣ => {
					｢targ-in-fn｣ => "infix_^fff",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#128\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"^fff\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<^fff>(Mu \\\$a, Mu \\\$b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Like \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"fff\",\n        ),\n        meta   => (\n          \"/routine/fff\",\n        )\n      ),\n      \", except it does not return true for matches to the left argument.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@list = <X A B C Y>;\\nsay \\\$_ if /A/ fff /C/ for \\\@list;   # OUTPUT: «A␤B␤C␤»\\nsay \\\$_ if /A/ ^fff /C/ for \\\@list;  # OUTPUT: «B␤C␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"For the non-sed version, see \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"^ff\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/\\\$CIRCUMFLEX_ACCENTff\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"This operator cannot be overloaded, as it's handled specially by the compiler.\\n\\n\",\n  )\n)",
					｢name｣       => "^fff",
					｢kind｣       => "operator"
				},
				｢en#language/operators#018｣ => {
					｢name｣       => "!",
					｢targ-in-fn｣ => "prefix_!",
					｢subkind｣    => "prefix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#018\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"!\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<!>(Mu --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Negated Boolean context operator\",\n        ),\n        meta   => (\n          \"Operators,Negated Boolean context operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces the argument to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bool\",\n        )\n      ),\n      \" by calling the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bool\",\n        )\n      ),\n      \" method on it,\\nand returns the negation of the result.\\nNote that this collapses \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \"s.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#089｣ => {
					｢subkind｣    => "infix",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_lt",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#089\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"lt\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<lt>(Mu,    Mu)\\nmulti infix:<lt>(Str:D, Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"String less than operator\",\n        ),\n        meta   => (\n          \"Infix operators,String less than operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" (if necessary); returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if\\nthe first is smaller than the second, as determined by lexicographic\\ncomparison.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Mnemonic: \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"less than\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "lt"
				},
				｢en#language/operators#108｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#108\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"(<=)\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⊆\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:«(<=)»(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Subset of or equal to operator\",\n        ),\n        meta   => (\n          \"Infix operators,Subset of or equal to operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"subset\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \", i.e., that all the\\nelements of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" are elements of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" but \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is a smaller or equal sized\\nset than \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say (1,2,3) (<=) (2,3,1); # OUTPUT: «True␤»\\nsay (2,3) (<=) (2,3,1);   # OUTPUT: «True␤»\\nsay 4 ⊆ (1,2,3);          # OUTPUT: «False␤»\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "(<=), infix ⊆",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_(\&lt;=),_infix_⊆"
				},
				｢en#language/operators#119｣ => {
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#119\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"min\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the smallest of the arguments, as determined by \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"cmp\",\n        ),\n        meta   => (\n          \"/routine/cmp\",\n        )\n      ),\n      \" semantics.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$foo = 42;\\n\\\$foo min= 0   # read as: \\\$foo decreases to 0\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Note:\",\n        )\n      ),\n      \" Before 2022.06, in the cases of ties \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\&min\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Any#routine_min\",\n        )\n      ),\n      \"\\nwould return the first argument with that value, whereas \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\&[min]\",\n        )\n      ),\n      \" would return\\nits RHS. After 2022.06, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\&[min]\",\n        )\n      ),\n      \" returns its LHS in the case of ties, and now\\nboth return the same value as dictated by their List associativity.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say min 0, False; # OUTPUT: «0␤»\\nsay 0 min False;  # OUTPUT: «0␤»\\nsay min False, 0; # OUTPUT: «False␤»\\nsay False min 0;  # OUTPUT: «False␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_min",
					｢subkind｣    => "infix",
					｢name｣       => "min"
				},
				｢en#language/operators#101｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#101\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"∉\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<∉>(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Non-membership operator\",\n        ),\n        meta   => (\n          \"Infix operators,Non-membership operator (elem)\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"not\",\n        )\n      ),\n      \" an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"element\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \".  Equivalent to\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"!(elem)\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"say 4 ∉ (1, 2, 3);       # OUTPUT: «True␤»\\nsay 2 !(elem) (1, 2, 3); # OUTPUT: «False␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢name｣       => "∉",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_∉"
				},
				｢en#language/operators#047｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#047\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"+|\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<+|>(\\\$a, \\\$b --> Int:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Integer bitwise OR operator\",\n        ),\n        meta   => (\n          \"Infix operators,Integer bitwise OR operator\",\n        )\n      ),\n      \": Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \" and\\ndoes a bitwise \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"OR\",\n        )\n      ),\n      \" (inclusive OR) operation.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "infix",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_+|",
					｢name｣       => "+|"
				},
				｢en#language/operators#145｣ => {
					｢name｣       => "???",
					｢targ-in-fn｣ => "listop_???",
					｢subkind｣    => "listop",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#145\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"listop \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"???\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    \"If it's the only statement in a routine or type, it marks that routine\\nor type as a stub (which is significant in the context of pre-declaring\\ntypes and composing roles).\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"If the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"???\",\n        )\n      ),\n      \" statement is executed, it calls \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"warn\",\n        ),\n        meta   => (\n          \"/routine/warn\",\n        )\n      ),\n      \",\\nwith the default message \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Stub code executed\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#067｣ => {
					｢targ-in-fn｣ => "prefix_let",
					｢name｣       => "let",
					｢subkind｣    => "prefix",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#067\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"let\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub prefix:<let>(Mu \\\$a is rw)\\n\\n\",\n      )\n    ),\n    \"Refers to a variable in an outer scope whose value will be restored if the block\\nexits unsuccessfully, implying that the block returned a defined object.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"my \\\$name = \\\"Jane Doe\\\";\\n\\n\\\{\\n    let \\\$name = prompt(\\\"Say your name \\\");\\n    die if !\\\$name;\\n    CATCH \\\{\\n        default \\\{ say \\\"No name entered\\\" }\\n    }\\n    say \\\"We have \\\$name\\\";\\n}\\n\\nsay \\\"We got \\\$name\\\";\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This code provides a default name for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$name\",\n        )\n      ),\n      \". If the user exits from the\\nprompt or simply does not provide a valid input for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$name\",\n        )\n      ),\n      \"; \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"let\",\n        )\n      ),\n      \" will\\nrestore the default value provided at the top. If user input is valid, it will\\nkeep that.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type        => \"comment\",\n      abbreviated => True,\n      paragraphs  => (\n        \"this is duplicated in variables.pod\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#117｣ => {
					｢targ-in-fn｣ => "infix_^^",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#117\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"^^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Short-circuit exclusive-or\",\n        ),\n        meta   => (\n          \"Infix operators,Short-circuit exclusive-or\",\n        )\n      ),\n      \". Returns the true argument if there\\nis one (and only one). Returns the last argument if all arguments are false.\\nReturns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \" when more than one argument is true.\\n\\n\"\n    ),\n    \"This operator short-circuits in the sense that it does not evaluate\\nany arguments after a 2nd true result.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say 0 ^^ 42;                             # OUTPUT: «42␤»\\nsay '' ^^ 0;                             # OUTPUT: «0␤»\\nsay 0 ^^ 42 ^^ 1 ^^ die \\\"never called\\\";  # OUTPUT: «Nil␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note that the semantics of this operator may not be what you assume: infix \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"^^\",\n        )\n      ),\n      \"\\nflips to the first true value it finds and then flips to Nil \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"forever\",\n        )\n      ),\n      \" after the\\nsecond, no matter how many more true values there are. (In other words, it has\\n\\\"find the one true value\\\" semantics, not \\\"Boolean parity\\\" semantics.)\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "^^"
				},
				｢en#language/operators#058｣ => {
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_(\&amp;),_infix_∩",
					｢name｣       => "(\&), infix ∩",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#058\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"(\\\&)\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"∩\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<(\\\&)>(**\\\@p)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Intersection operator\",\n        ),\n        meta   => (\n          \"Infix operators,Intersection operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"'\\\&' as in left hand side arguments 'and' right hand side arguments.\\nReturns the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"intersection\",\n        )\n      ),\n      \" of all of its arguments. This creates a new\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Set\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Set\",\n        )\n      ),\n      \" that contains only the elements common to all of the\\narguments if none of the arguments are a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bag\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bag\",\n        )\n      ),\n      \",\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"BagHash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/BagHash\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mix\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mix\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"MixHash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/MixHash\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say <a b c> (\\\&) <b c d>; # OUTPUT: «Set(b c)␤»\\nsay <a b c d> ∩ <b c d e> ∩ <c d e f>; # OUTPUT: «Set(c d)␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If any of the arguments are \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Baggy\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Baggy\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mixy\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mixy\",\n        )\n      ),\n      \",\\nthe result is a new \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bag\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bag\",\n        )\n      ),\n      \" (or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Mix\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Mix\",\n        )\n      ),\n      \") containing the common elements, each\\nweighted by the largest \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"common\",\n        )\n      ),\n      \" weight (which is the minimum of the weights\\nof that element over all arguments).\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say <a a b c a> (\\\&) bag(<a a b c c>); # OUTPUT: «Bag(a(2) b c)␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#049｣ => {
					｢name｣       => "~|",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#049\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"~|\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces each argument to a non-variable-encoding string buffer type (e.g. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf8\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf16\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf32\",\n        )\n      ),\n      \")\\nand then performs a numeric bitwise OR on corresponding integers of the two buffers, padding the\\nshorter buffer with zeroes.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_~|"
				},
				｢en#language/operators#076｣ => {
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#076\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"..^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<..^>(\\\$a, \\\$b --> Range:D) is assoc<non>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Right-open range operator\",\n        ),\n        meta   => (\n          \"Infix operators,Right-open range operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Constructs a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Range\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Range\",\n        )\n      ),\n      \" from the arguments, excluding the end point.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_..^",
					｢subkind｣    => "infix",
					｢name｣       => "..^"
				},
				｢en#language/operators#029｣ => {
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_.",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#029\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \".\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    \"Calls the following method (whose name must be alphabetic) on the left-side\\ninvocant.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"Note that the infix form of the operator has a slightly lower precedence\\nthan postfix \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \".meth\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say -5.abs;      # like: -(5.abs)\\n# OUTPUT: «-5␤»\\nsay -5 . abs;    # like: (-5) . abs\\n# OUTPUT: «5␤»\\nsay -5 .abs;     # following whitespace is optional\\n# OUTPUT: «5␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "."
				},
				｢en#language/operators#045｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#045\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"+\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<+>(\\\$a, \\\$b --> Numeric:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Addition operator\",\n        ),\n        meta   => (\n          \"Infix operators,Addition operator\",\n        )\n      ),\n      \": Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \" and\\nadds them. From version 6.d it works also on \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Duration\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Duration\",\n        )\n      ),\n      \",\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"DateTime\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/DateTime\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Real\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Real\",\n        )\n      ),\n      \" types.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_+",
					｢subkind｣    => "infix",
					｢kind｣       => "operator",
					｢name｣       => "+"
				},
				｢en#language/operators#139｣ => {
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_...",
					｢name｣       => "...",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#139\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"...\",\n            )\n          ),\n          \"\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Infix operators,...\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Infix operators,...^\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Infix operators,^...\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Infix operators,^...^\",\n            )\n          ),\n          \"\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Infix operators,…\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Infix operators,…^\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Infix operators,^…\",\n            )\n          ),\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            meta   => (\n              \"Infix operators,^…^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<...>(**\\\@) is assoc<list>\\nmulti infix:<...^>(**\\\@) is assoc<list>\\nmulti infix:<^...>(**\\\@) is assoc<list>\\nmulti infix:<^...^>(**\\\@) is assoc<list>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"sequence operator\",\n        ),\n        meta   => (\n          \"Infix operators,sequence operator\",\n        )\n      ),\n      \", which can be written either as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"...\",\n        )\n      ),\n      \" or as\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"…\",\n        )\n      ),\n      \", with variants \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"...^\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^...\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^...^\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"…^\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^…\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^…^\",\n        )\n      ),\n      \",\\nwill produce (possibly lazy) generic sequences on demand. Such sequences\\nare of the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \" type.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The variants of the operator with an initial caret, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^...\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^...^\",\n        )\n      ),\n      \",\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^…\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^…^\",\n        )\n      ),\n      \", produce sequences that do not contain the initial\\nelement.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The variants of the operator with a final caret, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"...^\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^...^\",\n        )\n      ),\n      \",\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"…^\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^…^\",\n        )\n      ),\n      \", produce sequences that do not contain the final\\nelement.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note: the variants \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^...\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^...^\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^…\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"^…^\",\n        )\n      ),\n      \" have been\\navailable in Rakudo compiler starting from 2020.05 release.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The left-hand side of the operator specify the initial elements; it may include a\\ngenerator after the first element or elements. The right-hand side will\\nhave an endpoint, which can be \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Inf\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"*\",\n        )\n      ),\n      \" for \\\"infinite\\\" lists (that is,\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"lazy\",\n        )\n      ),\n      \" lists whose elements are only produced on demand), an expression which\\nwill end the sequence when \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \", or other elements such as\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Junction\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Junction\",\n        )\n      ),\n      \"s.\\n\\n\"\n    ),\n    \"The sequence operator invokes the generator with as many arguments as necessary.\\nThe arguments are taken from the initial elements and the already generated\\nelements.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"An endpoint of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"*\",\n        )\n      ),\n      \" (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Whatever\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Whatever\",\n        )\n      ),\n      \"), \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Inf\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"∞\",\n        )\n      ),\n      \"\\ngenerates on demand an infinite sequence, with a default generator of\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"*.succ\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say (1 ... *)[^5];  # OUTPUT: «(1 2 3 4 5)␤»\\n\\n\",\n      )\n    ),\n    \"Custom generators need to be the last element of the list before the\\n'...' operator. This one takes two arguments, and generates the\\neight first Fibonacci numbers\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"say (1, 1, -> \\\$a, \\\$b \\\{ \\\$a + \\\$b } ... *)[^8]; # OUTPUT: «(1 1 2 3 5 8 13 21)␤»\\n# same but shorter\\nsay (1, 1, * + * ... *)[^8];                 # OUTPUT: «(1 1 2 3 5 8 13 21)␤»\\n\\n\",\n      )\n    ),\n    \"The generator can also take only one argument.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say 5, \\\{ \\\$_ * 2 } ... 40;                # OUTPUT: «5 10 20 40␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Or it can use the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"anonymous state variable\\n\",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\$\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/language/variables#index-entry-\\\$_(variable)\",\n        )\n      ),\n      \" to skip one position in\\nthe sequence when computing the next one:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say (1, 1, 1, -> \\\$a, \\\$b, \\\$ \\\{ \\\$a + \\\$b } … ∞)[3..10];\\n# OUTPUT: «(2 2 3 4 5 7 9 12)␤»\\n\\n\",\n      )\n    ),\n    \"There must be at least as many initial elements as arguments to the\\ngenerator.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"If the endpoint is not \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"*\",\n        )\n      ),\n      \", it's smartmatched against each generated\\nelement and the sequence is terminated when the smartmatch succeeded.\\nThe final element is excluded of the sequence if a sequence operator\\nvariant with a final caret is used, it is included otherwise.\\n\\n\"\n    ),\n    \"This allows you to write\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say 1, 1, * + * ...^ *>= 100;\\n# OUTPUT: «(1 1 2 3 5 8 13 21 34 55 89)␤»\\n\\n\",\n      )\n    ),\n    \"to generate all Fibonacci numbers up to but excluding 100.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"...\",\n        )\n      ),\n      \" operators consider the initial values as \\\"generated elements\\\" as\\nwell, so they are also checked against the endpoint:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$end = 4;\\nsay 1, 2, 4, 8, 16 ... \\\$end;\\n# OUTPUT: «(1 2 4)␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If you do not provide a generator, the sequence operator tries to deduce the\\nsequence.  In most cases, this means using a default \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"*.\",\n        )\n      ),\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"succ\",\n        ),\n        meta   => (\n          \"/routine/succ\",\n        )\n      ),\n      \"\\nor \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"*.\",\n        )\n      ),\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"pred\",\n        ),\n        meta   => (\n          \"/routine/pred\",\n        )\n      ),\n      \", depending on how the end points compare:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say 1 ... 4;        # OUTPUT: «(1 2 3 4)␤»\\nsay 4 ... 1;        # OUTPUT: «(4 3 2 1)␤»\\nsay 1 ^... 4;       # OUTPUT: «(2 3 4)␤»\\nsay 1 ...^ 4;       # OUTPUT: «(1 2 3)␤»\\nsay 1 ^...^ 4;      # OUTPUT: «(2 3)␤»\\nsay 'a' ... 'e';    # OUTPUT: «(a b c d e)␤»\\nsay 'e' ... 'a';    # OUTPUT: «(e d c b a)␤»\\n\\n\",\n      )\n    ),\n    \"However, the sequence operator will deduce a different sequence in some special\\ncases.\\n\\n\",\n    \"If you provide more than one initial element and all initial elements are\\nnumeric, the sequence operator tries find an arithmetic or geometric sequence\\nthat fits the pattern in the initial elements:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say 2, 4, 6 ... 12;     # OUTPUT: «(2 4 6 8 10 12)␤»\\nsay 1, 2, 4 ... 32;     # OUTPUT: «(1 2 4 8 16 32)␤»\\nsay 1, 2, 4 ^... 32;    # OUTPUT: «(2 4 8 16 32)␤»\\nsay 1, 2, 4 ^...^ 32;   # OUTPUT: «(2 4 8 16)␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If you provide one \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" initial element and a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" final element with the\\nsame number of characters, then the sequence operator will deduce a sequence of\\nall strings where each letter is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"le\",\n        )\n      ),\n      \" the letter at the corresponding position\\nin the final element:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say 'aa' … 'cc';          # OUTPUT: «(aa ab ac ba bb bc ca cb cc)␤»\\n# Which is the same as\\nsay 'a'..'c' X~ 'a'..'c'; # OUTPUT: «(aa ab ac ba bb bc ca cb cc)␤»\\n\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#066｣ => {
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#066\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"temp\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub prefix:<temp>(Mu \\\$a is rw)\\n\\n\",\n      )\n    ),\n    \"\\\"temporizes\\\" the variable passed as the argument. The variable begins\\nwith the same value as it had in the outer scope, but can be assigned\\nnew values in this scope. Upon exiting the scope, the variable will be\\nrestored to its original value.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$a = \\\"three\\\";\\nsay \\\$a; # OUTPUT: «three␤»\\n\\\{\\n    temp \\\$a;\\n    say \\\$a; # OUTPUT: «three␤»\\n    \\\$a = \\\"four\\\";\\n    say \\\$a; # OUTPUT: «four␤»\\n}\\nsay \\\$a; # OUTPUT: «three␤»\\n\\n\",\n      )\n    ),\n    \"You can also assign immediately as part of the call to temp:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      config     => \$\{:preamble(RakuAST::QuotedString.new(\n        processors => <words val>,\n        segments   => (\n          RakuAST::StrLiteral.new(\"my \\\$a\"),\n        )\n      ))},\n      paragraphs => (\n        \"temp \\\$a = \\\"five\\\";\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Be warned the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"temp\",\n        )\n      ),\n      \" effects get removed once the block is left. If\\nyou were to access the value from, say, within a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Promise\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Promise\",\n        )\n      ),\n      \" after\\nthe \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"temp\",\n        )\n      ),\n      \" was undone, you'd get the original value, not the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"temp\",\n        )\n      ),\n      \" one:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"my \\\$v = \\\"original\\\";\\n\\\{\\n    temp \\\$v = \\\"new one\\\";\\n    start \\\{\\n        say \\\"[PROMISE] Value before block is left: `\\\$v`\\\";\\n        sleep 1;\\n        say \\\"[PROMISE] Block was left while we slept; value is now `\\\$v`\\\";\\n    }\\n    sleep ½;\\n    say \\\"About to leave the block; value is `\\\$v`\\\";\\n}\\nsay \\\"Left the block; value is now `\\\$v`\\\";\\nsleep 2;\\n\\n# OUTPUT:\\n# [PROMISE] Value before block is left: `new one`\\n# About to leave the block; value is `new one`\\n# Left the block; value is now `original`\\n# [PROMISE] Block was left while we slept; value is now `original`\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "temp",
					｢subkind｣    => "prefix",
					｢targ-in-fn｣ => "prefix_temp"
				},
				｢en#language/operators#034｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#034\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"\\\%\\\%\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<\\\%\\\%>(\\\$a, \\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Divisibility operator\",\n        ),\n        meta   => (\n          \"Infix operators,Divisibility operator\",\n        )\n      ),\n      \". Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a \\\% \\\$b == 0\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_\%\%",
					｢subkind｣    => "infix",
					｢kind｣       => "operator",
					｢name｣       => "\%\%"
				},
				｢en#language/operators#144｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#144\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"listop \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"!!!\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    \"If it's the only statement in a routine or type, it marks that routine\\nor type as a stub (which is significant in the context of pre-declaring\\ntypes and composing roles).\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"If the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"!!!\",\n        )\n      ),\n      \" statement is executed, it calls \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"die\",\n        ),\n        meta   => (\n          \"/routine/die\",\n        )\n      ),\n      \", with\\nthe default message \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Stub code executed\",\n        )\n      ),\n      \".\\n\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Operators,Admonitory stub operator\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢name｣       => "!!!",
					｢kind｣       => "operator",
					｢subkind｣    => "listop",
					｢targ-in-fn｣ => "listop_!!!"
				},
				｢en#language/operators#113｣ => {
					｢name｣       => "⊉",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#113\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"⊉\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<⊉>(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Not a superset of nor equal to operator\",\n        ),\n        meta   => (\n          \"Infix operators,Not a superset of nor equal to operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"not\",\n        )\n      ),\n      \" a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"superset\",\n        )\n      ),\n      \" of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \".  Equivalent to\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"!(>=)\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say (1,2,3) ⊉ (2,3,1); # OUTPUT: «False␤»\\nsay (1,2,3) ⊉ (2,3);   # OUTPUT: «False␤»\\nsay 4 !(>=) (1,2,3);   # OUTPUT: «True␤»\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_⊉",
					｢kind｣       => "operator"
				},
				｢en#language/operators#041｣ => {
					｢name｣       => "~>",
					｢targ-in-fn｣ => "infix_~\&gt;",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#041\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"~>\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces the left argument to a non-variable-encoding string buffer type (e.g. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf8\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf16\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf32\",\n        )\n      ),\n      \")\\nand then performs a numeric bitwise right shift on the bits of the buffer.\\n\\n\"\n    ),\n    \"Please note that this has not yet been implemented.\\n\\n\",\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#082｣ => {
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#082\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"<=\",\n            )\n          ),\n          \", infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"≤\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:«<=»(Int:D, Int:D)\\nmulti infix:«<=»(Num:D, Num:D)\\nmulti infix:«<=»(Real:D, Real:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Numeric less than or equal to operator\",\n        ),\n        meta   => (\n          \"Infix operators,Numeric less than or equal to operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Real\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Real\",\n        )\n      ),\n      \" (if necessary); returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if the first argument\\nis smaller than or equal to the second.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_\&lt;=,_infix_≤",
					｢name｣       => "<=, infix ≤"
				},
				｢en#language/operators#046｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#046\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"-\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<->(\\\$a, \\\$b --> Numeric:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Subtraction operator\",\n        ),\n        meta   => (\n          \"Infix operators,Subtraction operator\",\n        )\n      ),\n      \": Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \"\\nand subtracts the second from the\\nfirst. From version 6.d it works also on \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Duration\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Duration\",\n        )\n      ),\n      \",\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"DateTime\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/DateTime\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Real\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Real\",\n        )\n      ),\n      \" types.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "-",
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_-",
					｢subkind｣    => "infix"
				},
				｢en#language/operators#140｣ => {
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_=_(list_assignment)",
					｢subkind｣    => "infix",
					｢name｣       => "= (list assignment)",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#140\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"=\",\n            )\n          ),\n          \" (list assignment)\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The list assignment operator generally copies values from its right-hand side\\ninto the container on its left-hand side. Its exact semantics are left to the\\nleft-hand side container type. See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Array\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Array\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Hash\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Hash\",\n        )\n      ),\n      \"\\nfor common cases.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The list assignment operator should be distinguished from the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"item assignment\\noperator\",\n        ),\n        meta   => (\n          \"#infix_=_(item_assignment)\",\n        )\n      ),\n      \", which uses the same\\noperator symbol \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"=\",\n        )\n      ),\n      \" but has a higher precedence. The context of the left-hand\\nside of the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"=\",\n        )\n      ),\n      \" symbol determines whether it is parsed as item assignment or\\nlist assignment. See the section on \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"item and list\\nassignment\",\n        ),\n        meta   => (\n          \"/language/variables#Item_and_list_assignment\",\n        )\n      ),\n      \" for a comparative\\ndiscussion of the two assignment types.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#010｣ => {
					｢name｣       => "( )",
					｢subkind｣    => "postcircumfix",
					｢targ-in-fn｣ => "postcircumfix_(_)",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#010\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"postcircumfix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"( )\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"call operator\",\n        ),\n        meta   => (\n          \"Operators,call operator\",\n        )\n      ),\n      \" treats the invocant as a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Callable\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Callable\",\n        )\n      ),\n      \" and invokes it,\\nusing the expression between the parentheses as arguments.\\n\\n\"\n    ),\n    \"Note that an identifier followed by a pair of parentheses is always parsed as a\\nsubroutine call.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"If you want your objects to respond to the call operator,\\nimplement a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"method CALL-ME\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/CALL-ME\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#language/operators#050｣ => {
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#050\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"~^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces each argument to a non-variable-encoding string buffer type (e.g. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf8\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf16\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"buf32\",\n        )\n      ),\n      \")\\nand then performs a numeric bitwise XOR on corresponding integers of the two buffers, padding the\\nshorter buffer with zeroes.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_~^",
					｢subkind｣    => "infix",
					｢name｣       => "~^"
				},
				｢en#language/operators#024｣ => {
					｢name｣       => "+^",
					｢kind｣       => "operator",
					｢subkind｣    => "prefix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#024\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"prefix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"+^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi prefix:<+^>(Any --> Int:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Integer bitwise negation operator\",\n        ),\n        meta   => (\n          \"Prefix operators,Integer bitwise negation operator\",\n        )\n      ),\n      \": converts the number to binary using as\\nmany bytes as needed by the number plus one; flips all bits and returns the\\nresult assuming it is a\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"two's complement\",\n        ),\n        meta   => (\n          \"https://en.wikipedia.org/wiki/Two\\\%27s_complement\",\n        )\n      ),\n      \"\\nrepresentation.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"say +^255; # OUTPUT: «-256␤»\\n\\n\",\n      )\n    ),\n    \"In this case, 255 is 11111111 and would need a single byte. We use the\\nrepresentation in bytes needed for this value plus one, converting it to 0000\\n0000 1111 1111. Bitwise negation turns it into 1111 1111 0000 0000 and this\\nis the representation in two's complement of -256, which is returned.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"say +^1;        # OUTPUT: «-2␤»\\nsay +^(-256);   # OUTPUT: «255␤»\\n\\n\",\n      )\n    ),\n    \"Negative numbers are assumed to be represented as two's complements, and thus\\ncircle back to the original number.\\n\\n\",\n  )\n)",
					｢targ-in-fn｣ => "prefix_+^"
				},
				｢en#language/operators#103｣ => {
					｢name｣       => "≢",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_≢",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#103\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"≢\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<≢>(\\\$a,\\\$b --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Set inequality operator\",\n        ),\n        meta   => (\n          \"Infix operators,Set inequality operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" are \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"not identical\",\n        )\n      ),\n      \".  Equivalent to\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"!(==)\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"code\",\n      paragraphs => (\n        \"say (1, 2, 3) ≢ (1, 2, 4); # OUTPUT: «True␤»\\nsay (1, 2, 3) ≢ (1, 3, 2); # OUTPUT: «False␤»\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#014｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#014\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"postfix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"X\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              RakuAST::Doc::Markup.new(\n                letter => \"C\",\n                opener => \"«\",\n                closer => \"»\",\n                atoms  => (\n                  \"++\",\n                )\n              ),\n            ),\n            meta   => (\n              \"Postfix operators,postfix ++\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi postfix:<++>(\\\$x is rw) is assoc<non>\\n\\n\",\n      )\n    ),\n    \"Increments its argument by one and returns the original value.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$x = 3;\\nsay \\\$x++;   # OUTPUT: «3␤»\\nsay \\\$x;     # OUTPUT: «4␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"It works by calling the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"succ\",\n        ),\n        meta   => (\n          \"/routine/succ\",\n        )\n      ),\n      \" method (for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"I\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"successor\",\n        )\n      ),\n      \") on its argument,\\nwhich gives custom types the freedom to implement their own increment\\nsemantics; when undefined, it sets the value to 1 and returns it.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$x;\\n\\\$x++;\\nsay \\\$x;     # OUTPUT: «1␤»\\n\\n\",\n      )\n    ),\n    \"Note that this does not necessarily return its argument; e.g., for\\nundefined values, it returns 0:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$x;\\nsay \\\$x++;   # OUTPUT: «0␤»\\nsay \\\$x;     # OUTPUT: «1␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Increment on \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" will increment the number part of a string and\\nassign the resulting string to the container. An \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"is rw\",\n        )\n      ),\n      \" container is required.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$filename = \\\"somefile-001.txt\\\";\\nsay \\\$filename++ for 1..3;\\n# OUTPUT: «somefile-001.txt␤somefile-002.txt␤somefile-003.txt␤»\\n\\n\",\n      )\n    ),\n    \"This will act on any Unicode numeral:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"my \\\$was٧ = \\\"ثمانية٧\\\";\\n\\\$was٧++;\\nsay \\\$was٧; # OUTPUT: «ثمانية٨␤»\\n\\n\",\n      )\n    ),\n    \"Including, since version 6.d, Thai numerals\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"my \\\$เลขไทย=\\\"๙๙\\\";\\n\\\$เลขไทย++;\\nsay \\\$เลขไทย; # OUTPUT: «๑๐๐␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Operators,postfix decrement operator\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢name｣       => "++",
					｢targ-in-fn｣ => "postfix_++",
					｢subkind｣    => "postfix"
				},
				｢en#language/operators#016｣ => {
					｢name｣       => "**",
					｢targ-in-fn｣ => "infix_**",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#016\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"**\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<**>(Any, Any --> Numeric:D) is assoc<right>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"exponentiation operator\",\n        ),\n        meta   => (\n          \"Operators,exponentiation operator\",\n        )\n      ),\n      \" coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \"\\nand calculates the left-hand-side raised to the power of the right-hand side.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If the right-hand side is a non-negative integer and the left-hand side\\nis an arbitrary precision type (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \", \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"FatRat\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/FatRat\",\n        )\n      ),\n      \"), then the calculation\\nis carried out without loss of precision.\\n\\n\"\n    ),\n    \"Unicode superscripts will behave in exactly the same way.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub squared( Int \\\$num ) \\\{ \\\$num² };\\nsay squared(\\\$_) for ^5; # OUTPUT: «0␤1␤4␤9␤16␤»\\n\\n\",\n      )\n    ),\n    \"It also works for sequences of several Unicode superscript numbers:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub twenty-second-power( Int \\\$num ) \\\{ \\\$num²² };\\nsay twenty-second-power(\\\$_) for ^5; # OUTPUT: «0␤1␤4194304␤31381059609␤17592186044416␤»\\n\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#126｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#126\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"^ff^\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<^ff^>(Mu \\\$a, Mu \\\$b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Works like \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"ff\",\n        ),\n        meta   => (\n          \"/routine/ff\",\n        )\n      ),\n      \", except it does not return \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" for items matching either\\nthe stop or start condition (or both).\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\@list = <X A B C Y>;\\nsay \\\$_ if /A/ ff /C/ for \\\@list;    # OUTPUT: «A␤B␤C␤»\\nsay \\\$_ if /A/ ^ff^ /C/ for \\\@list;  # OUTPUT: «B␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The sed-like version can be found in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"^fff^\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/\\\$CIRCUMFLEX_ACCENTfff\\\$CIRCUMFLEX_ACCENT\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"This operator cannot be overloaded, as it's handled specially by the compiler.\\n\\n\",\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_^ff^",
					｢name｣       => "^ff^"
				},
				｢en#language/operators#054｣ => {
					｢targ-in-fn｣ => "infix_xx",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#054\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"xx\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<xx>()\\nmulti infix:<xx>(Mu \\\\x)\\nmulti infix:<xx>(\\\&x, Num:D() \\\$n)\\nmulti infix:<xx>(\\\&x, Whatever)\\nmulti infix:<xx>(\\\&x, Bool:D \\\$b)\\nmulti infix:<xx>(\\\&x, Int:D \\\$n)\\nmulti infix:<xx>(Mu \\\\x, Num:D() \\\$n)\\nmulti infix:<xx>(Mu \\\\x, Whatever)\\nmulti infix:<xx>(Mu \\\\x, Bool:D \\\$b)\\nmulti infix:<xx>(Mu \\\\x, Int:D \\\$n)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"List repetition operator\",\n        ),\n        meta   => (\n          \"Infix operators,List repetition operator\",\n        )\n      ),\n      \"\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"In general, it returns a Sequence of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" repeated and evaluated \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" times\\n(\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" is coerced to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \"). If \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"\\\$b <= 0\",\n        )\n      ),\n      \", the empty list is\\nreturned. It will return an error with no operand, and return the operand itself\\nwith a single operand. An exception \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"X::Numeric::CannotConvert\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/X::Numeric::CannotConvert\",\n        )\n      ),\n      \" will be\\nthrown if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"-Inf\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NaN\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"The left-hand side is evaluated for each repetition, so\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say [1, 2] xx 5;\\n# OUTPUT: «([1 2] [1 2] [1 2] [1 2] [1 2])␤»\\n\\n\",\n      )\n    ),\n    \"returns five distinct arrays (but with the same content each time), and\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"rand xx 3\\n\\n\",\n      )\n    ),\n    \"returns three pseudo random numbers that are determined independently.\\n\\n\",\n    RakuAST::Doc::Paragraph.new(\n      \"The right-hand side can be \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"*\",\n        )\n      ),\n      \", in which case a lazy, infinite list is\\nreturned. If it's a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Bool\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Bool\",\n        )\n      ),\n      \", a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \" with a single element is returned if it's\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "xx"
				},
				｢en#language/operators#053｣ => {
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#053\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"x\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"sub infix:<x>(\\\$a, \\\$b --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"String repetition operator\",\n        ),\n        meta   => (\n          \"Infix operators,String repetition operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Repeats the string \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" times, if necessary coercing \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a\",\n        )\n      ),\n      \" to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \"\\nand \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \". Returns an empty string if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"\\\$b <= 0\",\n        )\n      ),\n      \". An exception\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"X::Numeric::CannotConvert\",\n        )\n      ),\n      \" will be thrown if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"-Inf\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NaN\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say 'ab' x 3;           # OUTPUT: «ababab␤»\\nsay 42 x 3;             # OUTPUT: «424242␤»\\n\\nmy \\\$a = 'a'.IO;\\nmy \\\$b = 3.5;\\nsay \\\$a x \\\$b;            # OUTPUT: «aaa␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "x",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_x"
				},
				｢en#language/operators#142｣ => {
					｢targ-in-fn｣ => "infix_::=",
					｢name｣       => "::=",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#142\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"::=\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Read-only binding operator\",\n        ),\n        meta   => (\n          \"Infix operators,Read-only binding operator\",\n        )\n      ),\n      \", not yet implemented in Rakudo.\\nSee \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"infix :=\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/:=\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Listop operators,stub operator\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator"
				},
				｢en#language/operators#120｣ => {
					｢targ-in-fn｣ => "infix_max",
					｢kind｣       => "operator",
					｢name｣       => "max",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#120\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"max\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the largest of the arguments, as determined by \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"cmp\",\n        ),\n        meta   => (\n          \"/routine/cmp\",\n        )\n      ),\n      \" semantics.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my \\\$foo = -42;\\n\\\$foo max= 0   # read as: \\\$foo increases to 0\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Note:\",\n        )\n      ),\n      \" Before 2022.06, in the cases of ties \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"\\\&max\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Any#routine_max\",\n        )\n      ),\n      \"\\nwould return the first argument with that value, whereas \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\&[max]\",\n        )\n      ),\n      \" would return\\nits RHS. After 2022.06, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\&[max]\",\n        )\n      ),\n      \" returns its LHS in the case of ties, and now\\nboth return the same value as dictated by their List associativity.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say max 0, False; # OUTPUT: «0␤»\\nsay 0 max False;  # OUTPUT: «0␤»\\nsay max False, 0; # OUTPUT: «False␤»\\nsay False max 0;  # OUTPUT: «False␤»\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#096｣ => {
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#096\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"=:=\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<=:=>(Mu \\\\a, Mu \\\\b)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Container identity operator\",\n        ),\n        meta   => (\n          \"Infix operators,Container identity operator\",\n        )\n      ),\n      \". Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if both arguments are bound to the same\\ncontainer. If it returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \", it generally means that modifying one will\\nalso modify the other.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"my (\\\$a, \\\$b) = (1, 3);\\nsay \\\$a =:= \\\$b;      # OUTPUT: «False␤»\\n\\\$b = 2;\\nsay \\\$a;             # OUTPUT: «1␤»\\n\\\$b := \\\$a;\\nsay \\\$a =:= \\\$b;      # OUTPUT: «True␤»\\n\\\$a = 5;\\nsay \\\$b;             # OUTPUT: «5␤»\\n\\n\",\n      )\n    ),\n    \"The single argument version, called as a routine, will always return True:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"say infix:<=:=>(42);    # OUTPUT: «True␤»\\nsay infix:<=:=>(False); # OUTPUT: «True␤»\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,smartmatch operator\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_=:=",
					｢name｣       => "=:="
				},
				｢en#language/operators#077｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "^..",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#077\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"^..\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<^..>(\\\$a, \\\$b --> Range:D) is assoc<non>\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Left-open range operator\",\n        ),\n        meta   => (\n          \"Infix operators,Left-open range operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Constructs a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Range\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Range\",\n        )\n      ),\n      \" from the arguments, excluding the start point.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_^..",
					｢kind｣       => "operator"
				},
				｢en#language/operators#149｣ => {
					｢name｣       => "or",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#149\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"or\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Same as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"||\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/||\",\n        )\n      ),\n      \", except with looser precedence.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the first argument that evaluates to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" in Boolean context, or\\notherwise the last argument, it short-circuits. Please note that \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"or\",\n        )\n      ),\n      \" is easy\\nto misuse. See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"traps\",\n        ),\n        meta   => (\n          \"/language/traps#Loose_Boolean_operators\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,orelse\",\n        )\n      ),\n      \"\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_or",
					｢kind｣       => "operator"
				},
				｢en#language/operators#030｣ => {
					｢subkind｣    => "infix",
					｢name｣       => "*",
					｢kind｣       => "operator",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#030\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"*\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<*>(Any, Any --> Numeric:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Multiplication operator\",\n        ),\n        meta   => (\n          \"Infix operators,Multiplication operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \" and multiplies them. The result\\nis of the wider type. See \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \" for details.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "infix_*"
				},
				｢en#language/operators#043｣ => {
					｢name｣       => "gcd",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#043\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"gcd\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<gcd>(\\\$a, \\\$b --> Int:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both arguments to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \" and returns the greatest common divisor.\",\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        meta   => (\n          \"Infix operators,greatest common divisor operator\",\n        )\n      ),\n      \"\\nIf one of its arguments is 0, the other is returned (when both arguments are 0, the operator returns 0).\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢targ-in-fn｣ => "infix_gcd"
				},
				｢en#language/operators#070｣ => {
					｢name｣       => "cmp",
					｢targ-in-fn｣ => "infix_cmp",
					｢kind｣       => "operator",
					｢subkind｣    => "infix",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#070\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"cmp\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:<cmp>(Any,       Any)\\nmulti infix:<cmp>(Real:D,    Real:D)\\nmulti infix:<cmp>(Str:D,     Str:D)\\nmulti infix:<cmp>(Version:D, Version:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Generic, \\\"smart\\\" three-way comparator\",\n        ),\n        meta   => (\n          \"Infix operators,Generic three-way comparator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Compares strings with string semantics, numbers\\nwith number semantics, \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \" objects first by key and then by value etc.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a eqv \\\$b\",\n        )\n      ),\n      \", then \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$a cmp \\\$b\",\n        )\n      ),\n      \" always returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Order::Same\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say (a => 3) cmp (a => 4);   # OUTPUT: «Less␤»\\nsay 4        cmp 4.0;        # OUTPUT: «Same␤»\\nsay 'b'      cmp 'a';        # OUTPUT: «More␤»\\n\\n\",\n      )\n    ),\n    \"Strings are compared codepoint by codepoint; if leading codepoints are the\\nsame, the result of comparing the first differing codepoint is returned or\\nthe longer string if their lengths differ.\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"\\\"abcd\\\" cmp \\\"abcde\\\";    # OUTPUT: «Less␤»\\n\\\"abcd \\\" cmp \\\"abcde\\\";   # OUTPUT: «Less␤»\\n'A' cmp 'Ẳ';           # OUTPUT: «Less␤»\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#language/operators#031｣ => {
					｢kind｣       => "operator",
					｢targ-in-fn｣ => "infix_/",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#language/operators#031\")},\n      paragraphs  => (\n        RakuAST::Doc::Paragraph.new(\n          \"infix \",\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"«\",\n            closer => \"»\",\n            atoms  => (\n              \"/\",\n            )\n          ),\n          \"\\n\\n\"\n        ),\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"multi infix:</>(Any, Any --> Numeric:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"X\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Division operator\",\n        ),\n        meta   => (\n          \"Infix operators,Division operator\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Coerces both argument to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \" and divides the left through the right\\nnumber. Division of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \" values returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Rat\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Rat\",\n        )\n      ),\n      \", otherwise the \\\"wider type\\\"\\nrule described in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Numeric\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Numeric\",\n        )\n      ),\n      \" holds.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Note there is also \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"div\",\n            )\n          ),\n        ),\n        meta   => (\n          \"#infix_div\",\n        )\n      ),\n      \" for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Int\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Int\",\n        )\n      ),\n      \" division.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "/",
					｢subkind｣    => "infix"
				}
			},
			｢modified｣   => "Instant.from-posix(1740907940.596644627)",
			｢type｣       => "primary",
			｢xtrk-targs｣ => {},
			｢config｣     => {
				｢category｣ => "fundamental",
				｢kind｣     => "Language",
				｢subkind｣  => "Language"
			}
		},
		｢routine/listen｣                    => {
			｢subtitle｣ => "From: en/type/IO/Socket/Async, en/type/IO/Socket/Async.",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢modified｣ => "Instant.from-posix(1742118642.353255605)",
			｢type｣     => "composite",
			｢title｣    => "The <b>listen</b> routine"
		},
		｢routine/write｣                     => {
			｢modified｣ => "Instant.from-posix(1742118642.475033199)",
			｢title｣    => "The <b>write</b> routine",
			｢config｣   => {
				｢kind｣  => "routine",
				｢index｣ => False
			},
			｢subtitle｣ => "From: en/type/IO/Socket, en/type/IO/Socket/Async, en/type/IO/Socket/Async.",
			｢type｣     => "composite"
		},
		｢operator/%2B%5E｣                   => {
			｢title｣    => "The <b>+^</b> operator",
			｢modified｣ => "Instant.from-posix(1742118639.443027293)",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "operator"
			},
			｢subtitle｣ => "From: en/language/operators, en/language/operators.",
			｢type｣     => "composite"
		},
		｢operator/%3F%5E｣                   => {
			｢subtitle｣ => "From: en/language/operators, en/language/operators.",
			｢type｣     => "composite",
			｢title｣    => "The <b>?^</b> operator",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "operator"
			},
			｢modified｣ => "Instant.from-posix(1742118639.61038828)"
		},
		｢operator/%2B%2B｣                   => {
			｢modified｣ => "Instant.from-posix(1742118640.23346965)",
			｢subtitle｣ => "From: en/language/operators, en/language/operators.",
			｢title｣    => "The <b>++</b> operator",
			｢type｣     => "composite",
			｢config｣   => {
				｢kind｣  => "operator",
				｢index｣ => False
			}
		},
		｢operator/...｣                      => {
			｢subtitle｣ => "From: en/language/operators, en/language/operators.",
			｢title｣    => "The <b>...</b> operator",
			｢config｣   => {
				｢kind｣  => "operator",
				｢index｣ => False
			},
			｢modified｣ => "Instant.from-posix(1742118640.033925226)",
			｢type｣     => "composite"
		},
		｢routine/lines｣                     => {
			｢title｣    => "The <b>lines</b> routine",
			｢type｣     => "composite",
			｢modified｣ => "Instant.from-posix(1742118640.428532024)",
			｢subtitle｣ => "From: en/type/IO/Socket/INET, en/type/IO/CatHandle.",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			}
		},
		｢routine/new｣                       => {
			｢title｣    => "The <b>new</b> routine",
			｢modified｣ => "Instant.from-posix(1742118640.381082852)",
			｢subtitle｣ => "From: en/type/IO/Special, en/type/IO/Socket/INET, en/type/IO/CatHandle.",
			｢type｣     => "composite",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			}
		},
		｢introduction｣                      => {
			｢subtitle｣   => "Introductory material, tutorials and migration guides for users familiar with other languages.",
			｢defns｣      => {},
			｢index｣      => {},
			｢xtrk-targs｣ => {},
			｢title｣      => "Introduction to Raku",
			｢config｣     => {
				｢page-content-columns｣ => True,
				｢no-glossary｣          => True
			},
			｢type｣       => "glue",
			｢toc｣        => [
				{
						｢numeration｣ => "",
						｢caption｣    => (
							"Getting",
							"started"
						),
						｢target｣     => "Getting_started",
						｢level｣      => 1
				},
				{
						｢level｣      => 1,
						｢numeration｣ => "",
						｢caption｣    => (
							"Migration",
							"guides"
						),
						｢target｣     => "Migration_guides"
				},
				{
						｢caption｣    => "Tutorials",
						｢target｣     => "Tutorials",
						｢numeration｣ => "",
						｢level｣      => 1
				}
			],
			｢modified｣   => "Instant.from-posix(1741016460.368613487)"
		},
		｢routine/rootdir｣                   => {
			｢modified｣ => "Instant.from-posix(1742118641.521654646)",
			｢type｣     => "composite",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢title｣    => "The <b>rootdir</b> routine",
			｢subtitle｣ => "From: en/type/IO/Spec/Win32, en/type/IO/Spec/Unix."
		},
		｢types｣                             => {
			｢modified｣   => "Instant.from-posix(1741016413.258264583)",
			｢title｣      => "Documented Types",
			｢config｣     => {
				｢no-glossary｣          => True,
				｢page-content-columns｣ => True
			},
			｢xtrk-targs｣ => {},
			｢toc｣        => [
				{
						｢target｣     => "Basic_classes",
						｢caption｣    => (
							"Basic",
							"classes"
						),
						｢level｣      => 1,
						｢numeration｣ => ""
				},
				{
						｢level｣      => 1,
						｢target｣     => "Composite_classes",
						｢numeration｣ => "",
						｢caption｣    => (
							"Composite",
							"classes"
						)
				},
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢caption｣    => (
							"Domain-specific",
							"classes"
						),
						｢target｣     => "Domain-specific_classes"
				},
				{
						｢caption｣    => (
							"Exception",
							"classes"
						),
						｢target｣     => "Exception_classes",
						｢level｣      => 1,
						｢numeration｣ => ""
				},
				{
						｢target｣     => "Metamodel_classes",
						｢numeration｣ => "",
						｢caption｣    => (
							"Metamodel",
							"classes"
						),
						｢level｣      => 1
				},
				{
						｢target｣     => "Basic_enums",
						｢level｣      => 1,
						｢caption｣    => (
							"Basic",
							"enums"
						),
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢caption｣    => (
							"Domain-specific",
							"enums"
						),
						｢target｣     => "Domain-specific_enums"
				},
				{
						｢caption｣    => (
							"Module",
							"modules"
						),
						｢level｣      => 1,
						｢target｣     => "Module_modules",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => (
							"Basic",
							"roles"
						),
						｢target｣     => "Basic_roles",
						｢level｣      => 1,
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => (
							"Composite",
							"roles"
						),
						｢level｣      => 1,
						｢target｣     => "Composite_roles"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "Domain-specific_roles",
						｢caption｣    => (
							"Domain-specific",
							"roles"
						),
						｢level｣      => 1
				},
				{
						｢target｣     => "Exception_roles",
						｢level｣      => 1,
						｢numeration｣ => "",
						｢caption｣    => (
							"Exception",
							"roles"
						)
				},
				{
						｢numeration｣ => "",
						｢target｣     => "Metamodel_roles",
						｢caption｣    => (
							"Metamodel",
							"roles"
						),
						｢level｣      => 1
				}
			],
			｢defns｣      => {},
			｢type｣       => "glue",
			｢index｣      => {},
			｢subtitle｣   => "Built-in types"
		},
		｢routine/tmpdir｣                    => {
			｢type｣     => "composite",
			｢modified｣ => "Instant.from-posix(1742118641.160762748)",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢subtitle｣ => "From: en/type/IO/Spec/Cygwin, en/type/IO/Spec/Win32, en/type/IO/Spec/Unix.",
			｢title｣    => "The <b>tmpdir</b> routine"
		},
		｢type/IO/Spec/QNX｣                  => {
			｢modified｣   => "Instant.from-posix(1716570626.140091333)",
			｢subtitle｣   => "Platform specific operations on file and directory paths QNX",
			｢config｣     => {
				｢subkind｣  => "class",
				｢kind｣     => "Type",
				｢category｣ => "domain-specific"
			},
			｢xtrk-targs｣ => {},
			｢title｣      => "class IO::Spec::QNX",
			｢index｣      => {},
			｢toc｣        => [
				{
						｢target｣     => "Methods",
						｢level｣      => 1,
						｢numeration｣ => "",
						｢caption｣    => "Methods"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method canonpath",
						｢target｣     => "method_canonpath",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "Class relation diagram",
						｢level｣      => 1,
						｢target｣     => "Class_relation_diagram",
						｢numeration｣ => ""
				}
			],
			｢type｣       => "primary",
			｢defns｣      => {
				｢en#type/IO/Spec/QNX#001｣ => {
					｢targ-in-fn｣ => "method_canonpath",
					｢subkind｣    => "method",
					｢name｣       => "canonpath",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/QNX#001\")},\n      paragraphs  => (\n        \"method canonpath\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method canonpath(Str() \\\$path, :\\\$parent --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a string that is a canonical representation of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \". If \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$parent\",\n        )\n      ),\n      \"\\nis set to true, will also clean up references to parent directories. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NOTE:\",\n        )\n      ),\n      \"\\nthe routine does not access the filesystem, so no symlinks are followed.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::QNX.canonpath(\\\"foo//../bar/../ber\\\").say;\\n# OUTPUT: «foo/../bar/../ber␤»\\n\\nIO::Spec::QNX.canonpath(\\\"foo///./../bar/../ber\\\").say;\\n# OUTPUT: «foo/../bar/../ber␤»\\n\\nIO::Spec::QNX.canonpath(\\\"foo///./../bar/../ber\\\", :parent).say;\\n# OUTPUT: «ber␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine"
				}
			}
		},
		｢routine/catpath｣                   => {
			｢config｣   => {
				｢kind｣  => "routine",
				｢index｣ => False
			},
			｢title｣    => "The <b>catpath</b> routine",
			｢type｣     => "composite",
			｢subtitle｣ => "From: en/type/IO/Spec/Cygwin, en/type/IO/Spec/Win32, en/type/IO/Spec/Unix.",
			｢modified｣ => "Instant.from-posix(1742118640.723793797)"
		},
		｢routine/catfile｣                   => {
			｢subtitle｣ => "From: en/type/IO/Spec/Win32, en/type/IO/Spec/Unix.",
			｢type｣     => "composite",
			｢config｣   => {
				｢index｣ => False,
				｢kind｣  => "routine"
			},
			｢modified｣ => "Instant.from-posix(1742118640.746159474)",
			｢title｣    => "The <b>catfile</b> routine"
		},
		｢type/IO/Socket｣                    => {
			｢title｣      => "role IO::Socket",
			｢modified｣   => "Instant.from-posix(1730070864.910096394)",
			｢xtrk-targs｣ => {},
			｢index｣      => {},
			｢defns｣      => {
				｢en#type/IO/Socket#008｣ => {
					｢name｣       => "native-descriptor",
					｢targ-in-fn｣ => "method_native-descriptor",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket#008\")},\n      paragraphs  => (\n        \"method native-descriptor\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method native-descriptor()\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This returns a value that the operating system would understand as a \\\"socket descriptor\\\" and\\nis suitable for passing to a native function that requires a socket descriptor as an\\nargument such as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"setsockopt\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#type/IO/Socket#001｣ => {
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket#001\")},\n      paragraphs  => (\n        \"method recv\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method recv(IO::Socket:D: Cool \\\$elems = Inf, :\\\$bin)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Receive a packet and return it, either as a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Blob\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Blob\",\n        )\n      ),\n      \" if\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":bin\",\n        )\n      ),\n      \" was passed, or a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" if not.\\nReceives up to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$elems\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"65535\",\n        )\n      ),\n      \" (whichever is smaller) bytes or characters.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"If the socket has previously been read from in non-\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":bin\",\n        )\n      ),\n      \" mode, it's not always\\nsafe to read from it in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":bin\",\n        )\n      ),\n      \" mode again. Depending on the decoder it's\\npossible for the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":bin\",\n        )\n      ),\n      \" read to skip over bytes that the decoder has read\\nahead messing up the order of bytes and chars. This effect can occur with the\\nUTF-8 decoder and if the previously decoded char could still receive combiners.\\n\\n\"\n    ),\n    \"In Rakudo versions prior to 2024.07 mixing of binary and non-binary reads is\\nunsupported.\\n\\n\",\n    \"Fails if the socket is not connected.\\n\\n\",\n  )\n)",
					｢name｣       => "recv",
					｢targ-in-fn｣ => "method_recv",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Socket#005｣ => {
					｢name｣       => "write",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket#005\")},\n      paragraphs  => (\n        \"method write\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method write(IO::Socket:D: Blob:D \\\$buf)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Writes the supplied buffer to the socket, thus sending it to other end of the\\nconnection. The string version is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"method print\",\n        ),\n        meta   => (\n          \"#method print\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"Fails if the socket is not connected.\\n\\n\",\n  )\n)",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_write"
				},
				｢en#type/IO/Socket#007｣ => {
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_close",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket#007\")},\n      paragraphs  => (\n        \"method close\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method close(IO::Socket:D)\\n\\n\",\n      )\n    ),\n    \"Closes the socket.\\n\\n\",\n    \"Fails if the socket is not connected.\\n\\n\",\n  )\n)",
					｢subkind｣    => "method",
					｢name｣       => "close"
				},
				｢en#type/IO/Socket#004｣ => {
					｢targ-in-fn｣ => "method_print",
					｢subkind｣    => "method",
					｢name｣       => "print",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket#004\")},\n      paragraphs  => (\n        \"method print\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method print(IO::Socket:D: Str(Cool) \\\$string)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Writes the supplied string to the socket, thus sending it to other end of the\\nconnection. The binary version is \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"method write\",\n        ),\n        meta   => (\n          \"#method write\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    \"Fails if the socket is not connected.\\n\\n\",\n  )\n)",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Socket#003｣ => {
					｢subkind｣    => "routine",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket#003\")},\n      paragraphs  => (\n        \"routine get\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method get(IO::Socket:D: --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Reads a single line of input from the socket, removing the trailing newline\\ncharacters (as set by \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \".nl-in\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/nl-in\",\n        )\n      ),\n      \"). Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Nil\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Nil\",\n        )\n      ),\n      \", if no\\nmore input is available.\\n\\n\"\n    ),\n    \"Fails if the socket is not connected.\\n\\n\",\n  )\n)",
					｢name｣       => "get",
					｢targ-in-fn｣ => "routine_get"
				},
				｢en#type/IO/Socket#006｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket#006\")},\n      paragraphs  => (\n        \"method put\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method put(IO::Socket:D: Str(Cool) \\\$string)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Writes the supplied string, with a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\\n\",\n        )\n      ),\n      \" appended to it,\\nto the socket, thus sending it to other end of the connection.\\n\\n\"\n    ),\n    \"Fails if the socket is not connected.\\n\\n\",\n  )\n)",
					｢targ-in-fn｣ => "method_put",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢name｣       => "put"
				},
				｢en#type/IO/Socket#002｣ => {
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢name｣       => "read",
					｢targ-in-fn｣ => "method_read",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket#002\")},\n      paragraphs  => (\n        \"method read\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method read(IO::Socket:D: Int(Cool) \\\$bytes)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Reads \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$bytes\",\n        )\n      ),\n      \" bytes from the socket and returns them in a\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Blob\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Blob\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The same caveat of mixed binary and non-binary reads described in\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"method recv\",\n        ),\n        meta   => (\n          \"#method recv\",\n        )\n      ),\n      \" applies.\\n\\n\"\n    ),\n    \"Fails if the socket is not connected.\\n\\n\",\n  )\n)"
				}
			},
			｢config｣     => {
				｢subkind｣  => "role",
				｢category｣ => "domain-specific",
				｢kind｣     => "Type"
			},
			｢toc｣        => [
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢target｣     => "Methods",
						｢caption｣    => "Methods"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "method recv",
						｢target｣     => "method_recv",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "method_read",
						｢level｣      => "2",
						｢caption｣    => "method read"
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "routine get",
						｢level｣      => "2",
						｢target｣     => "routine_get"
				},
				{
						｢target｣     => "method_print",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢caption｣    => "method print"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method write",
						｢numeration｣ => "",
						｢target｣     => "method_write"
				},
				{
						｢target｣     => "method_put",
						｢numeration｣ => "",
						｢caption｣    => "method put",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "method close",
						｢target｣     => "method_close",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "method native-descriptor",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_native-descriptor"
				},
				{
						｢level｣      => 1,
						｢numeration｣ => "",
						｢target｣     => "Class_relation_diagram",
						｢caption｣    => "Class relation diagram"
				}
			],
			｢subtitle｣   => "Network socket",
			｢type｣       => "primary"
		},
		｢type/IO/Socket/Async｣              => {
			｢subtitle｣   => "Asynchronous socket in TCP or UDP",
			｢type｣       => "primary",
			｢toc｣        => [
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢target｣     => "Methods",
						｢caption｣    => "Methods"
				},
				{
						｢target｣     => "method_connect",
						｢caption｣    => "method connect",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢target｣     => "method_connect-path",
						｢caption｣    => "method connect-path",
						｢level｣      => "2"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method listen",
						｢target｣     => "method_listen",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "method_listen-path",
						｢caption｣    => "method listen-path",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method udp",
						｢target｣     => "method_udp"
				},
				{
						｢caption｣    => "method bind-udp",
						｢target｣     => "method_bind-udp",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "method print",
						｢target｣     => "method_print",
						｢level｣      => "2",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method print-to",
						｢target｣     => "method_print-to",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "2",
						｢target｣     => "method_write",
						｢caption｣    => "method write",
						｢numeration｣ => ""
				},
				{
						｢caption｣    => "method write-to",
						｢level｣      => "2",
						｢target｣     => "method_write-to",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_Supply",
						｢caption｣    => "method Supply"
				},
				{
						｢caption｣    => "method close",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_close"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "method_socket-host",
						｢caption｣    => "method socket-host",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "method peer-host",
						｢target｣     => "method_peer-host",
						｢numeration｣ => "",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_socket-port",
						｢caption｣    => "method socket-port"
				},
				{
						｢target｣     => "method_peer-port",
						｢level｣      => "2",
						｢caption｣    => "method peer-port",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method native-descriptor",
						｢numeration｣ => "",
						｢target｣     => "method_native-descriptor"
				},
				{
						｢caption｣    => "Class relation diagram",
						｢numeration｣ => "",
						｢target｣     => "Class_relation_diagram",
						｢level｣      => 1
				}
			],
			｢title｣      => "class IO::Socket::Async",
			｢index｣      => {},
			｢defns｣      => {
				｢en#type/IO/Socket/Async#010｣ => {
					｢subkind｣    => "method",
					｢name｣       => "write-to",
					｢targ-in-fn｣ => "method_write-to",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#010\")},\n      paragraphs  => (\n        \"method write-to\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method write-to(IO::Socket::Async:D: Str() \\\$host, Int() \\\$port, Blob \\\$b --> Promise)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This is the equivalent of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"write\",\n        )\n      ),\n      \" for UDP sockets that have been\\ncreated with the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"udp\",\n        )\n      ),\n      \" method. It will try send a UDP message comprised\\nof the bytes in the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Blob\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Blob\",\n        )\n      ),\n      \"  \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" to the specified \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$host\",\n        )\n      ),\n      \"\\nand \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$port\",\n        )\n      ),\n      \" returning a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Promise\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Promise\",\n        )\n      ),\n      \" that will be kept when\\nthe data is successfully sent or broken if it was unable to send the\\ndata. In order to send to a broadcast address the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":broadcast\",\n        )\n      ),\n      \" flag\\nmust have been specified when the socket was created.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#type/IO/Socket/Async#011｣ => {
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#011\")},\n      paragraphs  => (\n        \"method Supply\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method Supply(:\\\$bin, :\\\$buf = buf8.new --> Supply)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Supply\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Supply\",\n        )\n      ),\n      \" which can be tapped to obtain the data read from\\nthe connected \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Socket::Async\",\n        )\n      ),\n      \" as it arrives.  By default the data\\nwill be emitted as characters, but if the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":bin\",\n        )\n      ),\n      \" adverb is provided a\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Buf\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Buf\",\n        )\n      ),\n      \" of bytes will be emitted instead, optionally in this\\ncase you can provide your own \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Buf\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Buf\",\n        )\n      ),\n      \" with the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":buf\",\n        )\n      ),\n      \" named parameter.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"A UDP socket in character mode will treat each packet as a complete\\nmessage and decode it. In the event of a decoding error, the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Supply\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Supply\",\n        )\n      ),\n      \"\\nwill \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"quit\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"On the other hand, a TCP socket treats the incoming packets as part of a\\nstream, and feeds the incoming bytes into a streaming decoder. It then\\nemits whatever characters the decoder considers ready. Since strings\\nwork at grapheme level in Raku, this means that only known complete\\ngraphemes will be emitted. For example, if the UTF-8 encoding were\\nbeing used and the last byte in the packet decoded to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"a\",\n        )\n      ),\n      \", this would\\nnot be emitted since the next packet may include a combining character\\nthat should form a single grapheme together with the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"a\",\n        )\n      ),\n      \". Control\\ncharacters (such as \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\\n\",\n        )\n      ),\n      \") always serve as grapheme boundaries, so any\\ntext-based protocols that use newlines or null bytes as terminators\\nwill not need special consideration. A TCP socket will also \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"quit\",\n        )\n      ),\n      \"\\nupon a decoding error.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "Supply",
					｢targ-in-fn｣ => "method_Supply"
				},
				｢en#type/IO/Socket/Async#017｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#017\")},\n      paragraphs  => (\n        \"method native-descriptor\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method native-descriptor(--> Int)\\n\\n\",\n      )\n    ),\n    \"Returns the file descriptor of this socket.\\n\\n\",\n  )\n)",
					｢name｣       => "native-descriptor",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_native-descriptor"
				},
				｢en#type/IO/Socket/Async#016｣ => {
					｢targ-in-fn｣ => "method_peer-port",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#016\")},\n      paragraphs  => (\n        \"method peer-port\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method peer-port(--> Int)\\n\\n\",\n      )\n    ),\n    \"Returns the port of the remote end of this socket.\\n\\n\",\n  )\n)",
					｢name｣       => "peer-port",
					｢kind｣       => "routine",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Socket/Async#002｣ => {
					｢name｣       => "connect-path",
					｢targ-in-fn｣ => "method_connect-path",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#002\")},\n      paragraphs  => (\n        \"method connect-path\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method connect-path(Str \\\$path --> Promise)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Attempts to connect to a unix domain stream socket specified by \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \",\\nreturning a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Promise\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Promise\",\n        )\n      ),\n      \" that will either be kept with a\\nconnected \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Socket::Async\",\n        )\n      ),\n      \" or broken if the connection cannot be\\nmade.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Socket/Async#005｣ => {
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#005\")},\n      paragraphs  => (\n        \"method udp\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method udp(IO::Socket::Async:U: :\\\$broadcast --> IO::Socket::Async)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns an initialized \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Socket::Async\",\n        )\n      ),\n      \" client object that is\\nconfigured to send UDP messages using \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"print-to\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"write-to\",\n        )\n      ),\n      \".  The\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":broadcast\",\n        )\n      ),\n      \" adverb will set the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"SO_BROADCAST\",\n        )\n      ),\n      \" option which will\\nallow the socket to send packets to a broadcast address.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_udp",
					｢subkind｣    => "method",
					｢name｣       => "udp"
				},
				｢en#type/IO/Socket/Async#001｣ => {
					｢name｣       => "connect",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#001\")},\n      paragraphs  => (\n        \"method connect\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method connect(Str \\\$host, Int \\\$port --> Promise)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Attempts to connect to the TCP server specified by \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$host\",\n        )\n      ),\n      \" and\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$port\",\n        )\n      ),\n      \", returning a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Promise\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Promise\",\n        )\n      ),\n      \" that will either be kept with a\\nconnected \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Socket::Async\",\n        )\n      ),\n      \" or broken if the connection cannot be\\nmade.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_connect",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Socket/Async#007｣ => {
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_print",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#007\")},\n      paragraphs  => (\n        \"method print\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method print(IO::Socket::Async:D: Str \\\$str --> Promise)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Attempt to send \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$str\",\n        )\n      ),\n      \" on the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Socket::Async\",\n        )\n      ),\n      \" that will have been\\nobtained indirectly via \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"connect\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"listen\",\n        )\n      ),\n      \", returning a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Promise\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Promise\",\n        )\n      ),\n      \"\\nthat will be kept with the number of bytes sent or broken if there was\\nan error sending.\\n\\n\"\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢name｣       => "print"
				},
				｢en#type/IO/Socket/Async#004｣ => {
					｢name｣       => "listen-path",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_listen-path",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#004\")},\n      paragraphs  => (\n        \"method listen-path\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method listen-path(Str \\\$path)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Creates a unix domain stream listening socket on the specified \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \",\\nreturning a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Supply\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Supply\",\n        )\n      ),\n      \" to which the accepted client\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Socket::Async\",\n        )\n      ),\n      \"s will be emitted. This\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Supply\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Supply\",\n        )\n      ),\n      \" should be tapped start listening for client\\nconnections.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Socket::Async::ListenSocket\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Socket::Async::ListenSocket\",\n        )\n      ),\n      \"\\nreturned by calling the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"tap\",\n        ),\n        meta   => (\n          \"/type/Supply#method_tap\",\n        )\n      ),\n      \" method on the supply\\nreturned represents the underlying listening TCP socket, which can be closed\\nusing its \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"close\",\n        ),\n        meta   => (\n          \"/type/Tap#method_close\",\n        )\n      ),\n      \" method.\\n\\n\"\n    ),\n  )\n)",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Socket/Async#008｣ => {
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#008\")},\n      paragraphs  => (\n        \"method print-to\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method print-to(IO::Socket::Async:D: Str() \\\$host, Int() \\\$port, Str() \\\$str --> Promise)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This is the equivalent of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"print\",\n        )\n      ),\n      \" for UDP sockets that have been\\ncreated with the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"udp\",\n        )\n      ),\n      \" method, it will try send a UDP message of\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$str\",\n        )\n      ),\n      \" to the specified \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$host\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$port\",\n        )\n      ),\n      \" returning a\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Promise\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Promise\",\n        )\n      ),\n      \" that will be kept when the data is successfully\\nsent or broken if it was unable to send the data. In order to send to a\\nbroadcast address the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":broadcast\",\n        )\n      ),\n      \" flag must have been specified when\\nthe socket was created.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_print-to",
					｢subkind｣    => "method",
					｢name｣       => "print-to"
				},
				｢en#type/IO/Socket/Async#003｣ => {
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢name｣       => "listen",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#003\")},\n      paragraphs  => (\n        \"method listen\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method listen(Str \\\$host, Int \\\$port --> Supply)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Creates a listening socket on the specified \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$host\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$port\",\n        )\n      ),\n      \",\\nreturning a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Supply\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Supply\",\n        )\n      ),\n      \" to which the accepted client\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Socket::Async\",\n        )\n      ),\n      \"s will be emitted. This\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Supply\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Supply\",\n        )\n      ),\n      \" should be tapped start listening for client\\nconnections.  You can set \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$port\",\n        )\n      ),\n      \" to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"0\",\n        )\n      ),\n      \" if you want the operating\\nsystem to find one for you.\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Socket::Async::ListenSocket\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Socket::Async::ListenSocket\",\n        )\n      ),\n      \"\\nreturned by calling the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"tap\",\n        ),\n        meta   => (\n          \"/type/Supply#method_tap\",\n        )\n      ),\n      \" method on the supply\\nreturned represents the underlying listening TCP socket, which can be closed\\nusing its \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"close\",\n        ),\n        meta   => (\n          \"/type/Tap#method_close\",\n        )\n      ),\n      \" method. If \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$port\",\n        )\n      ),\n      \" was set to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"0\",\n        )\n      ),\n      \",\\nyou can get the port the socket ended up with using its\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"socket-port\",\n        ),\n        meta   => (\n          \"/type/IO::Socket::Async::ListenSocket#method_socket-port\",\n        )\n      ),\n      \" method.\\n\\n\"\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_listen"
				},
				｢en#type/IO/Socket/Async#012｣ => {
					｢targ-in-fn｣ => "method_close",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#012\")},\n      paragraphs  => (\n        \"method close\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method close(IO::Socket::Async:D: )\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Close the connected client \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Socket::Async\",\n        )\n      ),\n      \" which will have been\\nobtained from the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"listen\",\n        )\n      ),\n      \" \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Supply\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Supply\",\n        )\n      ),\n      \" or the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"connect\",\n        )\n      ),\n      \"\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Promise\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Promise\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"In order to close the underlying listening socket created by \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"listen\",\n        )\n      ),\n      \" you can\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"close\",\n        )\n      ),\n      \" the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Socket::Async::ListenSocket\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Socket::Async::ListenSocket\",\n        )\n      ),\n      \". See\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"listen\",\n        ),\n        meta   => (\n          \"#method_listen\",\n        )\n      ),\n      \" for examples.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "close"
				},
				｢en#type/IO/Socket/Async#014｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#014\")},\n      paragraphs  => (\n        \"method peer-host\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method peer-host(--> Str)\\n\\n\",\n      )\n    ),\n    \"Returns the IP address of the remote end of this socket.\\n\\n\",\n  )\n)",
					｢targ-in-fn｣ => "method_peer-host",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢name｣       => "peer-host"
				},
				｢en#type/IO/Socket/Async#013｣ => {
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢name｣       => "socket-host",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#013\")},\n      paragraphs  => (\n        \"method socket-host\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method socket-host(--> Str)\\n\\n\",\n      )\n    ),\n    \"Returns the IP address of the local end of this socket.\\n\\n\",\n  )\n)",
					｢targ-in-fn｣ => "method_socket-host"
				},
				｢en#type/IO/Socket/Async#009｣ => {
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_write",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#009\")},\n      paragraphs  => (\n        \"method write\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method write(IO::Socket::Async:D: Blob \\\$b --> Promise)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This method will attempt to send the bytes in \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$b\",\n        )\n      ),\n      \" on the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Socket::Async\",\n        )\n      ),\n      \" that will have been obtained indirectly via\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"connect\",\n        )\n      ),\n      \" or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"listen\",\n        )\n      ),\n      \", returning a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Promise\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Promise\",\n        )\n      ),\n      \" that will be kept with\\nthe number of bytes sent or broken if there was an error sending.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "write"
				},
				｢en#type/IO/Socket/Async#015｣ => {
					｢kind｣       => "routine",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#015\")},\n      paragraphs  => (\n        \"method socket-port\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method socket-port(--> Int)\\n\\n\",\n      )\n    ),\n    \"Returns the port of the local end of this socket.\\n\\n\",\n  )\n)",
					｢targ-in-fn｣ => "method_socket-port",
					｢subkind｣    => "method",
					｢name｣       => "socket-port"
				},
				｢en#type/IO/Socket/Async#006｣ => {
					｢targ-in-fn｣ => "method_bind-udp",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Socket/Async#006\")},\n      paragraphs  => (\n        \"method bind-udp\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method bind-udp(IO::Socket::Async:U: Str() \\\$host, Int() \\\$port, :\\\$broadcast --> IO::Socket::Async)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"This returns an initialized \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"IO::Socket::Async\",\n        )\n      ),\n      \" server object that is\\nconfigured to receive UDP messages sent to the specified \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$host\",\n        )\n      ),\n      \" and\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$port\",\n        )\n      ),\n      \" and is equivalent to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"listen\",\n        )\n      ),\n      \" for a TCP socket.  The\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":broadcast\",\n        )\n      ),\n      \" adverb can be specified to allow the receipt of messages\\nsent to the broadcast address.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "bind-udp"
				}
			},
			｢config｣     => {
				｢kind｣     => "Type",
				｢subkind｣  => "class",
				｢category｣ => "domain-specific"
			},
			｢modified｣   => "Instant.from-posix(1716570626.140091333)",
			｢xtrk-targs｣ => {}
		},
		｢routine/join｣                      => {
			｢subtitle｣ => "From: en/type/IO/Spec/Cygwin, en/type/IO/Spec/Win32, en/type/IO/Spec/Unix.",
			｢modified｣ => "Instant.from-posix(1742118640.985436938)",
			｢title｣    => "The <b>join</b> routine",
			｢config｣   => {
				｢kind｣  => "routine",
				｢index｣ => False
			},
			｢type｣     => "composite"
		},
		｢type/IO/Spec/Win32｣                => {
			｢title｣      => "class IO::Spec::Win32",
			｢config｣     => {
				｢category｣ => "domain-specific",
				｢subkind｣  => "class",
				｢kind｣     => "Type"
			},
			｢type｣       => "primary",
			｢xtrk-targs｣ => {},
			｢toc｣        => [
				{
						｢target｣     => "Methods",
						｢numeration｣ => "",
						｢caption｣    => "Methods",
						｢level｣      => 1
				},
				{
						｢caption｣    => "method basename",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_basename"
				},
				{
						｢target｣     => "method_canonpath",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method canonpath"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢target｣     => "method_catdir",
						｢caption｣    => "method catdir"
				},
				{
						｢level｣      => "2",
						｢target｣     => "method_catfile",
						｢caption｣    => "method catfile",
						｢numeration｣ => ""
				},
				{
						｢level｣      => "2",
						｢target｣     => "method_catpath",
						｢numeration｣ => "",
						｢caption｣    => "method catpath"
				},
				{
						｢caption｣    => "method devnull",
						｢level｣      => "2",
						｢numeration｣ => "",
						｢target｣     => "method_devnull"
				},
				{
						｢level｣      => "2",
						｢target｣     => "method_dir-sep",
						｢numeration｣ => "",
						｢caption｣    => "method dir-sep"
				},
				{
						｢level｣      => "2",
						｢caption｣    => "method is-absolute",
						｢target｣     => "method_is-absolute",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢caption｣    => "method join",
						｢target｣     => "method_join",
						｢level｣      => "2"
				},
				{
						｢target｣     => "method_path",
						｢level｣      => "2",
						｢caption｣    => "method path",
						｢numeration｣ => ""
				},
				{
						｢target｣     => "method_rel2abs",
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method rel2abs"
				},
				{
						｢target｣     => "method_rootdir",
						｢numeration｣ => "",
						｢caption｣    => "method rootdir",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢target｣     => "method_split",
						｢caption｣    => "method split",
						｢level｣      => "2"
				},
				{
						｢caption｣    => "method splitdir",
						｢level｣      => "2",
						｢target｣     => "method_splitdir",
						｢numeration｣ => ""
				},
				{
						｢numeration｣ => "",
						｢target｣     => "method_splitpath",
						｢caption｣    => "method splitpath",
						｢level｣      => "2"
				},
				{
						｢numeration｣ => "",
						｢level｣      => "2",
						｢caption｣    => "method tmpdir",
						｢target｣     => "method_tmpdir"
				},
				{
						｢numeration｣ => "",
						｢level｣      => 1,
						｢caption｣    => "Class relation diagram",
						｢target｣     => "Class_relation_diagram"
				}
			],
			｢subtitle｣   => "Platform specific operations on file and directory paths for Windows",
			｢defns｣      => {
				｢en#type/IO/Spec/Win32#015｣ => {
					｢name｣       => "splitpath",
					｢targ-in-fn｣ => "method_splitpath",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#015\")},\n      paragraphs  => (\n        \"method splitpath\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method splitpath(Cool:D \\\$path, :\\\$nofile --> List:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Splits the given \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" into a list of 3 strings: volume,\\ndirname, and file. The volume is always an empty string, returned for API\\ncompatibility with other \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Spec\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Spec\",\n        )\n      ),\n      \" types. If \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$nofile\",\n        )\n      ),\n      \" named argument is\\nset to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \", the content of the file string is undefined and should be\\nignored; this is a means to get a performance boost, as implementations may use\\nfaster code path when file is not needed.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"IO::Spec::Win32.splitpath('C:\\\\foo/bar.txt').raku.say;\\n# OUTPUT: «(\\\"C:\\\", \\\"\\\\\\\\foo/\\\", \\\"bar.txt\\\")␤»\\n\\nIO::Spec::Win32.splitpath('C:\\\\foo/bar.txt', :nofile).raku.say;\\n# OUTPUT: «(\\\"C:\\\", \\\"\\\\\\\\foo/bar.txt\\\", \\\"\\\")␤»\\n\\nIO::Spec::Win32.splitpath('/foo/').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"/foo/\\\", \\\"\\\")␤»\\n\\nIO::Spec::Win32.splitpath('/foo/', :nofile).raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"/foo/\\\", \\\"\\\")␤»\\n\\nIO::Spec::Win32.splitpath('///').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"///\\\", \\\"\\\")␤»\\n\\nIO::Spec::Win32.splitpath('./').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"./\\\", \\\"\\\")␤»\\n\\nIO::Spec::Win32.splitpath('.').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"\\\", \\\".\\\")␤»\\n\\nIO::Spec::Win32.splitpath('').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"\\\", \\\"\\\")␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢subkind｣    => "method"
				},
				｢en#type/IO/Spec/Win32#004｣ => {
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#004\")},\n      paragraphs  => (\n        \"method catfile\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Alias for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"catdir\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/catdir\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "catfile",
					｢targ-in-fn｣ => "method_catfile"
				},
				｢en#type/IO/Spec/Win32#007｣ => {
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#007\")},\n      paragraphs  => (\n        \"method dir-sep\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method dir-sep(--> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the string \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"｢\\\\｣\",\n        )\n      ),\n      \" representing canonical directory separator\\ncharacter.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"IO::Spec::Win32.dir-sep.say; # OUTPUT: «\\\\␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "dir-sep",
					｢targ-in-fn｣ => "method_dir-sep",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Spec/Win32#009｣ => {
					｢targ-in-fn｣ => "method_join",
					｢name｣       => "join",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#009\")},\n      paragraphs  => (\n        \"method join\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method join (Str:D \\\$volume, Str:D \\\$dir, Str:D \\\$file --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Similar to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"catpath\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/catpath\",\n        )\n      ),\n      \", takes two path fragments and\\nconcatenates them, adding or removing a path separator, if necessary,\\nexcept it will return just \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$file\",\n        )\n      ),\n      \" if both \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$dir\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$file\",\n        )\n      ),\n      \" are\\nstring \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"'/'\",\n        )\n      ),\n      \" or if \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$dir\",\n        )\n      ),\n      \" is the string \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"'.'\",\n        )\n      ),\n      \". The first argument is\\nignored (it exists to maintain consistent interface with other\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Spec\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Spec\",\n        )\n      ),\n      \" types for systems that have volumes).\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Win32.join('C:', '/some/dir', 'foo.txt').say;\\n# OUTPUT: «C:/some/dir\\\\and/more␤»\\n\\nIO::Spec::Win32.join('C:', '.', 'foo.txt').say;\\n# OUTPUT: «C:foo.txt␤»\\n\\nIO::Spec::Win32.join('C:', ｢\\\\｣, '/').say;\\n# OUTPUT: «C:\\\\␤»\\n\\nIO::Spec::Win32.join('//server/share', ｢\\\\｣, '/').say;\\n# OUTPUT: «//server/share␤»\\n\\nIO::Spec::Win32.join('E:', '', 'foo.txt').say;\\n# OUTPUT: «E:foo.txt␤»\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#type/IO/Spec/Win32#003｣ => {
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_catdir",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#003\")},\n      paragraphs  => (\n        \"method catdir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method catdir (*\\\@parts --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Concatenates multiple path fragments and returns the canonical\\nrepresentation of the resultant path as a string. The \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\@parts\",\n        )\n      ),\n      \" are\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Str\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Str\",\n        )\n      ),\n      \" objects and are allowed to contain path separators.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Win32.catdir(<foo/bar ber raku>).say;\\n# OUTPUT: «foo\\\\bar\\\\ber\\\\raku␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "catdir"
				},
				｢en#type/IO/Spec/Win32#016｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#016\")},\n      paragraphs  => (\n        \"method tmpdir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"        \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method tmpdir(--> IO::Path:D)\\n\\n\",\n      )\n    ),\n    \"Attempts to locate a system's temporary directory by checking several typical directories and environment variables. Uses current directory if no suitable directories are found.\\n\\n\",\n  )\n)",
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_tmpdir",
					｢name｣       => "tmpdir"
				},
				｢en#type/IO/Spec/Win32#014｣ => {
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_splitdir",
					｢name｣       => "splitdir",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#014\")},\n      paragraphs  => (\n        \"method splitdir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method splitdir(Cool:D \\\$path --> List:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Splits the given \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" on slashes and backslashes.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"IO::Spec::Win32.splitdir('C:\\\\foo/bar.txt').raku.say;\\n# OUTPUT: «(\\\"C:\\\", \\\"foo\\\", \\\"bar.txt\\\")␤»\\n\\nIO::Spec::Win32.splitdir('/foo/').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"foo\\\", \\\"\\\")␤»\\n\\nIO::Spec::Win32.splitdir('///').raku.say;\\n# OUTPUT: «(\\\"\\\", \\\"\\\", \\\"\\\", \\\"\\\")␤»\\n\\nIO::Spec::Win32.splitdir('./').raku.say;\\n# OUTPUT: «(\\\".\\\", \\\"\\\")␤»\\n\\nIO::Spec::Win32.splitdir('.').raku.say;\\n# OUTPUT: «(\\\".\\\",)␤»\\n\\nIO::Spec::Win32.splitdir('').raku.say;\\n# OUTPUT: «(\\\"\\\",)␤»\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Spec/Win32#011｣ => {
					｢kind｣       => "routine",
					｢name｣       => "rel2abs",
					｢subkind｣    => "method",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#011\")},\n      paragraphs  => (\n        \"method rel2abs\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method rel2abs(Str() \\\$path, \\\$base = \\\$*CWD --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a string representing \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" converted to absolute path, based at\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$base\",\n        )\n      ),\n      \", which defaults to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*CWD\",\n        )\n      ),\n      \". If \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$base\",\n        )\n      ),\n      \" is not an absolute path,\\nit will be made absolute relative to \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*CWD\",\n        )\n      ),\n      \", unless \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$*CWD\",\n        )\n      ),\n      \" and \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$base\",\n        )\n      ),\n      \"\\nare the same.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"say \\\$*CWD;                                   # OUTPUT: «\\\"C:\\\\Users\\\\camelia\\\".IO␤»\\n\\nsay IO::Spec::Win32.rel2abs: 'foo';          # OUTPUT: «C:\\\\Users\\\\camelia\\\\foo␤»\\nsay IO::Spec::Win32.rel2abs: './';           # OUTPUT: «C:\\\\Users\\\\camelia␤»\\nsay IO::Spec::Win32.rel2abs: 'foo/../../';   # OUTPUT: «C:\\\\Users\\\\camelia\\\\foo\\\\..\\\\..␤»\\nsay IO::Spec::Win32.rel2abs: '/foo/';        # OUTPUT: «C:\\\\foo␤»\\n\\nsay IO::Spec::Win32.rel2abs: 'foo', 'bar';   # OUTPUT: «C:\\\\Users\\\\camelia\\\\bar\\\\foo␤»\\nsay IO::Spec::Win32.rel2abs: './', '/bar';   # OUTPUT: «\\\\bar␤»\\nsay IO::Spec::Win32.rel2abs: '/foo/', 'bar'; # OUTPUT: «C:\\\\foo␤»\\n\\nsay IO::Spec::Win32.rel2abs: 'foo/../../', 'bar';\\n# OUTPUT: «C:\\\\Users\\\\camelia\\\\bar\\\\foo\\\\..\\\\..␤»\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_rel2abs"
				},
				｢en#type/IO/Spec/Win32#001｣ => {
					｢name｣       => "basename",
					｢targ-in-fn｣ => "method_basename",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#001\")},\n      paragraphs  => (\n        \"method basename\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method basename(Str:D \\\$path --> Str:D)\\n\\n\",\n      )\n    ),\n    \"Takes a path as a string and returns a possibly-empty portion after the\\nlast slash or backslash:\\n\\n\",\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Win32.basename(\\\"foo/bar/\\\") .raku.say; # OUTPUT: «\\\"\\\"␤»\\nIO::Spec::Win32.basename(\\\"foo/bar\\\\\\\\\\\").raku.say; # OUTPUT: «\\\"\\\"␤»\\nIO::Spec::Win32.basename(\\\"foo/bar/.\\\").raku.say; # OUTPUT: «\\\".\\\"␤»\\nIO::Spec::Win32.basename(\\\"foo/bar\\\")  .raku.say; # OUTPUT: «\\\"bar\\\"␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢subkind｣    => "method",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Spec/Win32#005｣ => {
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_catpath",
					｢subkind｣    => "method",
					｢name｣       => "catpath",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#005\")},\n      paragraphs  => (\n        \"method catpath\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method catpath (Str:D \\\$volume, Str:D \\\$dir, Str:D \\\$file --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Concatenates a path from given volume, a chain of directories, and file.\\nAn empty string can be given for any of the three arguments. No attempt\\nto make the path canonical is made. Use\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"canonpath\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/routine/canonpath\",\n        )\n      ),\n      \" for that purpose.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Win32.catpath('C:', '/some/dir', 'foo.txt').say;\\n# OUTPUT: «C:/some/dir\\\\foo.txt␤»\\n\\nIO::Spec::Win32.catpath('C:', '/some/dir', '').say;\\n# OUTPUT: «C:/some/dir␤»\\n\\nIO::Spec::Win32.catpath('', '/some/dir', 'foo.txt').say;\\n# OUTPUT: «/some/dir\\\\foo.txt␤»\\n\\nIO::Spec::Win32.catpath('E:', '', 'foo.txt').say;\\n# OUTPUT: «E:foo.txt␤»\\n\\n\",\n      )\n    ),\n  )\n)"
				},
				｢en#type/IO/Spec/Win32#002｣ => {
					｢kind｣       => "routine",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_canonpath",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#002\")},\n      paragraphs  => (\n        \"method canonpath\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method canonpath(Str() \\\$path, :\\\$parent --> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns a string that is a canonical representation of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \". If \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \":\\\$parent\",\n        )\n      ),\n      \"\\nis set to true, will also clean up references to parent directories. \",\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"NOTE:\",\n        )\n      ),\n      \"\\nthe routine does not access the filesystem.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"IO::Spec::Win32.canonpath(\\\"C:/foo//../bar/../ber\\\").say;\\n# OUTPUT: «C:\\\\foo\\\\..\\\\bar\\\\..\\\\ber␤»\\n\\nIO::Spec::Win32.canonpath(\\\"C:/foo///./../bar/../ber\\\").say;\\n# OUTPUT: «C:\\\\foo\\\\..\\\\bar\\\\..\\\\ber␤»\\n\\nIO::Spec::Win32.canonpath(\\\"C:/foo///./../bar/../ber\\\", :parent).say;\\n# OUTPUT: «C:\\\\ber␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢name｣       => "canonpath"
				},
				｢en#type/IO/Spec/Win32#013｣ => {
					｢targ-in-fn｣ => "method_split",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢name｣       => "split",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#013\")},\n      paragraphs  => (\n        \"method split\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method split(IO::Spec::Win32: Cool:D \\\$path)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Creates an \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"IO::Path::Parts\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/IO::Path::Parts\",\n        )\n      ),\n      \" for \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \".\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      paragraphs => (\n        \"IO::Spec::Win32.split('C:/foo/bar.txt').raku.say;\\n# OUTPUT: «IO::Path::Parts.new(\\\"C:\\\",\\\"/foo\\\",\\\"bar.txt\\\")␤»\\n\\nIO::Spec::Win32.split('/foo/').raku.say;\\n# OUTPUT: «IO::Path::Parts.new(\\\"\\\",\\\"/\\\",\\\"foo\\\")␤»\\n\\nIO::Spec::Win32.split('///').raku.say;\\n# OUTPUT: «IO::Path::Parts.new(\\\"\\\",\\\"/\\\",\\\"\\\\\\\\\\\")␤»\\n\\nIO::Spec::Win32.split('./').raku.say;\\n# OUTPUT: «IO::Path::Parts.new(\\\"\\\",\\\".\\\",\\\".\\\")␤»\\n\\nIO::Spec::Win32.split('.').raku.say;\\n# OUTPUT: «IO::Path::Parts.new(\\\"\\\",\\\".\\\",\\\".\\\")␤»\\n\\nIO::Spec::Win32.split('').raku.say;\\n# OUTPUT: «IO::Path::Parts.new(\\\"\\\",\\\"\\\",\\\"\\\")␤»\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      RakuAST::Doc::Markup.new(\n        letter => \"B\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"Note\",\n        )\n      ),\n      \": Before Rakudo version 2020.06 this method split the given\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" into \\\"volume\\\", \\\"dirname\\\", and \\\"basename\\\" and returned the result\\nas a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"List\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/List\",\n        )\n      ),\n      \" of three \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Pair\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Pair\",\n        )\n      ),\n      \"s, in that order.\\n\\n\"\n    ),\n  )\n)"
				},
				｢en#type/IO/Spec/Win32#006｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#006\")},\n      paragraphs  => (\n        \"method devnull\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method devnull(--> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns the string \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\"nul\\\"\",\n        )\n      ),\n      \" representing the\\n\",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\"Null device\\\"\",\n        ),\n        meta   => (\n          \"https://en.wikipedia.org/wiki/Null_device\",\n        )\n      ),\n      \":\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      type       => \"code\",\n      for        => True,\n      paragraphs => (\n        \"\\\$*SPEC.devnull.IO.spurt: \\\"foo bar baz\\\";\\n\\n\",\n      )\n    ),\n  )\n)",
					｢targ-in-fn｣ => "method_devnull",
					｢subkind｣    => "method",
					｢kind｣       => "routine",
					｢name｣       => "devnull"
				},
				｢en#type/IO/Spec/Win32#012｣ => {
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#012\")},\n      paragraphs  => (\n        \"method rootdir\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method rootdir(--> Str:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns string \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"｢\\\\｣\",\n        )\n      ),\n      \", representing root directory.\\n\\n\"\n    ),\n  )\n)",
					｢name｣       => "rootdir",
					｢subkind｣    => "method",
					｢targ-in-fn｣ => "method_rootdir",
					｢kind｣       => "routine"
				},
				｢en#type/IO/Spec/Win32#010｣ => {
					｢subkind｣    => "method",
					｢name｣       => "path",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#010\")},\n      paragraphs  => (\n        \"method path\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method path(--> Seq:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Splits the value of \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"\\\%*EN\",\n          RakuAST::Doc::Markup.new(\n            letter => \"V\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"PATH\",\n            )\n          ),\n        )\n      ),\n      \" (or \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"«\",\n        closer => \"»\",\n        atoms  => (\n          \"\\\%*EN\",\n          RakuAST::Doc::Markup.new(\n            letter => \"V\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Path\",\n            )\n          ),\n        )\n      ),\n      \" if the former is not set)\\non semicolons (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\";\\\"\",\n        )\n      ),\n      \") and returns a \",\n      RakuAST::Doc::Markup.new(\n        letter => \"L\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          RakuAST::Doc::Markup.new(\n            letter => \"C\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"Seq\",\n            )\n          ),\n        ),\n        meta   => (\n          \"/type/Seq\",\n        )\n      ),\n      \" with each of the resultant\\nparts, always adding element \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\".\\\"\",\n        )\n      ),\n      \" to the head. Removes all double\\nquotes (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\"\",\n        )\n      ),\n      \") it finds.\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        RakuAST::Doc::Paragraph.new(\n          \"\\\%*EN\",\n          RakuAST::Doc::Markup.new(\n            letter => \"V\",\n            opener => \"<\",\n            closer => \">\",\n            atoms  => (\n              \"PATH\",\n            )\n          ),\n          \" = 'foo;\\\"bar\\\"/\\\"ber\\\"';\\nIO::Spec::Win32.path.raku.say; # OUTPUT: «(\\\".\\\", \\\"foo\\\", \\\"bar/ber\\\").Seq␤»\\n\\n\"\n        ),\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_path"
				},
				｢en#type/IO/Spec/Win32#008｣ => {
					｢subkind｣    => "method",
					｢name｣       => "is-absolute",
					｢snip｣       => "RakuAST::Doc::Block.new(\n  type       => \"section\",\n  paragraphs => (\n    RakuAST::Doc::Block.new(\n      type        => \"head\",\n      level       => \"2\",\n      abbreviated => True,\n      config      => \$\{:Elucid8-composite(Bool::True), :xtr-trgt(\"en#type/IO/Spec/Win32#008\")},\n      paragraphs  => (\n        \"method is-absolute\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"method is-absolute(Str:D \\\$path --> Bool:D)\\n\\n\",\n      )\n    ),\n    RakuAST::Doc::Paragraph.new(\n      \"Returns \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"True\",\n        )\n      ),\n      \" if the \",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\$path\",\n        )\n      ),\n      \" starts with a slash (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\"/\\\"\",\n        )\n      ),\n      \") or\\nbackslash (\",\n      RakuAST::Doc::Markup.new(\n        letter => \"C\",\n        opener => \"<\",\n        closer => \">\",\n        atoms  => (\n          \"\\\"\\\\\\\"\",\n        )\n      ),\n      \"), even if they have combining character on them,\\noptionally preceded by a volume:\\n\\n\"\n    ),\n    RakuAST::Doc::Block.new(\n      margin     => \"    \",\n      type       => \"implicit-code\",\n      paragraphs => (\n        \"say IO::Spec::Win32.is-absolute: \\\"/foo\\\";        # OUTPUT: «True␤»\\nsay IO::Spec::Win32.is-absolute: \\\"/\\\\x[308]foo\\\"; # OUTPUT: «True␤»\\nsay IO::Spec::Win32.is-absolute: ｢C:\\\\foo｣;      # OUTPUT: «True␤»\\nsay IO::Spec::Win32.is-absolute: \\\"bar\\\";         # OUTPUT: «False␤»\\n\\n\",\n      )\n    ),\n  )\n)",
					｢kind｣       => "routine",
					｢targ-in-fn｣ => "method_is-absolute"
				}
			},
			｢index｣      => {},
			｢modified｣   => "Instant.from-posix(1730070864.911096399)"
		},
		｢all-syntax｣                        => {
			｢subtitle｣   => "Searchable table of documented syntactic elements",
			｢index｣      => {},
			｢xtrk-targs｣ => {},
			｢toc｣        => [],
			｢modified｣   => "Instant.from-posix(1741013229.915900139)",
			｢title｣      => "Syntax items in Raku",
			｢defns｣      => {},
			｢type｣       => "info",
			｢config｣     => {
				｢index｣ => False,
				｢toc｣   => False,
				｢type｣  => "info"
			}
		}
	}
}